
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model agent
 * 
 */
export type agent = $Result.DefaultSelection<Prisma.$agentPayload>
/**
 * Model basecountry
 * 
 */
export type basecountry = $Result.DefaultSelection<Prisma.$basecountryPayload>
/**
 * Model currency
 * 
 */
export type currency = $Result.DefaultSelection<Prisma.$currencyPayload>
/**
 * Model customer
 * 
 */
export type customer = $Result.DefaultSelection<Prisma.$customerPayload>
/**
 * Model customerauditlogs
 * 
 */
export type customerauditlogs = $Result.DefaultSelection<Prisma.$customerauditlogsPayload>
/**
 * Model exchangerates
 * 
 */
export type exchangerates = $Result.DefaultSelection<Prisma.$exchangeratesPayload>
/**
 * Model formstatus
 * 
 */
export type formstatus = $Result.DefaultSelection<Prisma.$formstatusPayload>
/**
 * Model formvisibilitystatus
 * 
 */
export type formvisibilitystatus = $Result.DefaultSelection<Prisma.$formvisibilitystatusPayload>
/**
 * Model fundraiser
 * 
 */
export type fundraiser = $Result.DefaultSelection<Prisma.$fundraiserPayload>
/**
 * Model fundraiser_acceptedcurrencies
 * 
 */
export type fundraiser_acceptedcurrencies = $Result.DefaultSelection<Prisma.$fundraiser_acceptedcurrenciesPayload>
/**
 * Model fundraiser_contactlinks
 * 
 */
export type fundraiser_contactlinks = $Result.DefaultSelection<Prisma.$fundraiser_contactlinksPayload>
/**
 * Model manychat
 * 
 */
export type manychat = $Result.DefaultSelection<Prisma.$manychatPayload>
/**
 * Model minimumamount
 * 
 */
export type minimumamount = $Result.DefaultSelection<Prisma.$minimumamountPayload>
/**
 * Model note
 * 
 */
export type note = $Result.DefaultSelection<Prisma.$notePayload>
/**
 * Model platform
 * 
 */
export type platform = $Result.DefaultSelection<Prisma.$platformPayload>
/**
 * Model screenshot
 * 
 */
export type screenshot = $Result.DefaultSelection<Prisma.$screenshotPayload>
/**
 * Model supportregion
 * 
 */
export type supportregion = $Result.DefaultSelection<Prisma.$supportregionPayload>
/**
 * Model transactionagent
 * 
 */
export type transactionagent = $Result.DefaultSelection<Prisma.$transactionagentPayload>
/**
 * Model transactions
 * 
 */
export type transactions = $Result.DefaultSelection<Prisma.$transactionsPayload>
/**
 * Model transactionstatus
 * 
 */
export type transactionstatus = $Result.DefaultSelection<Prisma.$transactionstatusPayload>
/**
 * Model userrole
 * 
 */
export type userrole = $Result.DefaultSelection<Prisma.$userrolePayload>
/**
 * Model wallet
 * 
 */
export type wallet = $Result.DefaultSelection<Prisma.$walletPayload>
/**
 * Model testing_new_table
 * 
 */
export type testing_new_table = $Result.DefaultSelection<Prisma.$testing_new_tablePayload>
/**
 * Model testing_new_table2
 * 
 */
export type testing_new_table2 = $Result.DefaultSelection<Prisma.$testing_new_table2Payload>

/**
 * Enums
 */
export namespace $Enums {
  export const customerauditlogs_FieldChanged: {
  Name: 'Name',
  Email: 'Email',
  UserCountry: 'UserCountry'
};

export type customerauditlogs_FieldChanged = (typeof customerauditlogs_FieldChanged)[keyof typeof customerauditlogs_FieldChanged]

}

export type customerauditlogs_FieldChanged = $Enums.customerauditlogs_FieldChanged

export const customerauditlogs_FieldChanged: typeof $Enums.customerauditlogs_FieldChanged

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Agents
 * const agents = await prisma.agent.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Agents
   * const agents = await prisma.agent.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.agent`: Exposes CRUD operations for the **agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.agentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.basecountry`: Exposes CRUD operations for the **basecountry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Basecountries
    * const basecountries = await prisma.basecountry.findMany()
    * ```
    */
  get basecountry(): Prisma.basecountryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.currency`: Exposes CRUD operations for the **currency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Currencies
    * const currencies = await prisma.currency.findMany()
    * ```
    */
  get currency(): Prisma.currencyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.customerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customerauditlogs`: Exposes CRUD operations for the **customerauditlogs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customerauditlogs
    * const customerauditlogs = await prisma.customerauditlogs.findMany()
    * ```
    */
  get customerauditlogs(): Prisma.customerauditlogsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.exchangerates`: Exposes CRUD operations for the **exchangerates** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exchangerates
    * const exchangerates = await prisma.exchangerates.findMany()
    * ```
    */
  get exchangerates(): Prisma.exchangeratesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formstatus`: Exposes CRUD operations for the **formstatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Formstatuses
    * const formstatuses = await prisma.formstatus.findMany()
    * ```
    */
  get formstatus(): Prisma.formstatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.formvisibilitystatus`: Exposes CRUD operations for the **formvisibilitystatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Formvisibilitystatuses
    * const formvisibilitystatuses = await prisma.formvisibilitystatus.findMany()
    * ```
    */
  get formvisibilitystatus(): Prisma.formvisibilitystatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fundraiser`: Exposes CRUD operations for the **fundraiser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fundraisers
    * const fundraisers = await prisma.fundraiser.findMany()
    * ```
    */
  get fundraiser(): Prisma.fundraiserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fundraiser_acceptedcurrencies`: Exposes CRUD operations for the **fundraiser_acceptedcurrencies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fundraiser_acceptedcurrencies
    * const fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.findMany()
    * ```
    */
  get fundraiser_acceptedcurrencies(): Prisma.fundraiser_acceptedcurrenciesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fundraiser_contactlinks`: Exposes CRUD operations for the **fundraiser_contactlinks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fundraiser_contactlinks
    * const fundraiser_contactlinks = await prisma.fundraiser_contactlinks.findMany()
    * ```
    */
  get fundraiser_contactlinks(): Prisma.fundraiser_contactlinksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.manychat`: Exposes CRUD operations for the **manychat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manychats
    * const manychats = await prisma.manychat.findMany()
    * ```
    */
  get manychat(): Prisma.manychatDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.minimumamount`: Exposes CRUD operations for the **minimumamount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Minimumamounts
    * const minimumamounts = await prisma.minimumamount.findMany()
    * ```
    */
  get minimumamount(): Prisma.minimumamountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.note`: Exposes CRUD operations for the **note** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notes
    * const notes = await prisma.note.findMany()
    * ```
    */
  get note(): Prisma.noteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platform`: Exposes CRUD operations for the **platform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Platforms
    * const platforms = await prisma.platform.findMany()
    * ```
    */
  get platform(): Prisma.platformDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.screenshot`: Exposes CRUD operations for the **screenshot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Screenshots
    * const screenshots = await prisma.screenshot.findMany()
    * ```
    */
  get screenshot(): Prisma.screenshotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportregion`: Exposes CRUD operations for the **supportregion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Supportregions
    * const supportregions = await prisma.supportregion.findMany()
    * ```
    */
  get supportregion(): Prisma.supportregionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionagent`: Exposes CRUD operations for the **transactionagent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactionagents
    * const transactionagents = await prisma.transactionagent.findMany()
    * ```
    */
  get transactionagent(): Prisma.transactionagentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactions`: Exposes CRUD operations for the **transactions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transactions.findMany()
    * ```
    */
  get transactions(): Prisma.transactionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionstatus`: Exposes CRUD operations for the **transactionstatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactionstatuses
    * const transactionstatuses = await prisma.transactionstatus.findMany()
    * ```
    */
  get transactionstatus(): Prisma.transactionstatusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userrole`: Exposes CRUD operations for the **userrole** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Userroles
    * const userroles = await prisma.userrole.findMany()
    * ```
    */
  get userrole(): Prisma.userroleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wallet`: Exposes CRUD operations for the **wallet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Wallets
    * const wallets = await prisma.wallet.findMany()
    * ```
    */
  get wallet(): Prisma.walletDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testing_new_table`: Exposes CRUD operations for the **testing_new_table** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testing_new_tables
    * const testing_new_tables = await prisma.testing_new_table.findMany()
    * ```
    */
  get testing_new_table(): Prisma.testing_new_tableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.testing_new_table2`: Exposes CRUD operations for the **testing_new_table2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Testing_new_table2s
    * const testing_new_table2s = await prisma.testing_new_table2.findMany()
    * ```
    */
  get testing_new_table2(): Prisma.testing_new_table2Delegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    agent: 'agent',
    basecountry: 'basecountry',
    currency: 'currency',
    customer: 'customer',
    customerauditlogs: 'customerauditlogs',
    exchangerates: 'exchangerates',
    formstatus: 'formstatus',
    formvisibilitystatus: 'formvisibilitystatus',
    fundraiser: 'fundraiser',
    fundraiser_acceptedcurrencies: 'fundraiser_acceptedcurrencies',
    fundraiser_contactlinks: 'fundraiser_contactlinks',
    manychat: 'manychat',
    minimumamount: 'minimumamount',
    note: 'note',
    platform: 'platform',
    screenshot: 'screenshot',
    supportregion: 'supportregion',
    transactionagent: 'transactionagent',
    transactions: 'transactions',
    transactionstatus: 'transactionstatus',
    userrole: 'userrole',
    wallet: 'wallet',
    testing_new_table: 'testing_new_table',
    testing_new_table2: 'testing_new_table2'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "agent" | "basecountry" | "currency" | "customer" | "customerauditlogs" | "exchangerates" | "formstatus" | "formvisibilitystatus" | "fundraiser" | "fundraiser_acceptedcurrencies" | "fundraiser_contactlinks" | "manychat" | "minimumamount" | "note" | "platform" | "screenshot" | "supportregion" | "transactionagent" | "transactions" | "transactionstatus" | "userrole" | "wallet" | "testing_new_table" | "testing_new_table2"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      agent: {
        payload: Prisma.$agentPayload<ExtArgs>
        fields: Prisma.agentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.agentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.agentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agentPayload>
          }
          findFirst: {
            args: Prisma.agentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.agentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agentPayload>
          }
          findMany: {
            args: Prisma.agentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agentPayload>[]
          }
          create: {
            args: Prisma.agentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agentPayload>
          }
          createMany: {
            args: Prisma.agentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.agentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agentPayload>
          }
          update: {
            args: Prisma.agentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agentPayload>
          }
          deleteMany: {
            args: Prisma.agentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.agentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.agentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$agentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.agentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.agentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      basecountry: {
        payload: Prisma.$basecountryPayload<ExtArgs>
        fields: Prisma.basecountryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.basecountryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basecountryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.basecountryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basecountryPayload>
          }
          findFirst: {
            args: Prisma.basecountryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basecountryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.basecountryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basecountryPayload>
          }
          findMany: {
            args: Prisma.basecountryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basecountryPayload>[]
          }
          create: {
            args: Prisma.basecountryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basecountryPayload>
          }
          createMany: {
            args: Prisma.basecountryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.basecountryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basecountryPayload>
          }
          update: {
            args: Prisma.basecountryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basecountryPayload>
          }
          deleteMany: {
            args: Prisma.basecountryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.basecountryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.basecountryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$basecountryPayload>
          }
          aggregate: {
            args: Prisma.BasecountryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBasecountry>
          }
          groupBy: {
            args: Prisma.basecountryGroupByArgs<ExtArgs>
            result: $Utils.Optional<BasecountryGroupByOutputType>[]
          }
          count: {
            args: Prisma.basecountryCountArgs<ExtArgs>
            result: $Utils.Optional<BasecountryCountAggregateOutputType> | number
          }
        }
      }
      currency: {
        payload: Prisma.$currencyPayload<ExtArgs>
        fields: Prisma.currencyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.currencyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currencyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.currencyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currencyPayload>
          }
          findFirst: {
            args: Prisma.currencyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currencyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.currencyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currencyPayload>
          }
          findMany: {
            args: Prisma.currencyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currencyPayload>[]
          }
          create: {
            args: Prisma.currencyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currencyPayload>
          }
          createMany: {
            args: Prisma.currencyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.currencyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currencyPayload>
          }
          update: {
            args: Prisma.currencyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currencyPayload>
          }
          deleteMany: {
            args: Prisma.currencyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.currencyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.currencyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$currencyPayload>
          }
          aggregate: {
            args: Prisma.CurrencyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCurrency>
          }
          groupBy: {
            args: Prisma.currencyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CurrencyGroupByOutputType>[]
          }
          count: {
            args: Prisma.currencyCountArgs<ExtArgs>
            result: $Utils.Optional<CurrencyCountAggregateOutputType> | number
          }
        }
      }
      customer: {
        payload: Prisma.$customerPayload<ExtArgs>
        fields: Prisma.customerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findFirst: {
            args: Prisma.customerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findMany: {
            args: Prisma.customerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          create: {
            args: Prisma.customerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          createMany: {
            args: Prisma.customerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.customerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          update: {
            args: Prisma.customerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          deleteMany: {
            args: Prisma.customerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.customerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.customerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      customerauditlogs: {
        payload: Prisma.$customerauditlogsPayload<ExtArgs>
        fields: Prisma.customerauditlogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerauditlogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerauditlogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerauditlogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerauditlogsPayload>
          }
          findFirst: {
            args: Prisma.customerauditlogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerauditlogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerauditlogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerauditlogsPayload>
          }
          findMany: {
            args: Prisma.customerauditlogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerauditlogsPayload>[]
          }
          create: {
            args: Prisma.customerauditlogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerauditlogsPayload>
          }
          createMany: {
            args: Prisma.customerauditlogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.customerauditlogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerauditlogsPayload>
          }
          update: {
            args: Prisma.customerauditlogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerauditlogsPayload>
          }
          deleteMany: {
            args: Prisma.customerauditlogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customerauditlogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.customerauditlogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerauditlogsPayload>
          }
          aggregate: {
            args: Prisma.CustomerauditlogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomerauditlogs>
          }
          groupBy: {
            args: Prisma.customerauditlogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerauditlogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.customerauditlogsCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerauditlogsCountAggregateOutputType> | number
          }
        }
      }
      exchangerates: {
        payload: Prisma.$exchangeratesPayload<ExtArgs>
        fields: Prisma.exchangeratesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.exchangeratesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchangeratesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.exchangeratesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchangeratesPayload>
          }
          findFirst: {
            args: Prisma.exchangeratesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchangeratesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.exchangeratesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchangeratesPayload>
          }
          findMany: {
            args: Prisma.exchangeratesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchangeratesPayload>[]
          }
          create: {
            args: Prisma.exchangeratesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchangeratesPayload>
          }
          createMany: {
            args: Prisma.exchangeratesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.exchangeratesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchangeratesPayload>
          }
          update: {
            args: Prisma.exchangeratesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchangeratesPayload>
          }
          deleteMany: {
            args: Prisma.exchangeratesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.exchangeratesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.exchangeratesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$exchangeratesPayload>
          }
          aggregate: {
            args: Prisma.ExchangeratesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExchangerates>
          }
          groupBy: {
            args: Prisma.exchangeratesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExchangeratesGroupByOutputType>[]
          }
          count: {
            args: Prisma.exchangeratesCountArgs<ExtArgs>
            result: $Utils.Optional<ExchangeratesCountAggregateOutputType> | number
          }
        }
      }
      formstatus: {
        payload: Prisma.$formstatusPayload<ExtArgs>
        fields: Prisma.formstatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.formstatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formstatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.formstatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formstatusPayload>
          }
          findFirst: {
            args: Prisma.formstatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formstatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.formstatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formstatusPayload>
          }
          findMany: {
            args: Prisma.formstatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formstatusPayload>[]
          }
          create: {
            args: Prisma.formstatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formstatusPayload>
          }
          createMany: {
            args: Prisma.formstatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.formstatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formstatusPayload>
          }
          update: {
            args: Prisma.formstatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formstatusPayload>
          }
          deleteMany: {
            args: Prisma.formstatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.formstatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.formstatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formstatusPayload>
          }
          aggregate: {
            args: Prisma.FormstatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormstatus>
          }
          groupBy: {
            args: Prisma.formstatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormstatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.formstatusCountArgs<ExtArgs>
            result: $Utils.Optional<FormstatusCountAggregateOutputType> | number
          }
        }
      }
      formvisibilitystatus: {
        payload: Prisma.$formvisibilitystatusPayload<ExtArgs>
        fields: Prisma.formvisibilitystatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.formvisibilitystatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formvisibilitystatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.formvisibilitystatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formvisibilitystatusPayload>
          }
          findFirst: {
            args: Prisma.formvisibilitystatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formvisibilitystatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.formvisibilitystatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formvisibilitystatusPayload>
          }
          findMany: {
            args: Prisma.formvisibilitystatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formvisibilitystatusPayload>[]
          }
          create: {
            args: Prisma.formvisibilitystatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formvisibilitystatusPayload>
          }
          createMany: {
            args: Prisma.formvisibilitystatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.formvisibilitystatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formvisibilitystatusPayload>
          }
          update: {
            args: Prisma.formvisibilitystatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formvisibilitystatusPayload>
          }
          deleteMany: {
            args: Prisma.formvisibilitystatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.formvisibilitystatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.formvisibilitystatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$formvisibilitystatusPayload>
          }
          aggregate: {
            args: Prisma.FormvisibilitystatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFormvisibilitystatus>
          }
          groupBy: {
            args: Prisma.formvisibilitystatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<FormvisibilitystatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.formvisibilitystatusCountArgs<ExtArgs>
            result: $Utils.Optional<FormvisibilitystatusCountAggregateOutputType> | number
          }
        }
      }
      fundraiser: {
        payload: Prisma.$fundraiserPayload<ExtArgs>
        fields: Prisma.fundraiserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fundraiserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fundraiserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiserPayload>
          }
          findFirst: {
            args: Prisma.fundraiserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fundraiserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiserPayload>
          }
          findMany: {
            args: Prisma.fundraiserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiserPayload>[]
          }
          create: {
            args: Prisma.fundraiserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiserPayload>
          }
          createMany: {
            args: Prisma.fundraiserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.fundraiserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiserPayload>
          }
          update: {
            args: Prisma.fundraiserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiserPayload>
          }
          deleteMany: {
            args: Prisma.fundraiserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fundraiserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.fundraiserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiserPayload>
          }
          aggregate: {
            args: Prisma.FundraiserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFundraiser>
          }
          groupBy: {
            args: Prisma.fundraiserGroupByArgs<ExtArgs>
            result: $Utils.Optional<FundraiserGroupByOutputType>[]
          }
          count: {
            args: Prisma.fundraiserCountArgs<ExtArgs>
            result: $Utils.Optional<FundraiserCountAggregateOutputType> | number
          }
        }
      }
      fundraiser_acceptedcurrencies: {
        payload: Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>
        fields: Prisma.fundraiser_acceptedcurrenciesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fundraiser_acceptedcurrenciesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_acceptedcurrenciesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fundraiser_acceptedcurrenciesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_acceptedcurrenciesPayload>
          }
          findFirst: {
            args: Prisma.fundraiser_acceptedcurrenciesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_acceptedcurrenciesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fundraiser_acceptedcurrenciesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_acceptedcurrenciesPayload>
          }
          findMany: {
            args: Prisma.fundraiser_acceptedcurrenciesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_acceptedcurrenciesPayload>[]
          }
          create: {
            args: Prisma.fundraiser_acceptedcurrenciesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_acceptedcurrenciesPayload>
          }
          createMany: {
            args: Prisma.fundraiser_acceptedcurrenciesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.fundraiser_acceptedcurrenciesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_acceptedcurrenciesPayload>
          }
          update: {
            args: Prisma.fundraiser_acceptedcurrenciesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_acceptedcurrenciesPayload>
          }
          deleteMany: {
            args: Prisma.fundraiser_acceptedcurrenciesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fundraiser_acceptedcurrenciesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.fundraiser_acceptedcurrenciesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_acceptedcurrenciesPayload>
          }
          aggregate: {
            args: Prisma.Fundraiser_acceptedcurrenciesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFundraiser_acceptedcurrencies>
          }
          groupBy: {
            args: Prisma.fundraiser_acceptedcurrenciesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Fundraiser_acceptedcurrenciesGroupByOutputType>[]
          }
          count: {
            args: Prisma.fundraiser_acceptedcurrenciesCountArgs<ExtArgs>
            result: $Utils.Optional<Fundraiser_acceptedcurrenciesCountAggregateOutputType> | number
          }
        }
      }
      fundraiser_contactlinks: {
        payload: Prisma.$fundraiser_contactlinksPayload<ExtArgs>
        fields: Prisma.fundraiser_contactlinksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.fundraiser_contactlinksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_contactlinksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.fundraiser_contactlinksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_contactlinksPayload>
          }
          findFirst: {
            args: Prisma.fundraiser_contactlinksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_contactlinksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.fundraiser_contactlinksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_contactlinksPayload>
          }
          findMany: {
            args: Prisma.fundraiser_contactlinksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_contactlinksPayload>[]
          }
          create: {
            args: Prisma.fundraiser_contactlinksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_contactlinksPayload>
          }
          createMany: {
            args: Prisma.fundraiser_contactlinksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.fundraiser_contactlinksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_contactlinksPayload>
          }
          update: {
            args: Prisma.fundraiser_contactlinksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_contactlinksPayload>
          }
          deleteMany: {
            args: Prisma.fundraiser_contactlinksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.fundraiser_contactlinksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.fundraiser_contactlinksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$fundraiser_contactlinksPayload>
          }
          aggregate: {
            args: Prisma.Fundraiser_contactlinksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFundraiser_contactlinks>
          }
          groupBy: {
            args: Prisma.fundraiser_contactlinksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Fundraiser_contactlinksGroupByOutputType>[]
          }
          count: {
            args: Prisma.fundraiser_contactlinksCountArgs<ExtArgs>
            result: $Utils.Optional<Fundraiser_contactlinksCountAggregateOutputType> | number
          }
        }
      }
      manychat: {
        payload: Prisma.$manychatPayload<ExtArgs>
        fields: Prisma.manychatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.manychatFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manychatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.manychatFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manychatPayload>
          }
          findFirst: {
            args: Prisma.manychatFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manychatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.manychatFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manychatPayload>
          }
          findMany: {
            args: Prisma.manychatFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manychatPayload>[]
          }
          create: {
            args: Prisma.manychatCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manychatPayload>
          }
          createMany: {
            args: Prisma.manychatCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.manychatDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manychatPayload>
          }
          update: {
            args: Prisma.manychatUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manychatPayload>
          }
          deleteMany: {
            args: Prisma.manychatDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.manychatUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.manychatUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$manychatPayload>
          }
          aggregate: {
            args: Prisma.ManychatAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateManychat>
          }
          groupBy: {
            args: Prisma.manychatGroupByArgs<ExtArgs>
            result: $Utils.Optional<ManychatGroupByOutputType>[]
          }
          count: {
            args: Prisma.manychatCountArgs<ExtArgs>
            result: $Utils.Optional<ManychatCountAggregateOutputType> | number
          }
        }
      }
      minimumamount: {
        payload: Prisma.$minimumamountPayload<ExtArgs>
        fields: Prisma.minimumamountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.minimumamountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$minimumamountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.minimumamountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$minimumamountPayload>
          }
          findFirst: {
            args: Prisma.minimumamountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$minimumamountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.minimumamountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$minimumamountPayload>
          }
          findMany: {
            args: Prisma.minimumamountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$minimumamountPayload>[]
          }
          create: {
            args: Prisma.minimumamountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$minimumamountPayload>
          }
          createMany: {
            args: Prisma.minimumamountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.minimumamountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$minimumamountPayload>
          }
          update: {
            args: Prisma.minimumamountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$minimumamountPayload>
          }
          deleteMany: {
            args: Prisma.minimumamountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.minimumamountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.minimumamountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$minimumamountPayload>
          }
          aggregate: {
            args: Prisma.MinimumamountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMinimumamount>
          }
          groupBy: {
            args: Prisma.minimumamountGroupByArgs<ExtArgs>
            result: $Utils.Optional<MinimumamountGroupByOutputType>[]
          }
          count: {
            args: Prisma.minimumamountCountArgs<ExtArgs>
            result: $Utils.Optional<MinimumamountCountAggregateOutputType> | number
          }
        }
      }
      note: {
        payload: Prisma.$notePayload<ExtArgs>
        fields: Prisma.noteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.noteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.noteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notePayload>
          }
          findFirst: {
            args: Prisma.noteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.noteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notePayload>
          }
          findMany: {
            args: Prisma.noteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notePayload>[]
          }
          create: {
            args: Prisma.noteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notePayload>
          }
          createMany: {
            args: Prisma.noteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.noteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notePayload>
          }
          update: {
            args: Prisma.noteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notePayload>
          }
          deleteMany: {
            args: Prisma.noteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.noteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.noteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$notePayload>
          }
          aggregate: {
            args: Prisma.NoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNote>
          }
          groupBy: {
            args: Prisma.noteGroupByArgs<ExtArgs>
            result: $Utils.Optional<NoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.noteCountArgs<ExtArgs>
            result: $Utils.Optional<NoteCountAggregateOutputType> | number
          }
        }
      }
      platform: {
        payload: Prisma.$platformPayload<ExtArgs>
        fields: Prisma.platformFieldRefs
        operations: {
          findUnique: {
            args: Prisma.platformFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$platformPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.platformFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$platformPayload>
          }
          findFirst: {
            args: Prisma.platformFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$platformPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.platformFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$platformPayload>
          }
          findMany: {
            args: Prisma.platformFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$platformPayload>[]
          }
          create: {
            args: Prisma.platformCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$platformPayload>
          }
          createMany: {
            args: Prisma.platformCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.platformDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$platformPayload>
          }
          update: {
            args: Prisma.platformUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$platformPayload>
          }
          deleteMany: {
            args: Prisma.platformDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.platformUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.platformUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$platformPayload>
          }
          aggregate: {
            args: Prisma.PlatformAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatform>
          }
          groupBy: {
            args: Prisma.platformGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformGroupByOutputType>[]
          }
          count: {
            args: Prisma.platformCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformCountAggregateOutputType> | number
          }
        }
      }
      screenshot: {
        payload: Prisma.$screenshotPayload<ExtArgs>
        fields: Prisma.screenshotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.screenshotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$screenshotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.screenshotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$screenshotPayload>
          }
          findFirst: {
            args: Prisma.screenshotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$screenshotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.screenshotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$screenshotPayload>
          }
          findMany: {
            args: Prisma.screenshotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$screenshotPayload>[]
          }
          create: {
            args: Prisma.screenshotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$screenshotPayload>
          }
          createMany: {
            args: Prisma.screenshotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.screenshotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$screenshotPayload>
          }
          update: {
            args: Prisma.screenshotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$screenshotPayload>
          }
          deleteMany: {
            args: Prisma.screenshotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.screenshotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.screenshotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$screenshotPayload>
          }
          aggregate: {
            args: Prisma.ScreenshotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScreenshot>
          }
          groupBy: {
            args: Prisma.screenshotGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScreenshotGroupByOutputType>[]
          }
          count: {
            args: Prisma.screenshotCountArgs<ExtArgs>
            result: $Utils.Optional<ScreenshotCountAggregateOutputType> | number
          }
        }
      }
      supportregion: {
        payload: Prisma.$supportregionPayload<ExtArgs>
        fields: Prisma.supportregionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.supportregionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportregionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.supportregionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportregionPayload>
          }
          findFirst: {
            args: Prisma.supportregionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportregionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.supportregionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportregionPayload>
          }
          findMany: {
            args: Prisma.supportregionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportregionPayload>[]
          }
          create: {
            args: Prisma.supportregionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportregionPayload>
          }
          createMany: {
            args: Prisma.supportregionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.supportregionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportregionPayload>
          }
          update: {
            args: Prisma.supportregionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportregionPayload>
          }
          deleteMany: {
            args: Prisma.supportregionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.supportregionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.supportregionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$supportregionPayload>
          }
          aggregate: {
            args: Prisma.SupportregionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportregion>
          }
          groupBy: {
            args: Prisma.supportregionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportregionGroupByOutputType>[]
          }
          count: {
            args: Prisma.supportregionCountArgs<ExtArgs>
            result: $Utils.Optional<SupportregionCountAggregateOutputType> | number
          }
        }
      }
      transactionagent: {
        payload: Prisma.$transactionagentPayload<ExtArgs>
        fields: Prisma.transactionagentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionagentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionagentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionagentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionagentPayload>
          }
          findFirst: {
            args: Prisma.transactionagentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionagentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionagentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionagentPayload>
          }
          findMany: {
            args: Prisma.transactionagentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionagentPayload>[]
          }
          create: {
            args: Prisma.transactionagentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionagentPayload>
          }
          createMany: {
            args: Prisma.transactionagentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transactionagentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionagentPayload>
          }
          update: {
            args: Prisma.transactionagentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionagentPayload>
          }
          deleteMany: {
            args: Prisma.transactionagentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionagentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transactionagentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionagentPayload>
          }
          aggregate: {
            args: Prisma.TransactionagentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionagent>
          }
          groupBy: {
            args: Prisma.transactionagentGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionagentGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionagentCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionagentCountAggregateOutputType> | number
          }
        }
      }
      transactions: {
        payload: Prisma.$transactionsPayload<ExtArgs>
        fields: Prisma.transactionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findFirst: {
            args: Prisma.transactionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          findMany: {
            args: Prisma.transactionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>[]
          }
          create: {
            args: Prisma.transactionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          createMany: {
            args: Prisma.transactionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transactionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          update: {
            args: Prisma.transactionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          deleteMany: {
            args: Prisma.transactionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transactionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionsPayload>
          }
          aggregate: {
            args: Prisma.TransactionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactions>
          }
          groupBy: {
            args: Prisma.transactionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionsCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionsCountAggregateOutputType> | number
          }
        }
      }
      transactionstatus: {
        payload: Prisma.$transactionstatusPayload<ExtArgs>
        fields: Prisma.transactionstatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.transactionstatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionstatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.transactionstatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionstatusPayload>
          }
          findFirst: {
            args: Prisma.transactionstatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionstatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.transactionstatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionstatusPayload>
          }
          findMany: {
            args: Prisma.transactionstatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionstatusPayload>[]
          }
          create: {
            args: Prisma.transactionstatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionstatusPayload>
          }
          createMany: {
            args: Prisma.transactionstatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.transactionstatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionstatusPayload>
          }
          update: {
            args: Prisma.transactionstatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionstatusPayload>
          }
          deleteMany: {
            args: Prisma.transactionstatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.transactionstatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.transactionstatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$transactionstatusPayload>
          }
          aggregate: {
            args: Prisma.TransactionstatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionstatus>
          }
          groupBy: {
            args: Prisma.transactionstatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionstatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.transactionstatusCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionstatusCountAggregateOutputType> | number
          }
        }
      }
      userrole: {
        payload: Prisma.$userrolePayload<ExtArgs>
        fields: Prisma.userroleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.userroleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.userroleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findFirst: {
            args: Prisma.userroleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.userroleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          findMany: {
            args: Prisma.userroleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>[]
          }
          create: {
            args: Prisma.userroleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          createMany: {
            args: Prisma.userroleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.userroleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          update: {
            args: Prisma.userroleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          deleteMany: {
            args: Prisma.userroleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.userroleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.userroleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$userrolePayload>
          }
          aggregate: {
            args: Prisma.UserroleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserrole>
          }
          groupBy: {
            args: Prisma.userroleGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserroleGroupByOutputType>[]
          }
          count: {
            args: Prisma.userroleCountArgs<ExtArgs>
            result: $Utils.Optional<UserroleCountAggregateOutputType> | number
          }
        }
      }
      wallet: {
        payload: Prisma.$walletPayload<ExtArgs>
        fields: Prisma.walletFieldRefs
        operations: {
          findUnique: {
            args: Prisma.walletFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.walletFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          findFirst: {
            args: Prisma.walletFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.walletFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          findMany: {
            args: Prisma.walletFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>[]
          }
          create: {
            args: Prisma.walletCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          createMany: {
            args: Prisma.walletCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.walletDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          update: {
            args: Prisma.walletUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          deleteMany: {
            args: Prisma.walletDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.walletUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.walletUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$walletPayload>
          }
          aggregate: {
            args: Prisma.WalletAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWallet>
          }
          groupBy: {
            args: Prisma.walletGroupByArgs<ExtArgs>
            result: $Utils.Optional<WalletGroupByOutputType>[]
          }
          count: {
            args: Prisma.walletCountArgs<ExtArgs>
            result: $Utils.Optional<WalletCountAggregateOutputType> | number
          }
        }
      }
      testing_new_table: {
        payload: Prisma.$testing_new_tablePayload<ExtArgs>
        fields: Prisma.testing_new_tableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.testing_new_tableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_tablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testing_new_tableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_tablePayload>
          }
          findFirst: {
            args: Prisma.testing_new_tableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_tablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testing_new_tableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_tablePayload>
          }
          findMany: {
            args: Prisma.testing_new_tableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_tablePayload>[]
          }
          create: {
            args: Prisma.testing_new_tableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_tablePayload>
          }
          createMany: {
            args: Prisma.testing_new_tableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.testing_new_tableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_tablePayload>
          }
          update: {
            args: Prisma.testing_new_tableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_tablePayload>
          }
          deleteMany: {
            args: Prisma.testing_new_tableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.testing_new_tableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.testing_new_tableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_tablePayload>
          }
          aggregate: {
            args: Prisma.Testing_new_tableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTesting_new_table>
          }
          groupBy: {
            args: Prisma.testing_new_tableGroupByArgs<ExtArgs>
            result: $Utils.Optional<Testing_new_tableGroupByOutputType>[]
          }
          count: {
            args: Prisma.testing_new_tableCountArgs<ExtArgs>
            result: $Utils.Optional<Testing_new_tableCountAggregateOutputType> | number
          }
        }
      }
      testing_new_table2: {
        payload: Prisma.$testing_new_table2Payload<ExtArgs>
        fields: Prisma.testing_new_table2FieldRefs
        operations: {
          findUnique: {
            args: Prisma.testing_new_table2FindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_table2Payload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.testing_new_table2FindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_table2Payload>
          }
          findFirst: {
            args: Prisma.testing_new_table2FindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_table2Payload> | null
          }
          findFirstOrThrow: {
            args: Prisma.testing_new_table2FindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_table2Payload>
          }
          findMany: {
            args: Prisma.testing_new_table2FindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_table2Payload>[]
          }
          create: {
            args: Prisma.testing_new_table2CreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_table2Payload>
          }
          createMany: {
            args: Prisma.testing_new_table2CreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.testing_new_table2DeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_table2Payload>
          }
          update: {
            args: Prisma.testing_new_table2UpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_table2Payload>
          }
          deleteMany: {
            args: Prisma.testing_new_table2DeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.testing_new_table2UpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.testing_new_table2UpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$testing_new_table2Payload>
          }
          aggregate: {
            args: Prisma.Testing_new_table2AggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTesting_new_table2>
          }
          groupBy: {
            args: Prisma.testing_new_table2GroupByArgs<ExtArgs>
            result: $Utils.Optional<Testing_new_table2GroupByOutputType>[]
          }
          count: {
            args: Prisma.testing_new_table2CountArgs<ExtArgs>
            result: $Utils.Optional<Testing_new_table2CountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    agent?: agentOmit
    basecountry?: basecountryOmit
    currency?: currencyOmit
    customer?: customerOmit
    customerauditlogs?: customerauditlogsOmit
    exchangerates?: exchangeratesOmit
    formstatus?: formstatusOmit
    formvisibilitystatus?: formvisibilitystatusOmit
    fundraiser?: fundraiserOmit
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesOmit
    fundraiser_contactlinks?: fundraiser_contactlinksOmit
    manychat?: manychatOmit
    minimumamount?: minimumamountOmit
    note?: noteOmit
    platform?: platformOmit
    screenshot?: screenshotOmit
    supportregion?: supportregionOmit
    transactionagent?: transactionagentOmit
    transactions?: transactionsOmit
    transactionstatus?: transactionstatusOmit
    userrole?: userroleOmit
    wallet?: walletOmit
    testing_new_table?: testing_new_tableOmit
    testing_new_table2?: testing_new_table2Omit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    customer: number
    customerauditlogs: number
    formvisibilitystatus: number
    note: number
    transactionagent: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | AgentCountOutputTypeCountCustomerArgs
    customerauditlogs?: boolean | AgentCountOutputTypeCountCustomerauditlogsArgs
    formvisibilitystatus?: boolean | AgentCountOutputTypeCountFormvisibilitystatusArgs
    note?: boolean | AgentCountOutputTypeCountNoteArgs
    transactionagent?: boolean | AgentCountOutputTypeCountTransactionagentArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountCustomerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountCustomerauditlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerauditlogsWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountFormvisibilitystatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formvisibilitystatusWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountNoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noteWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountTransactionagentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionagentWhereInput
  }


  /**
   * Count Type BasecountryCountOutputType
   */

  export type BasecountryCountOutputType = {
    exchangerates: number
    fundraiser: number
  }

  export type BasecountryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exchangerates?: boolean | BasecountryCountOutputTypeCountExchangeratesArgs
    fundraiser?: boolean | BasecountryCountOutputTypeCountFundraiserArgs
  }

  // Custom InputTypes
  /**
   * BasecountryCountOutputType without action
   */
  export type BasecountryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BasecountryCountOutputType
     */
    select?: BasecountryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BasecountryCountOutputType without action
   */
  export type BasecountryCountOutputTypeCountExchangeratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exchangeratesWhereInput
  }

  /**
   * BasecountryCountOutputType without action
   */
  export type BasecountryCountOutputTypeCountFundraiserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fundraiserWhereInput
  }


  /**
   * Count Type CurrencyCountOutputType
   */

  export type CurrencyCountOutputType = {
    exchangerates: number
    fundraiser_acceptedcurrencies: number
    minimumamount: number
    wallet: number
  }

  export type CurrencyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exchangerates?: boolean | CurrencyCountOutputTypeCountExchangeratesArgs
    fundraiser_acceptedcurrencies?: boolean | CurrencyCountOutputTypeCountFundraiser_acceptedcurrenciesArgs
    minimumamount?: boolean | CurrencyCountOutputTypeCountMinimumamountArgs
    wallet?: boolean | CurrencyCountOutputTypeCountWalletArgs
  }

  // Custom InputTypes
  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CurrencyCountOutputType
     */
    select?: CurrencyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountExchangeratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exchangeratesWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountFundraiser_acceptedcurrenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fundraiser_acceptedcurrenciesWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountMinimumamountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: minimumamountWhereInput
  }

  /**
   * CurrencyCountOutputType without action
   */
  export type CurrencyCountOutputTypeCountWalletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: walletWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    customerauditlogs: number
    manychat: number
    transactions: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customerauditlogs?: boolean | CustomerCountOutputTypeCountCustomerauditlogsArgs
    manychat?: boolean | CustomerCountOutputTypeCountManychatArgs
    transactions?: boolean | CustomerCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountCustomerauditlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerauditlogsWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountManychatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: manychatWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
  }


  /**
   * Count Type FundraiserCountOutputType
   */

  export type FundraiserCountOutputType = {
    fundraiser_acceptedcurrencies: number
    fundraiser_contactlinks: number
  }

  export type FundraiserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fundraiser_acceptedcurrencies?: boolean | FundraiserCountOutputTypeCountFundraiser_acceptedcurrenciesArgs
    fundraiser_contactlinks?: boolean | FundraiserCountOutputTypeCountFundraiser_contactlinksArgs
  }

  // Custom InputTypes
  /**
   * FundraiserCountOutputType without action
   */
  export type FundraiserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FundraiserCountOutputType
     */
    select?: FundraiserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FundraiserCountOutputType without action
   */
  export type FundraiserCountOutputTypeCountFundraiser_acceptedcurrenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fundraiser_acceptedcurrenciesWhereInput
  }

  /**
   * FundraiserCountOutputType without action
   */
  export type FundraiserCountOutputTypeCountFundraiser_contactlinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fundraiser_contactlinksWhereInput
  }


  /**
   * Count Type NoteCountOutputType
   */

  export type NoteCountOutputType = {
    transactions: number
  }

  export type NoteCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | NoteCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * NoteCountOutputType without action
   */
  export type NoteCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NoteCountOutputType
     */
    select?: NoteCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NoteCountOutputType without action
   */
  export type NoteCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
  }


  /**
   * Count Type SupportregionCountOutputType
   */

  export type SupportregionCountOutputType = {
    transactions: number
  }

  export type SupportregionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | SupportregionCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * SupportregionCountOutputType without action
   */
  export type SupportregionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportregionCountOutputType
     */
    select?: SupportregionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupportregionCountOutputType without action
   */
  export type SupportregionCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
  }


  /**
   * Count Type TransactionsCountOutputType
   */

  export type TransactionsCountOutputType = {
    formstatus: number
    screenshot: number
    transactionagent: number
  }

  export type TransactionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formstatus?: boolean | TransactionsCountOutputTypeCountFormstatusArgs
    screenshot?: boolean | TransactionsCountOutputTypeCountScreenshotArgs
    transactionagent?: boolean | TransactionsCountOutputTypeCountTransactionagentArgs
  }

  // Custom InputTypes
  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionsCountOutputType
     */
    select?: TransactionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeCountFormstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formstatusWhereInput
  }

  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeCountScreenshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: screenshotWhereInput
  }

  /**
   * TransactionsCountOutputType without action
   */
  export type TransactionsCountOutputTypeCountTransactionagentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionagentWhereInput
  }


  /**
   * Count Type TransactionstatusCountOutputType
   */

  export type TransactionstatusCountOutputType = {
    formstatus: number
  }

  export type TransactionstatusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formstatus?: boolean | TransactionstatusCountOutputTypeCountFormstatusArgs
  }

  // Custom InputTypes
  /**
   * TransactionstatusCountOutputType without action
   */
  export type TransactionstatusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionstatusCountOutputType
     */
    select?: TransactionstatusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionstatusCountOutputType without action
   */
  export type TransactionstatusCountOutputTypeCountFormstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formstatusWhereInput
  }


  /**
   * Count Type UserroleCountOutputType
   */

  export type UserroleCountOutputType = {
    agent: number
  }

  export type UserroleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | UserroleCountOutputTypeCountAgentArgs
  }

  // Custom InputTypes
  /**
   * UserroleCountOutputType without action
   */
  export type UserroleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserroleCountOutputType
     */
    select?: UserroleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserroleCountOutputType without action
   */
  export type UserroleCountOutputTypeCountAgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agentWhereInput
  }


  /**
   * Count Type WalletCountOutputType
   */

  export type WalletCountOutputType = {
    transactions: number
  }

  export type WalletCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | WalletCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WalletCountOutputType
     */
    select?: WalletCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WalletCountOutputType without action
   */
  export type WalletCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    AgentId: number | null
    UserRoleId: number | null
  }

  export type AgentSumAggregateOutputType = {
    AgentId: number | null
    UserRoleId: number | null
  }

  export type AgentMinAggregateOutputType = {
    AgentId: number | null
    AwsId: string | null
    UserRoleId: number | null
  }

  export type AgentMaxAggregateOutputType = {
    AgentId: number | null
    AwsId: string | null
    UserRoleId: number | null
  }

  export type AgentCountAggregateOutputType = {
    AgentId: number
    AwsId: number
    UserRoleId: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    AgentId?: true
    UserRoleId?: true
  }

  export type AgentSumAggregateInputType = {
    AgentId?: true
    UserRoleId?: true
  }

  export type AgentMinAggregateInputType = {
    AgentId?: true
    AwsId?: true
    UserRoleId?: true
  }

  export type AgentMaxAggregateInputType = {
    AgentId?: true
    AwsId?: true
    UserRoleId?: true
  }

  export type AgentCountAggregateInputType = {
    AgentId?: true
    AwsId?: true
    UserRoleId?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agent to aggregate.
     */
    where?: agentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agents to fetch.
     */
    orderBy?: agentOrderByWithRelationInput | agentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: agentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type agentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: agentWhereInput
    orderBy?: agentOrderByWithAggregationInput | agentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: agentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    AgentId: number
    AwsId: string | null
    UserRoleId: number | null
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends agentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type agentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    AgentId?: boolean
    AwsId?: boolean
    UserRoleId?: boolean
    userrole?: boolean | agent$userroleArgs<ExtArgs>
    customer?: boolean | agent$customerArgs<ExtArgs>
    customerauditlogs?: boolean | agent$customerauditlogsArgs<ExtArgs>
    formvisibilitystatus?: boolean | agent$formvisibilitystatusArgs<ExtArgs>
    note?: boolean | agent$noteArgs<ExtArgs>
    transactionagent?: boolean | agent$transactionagentArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>



  export type agentSelectScalar = {
    AgentId?: boolean
    AwsId?: boolean
    UserRoleId?: boolean
  }

  export type agentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"AgentId" | "AwsId" | "UserRoleId", ExtArgs["result"]["agent"]>
  export type agentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userrole?: boolean | agent$userroleArgs<ExtArgs>
    customer?: boolean | agent$customerArgs<ExtArgs>
    customerauditlogs?: boolean | agent$customerauditlogsArgs<ExtArgs>
    formvisibilitystatus?: boolean | agent$formvisibilitystatusArgs<ExtArgs>
    note?: boolean | agent$noteArgs<ExtArgs>
    transactionagent?: boolean | agent$transactionagentArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $agentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "agent"
    objects: {
      userrole: Prisma.$userrolePayload<ExtArgs> | null
      customer: Prisma.$customerPayload<ExtArgs>[]
      customerauditlogs: Prisma.$customerauditlogsPayload<ExtArgs>[]
      formvisibilitystatus: Prisma.$formvisibilitystatusPayload<ExtArgs>[]
      note: Prisma.$notePayload<ExtArgs>[]
      transactionagent: Prisma.$transactionagentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      AgentId: number
      AwsId: string | null
      UserRoleId: number | null
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type agentGetPayload<S extends boolean | null | undefined | agentDefaultArgs> = $Result.GetResult<Prisma.$agentPayload, S>

  type agentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<agentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface agentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['agent'], meta: { name: 'agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {agentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends agentFindUniqueArgs>(args: SelectSubset<T, agentFindUniqueArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {agentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends agentFindUniqueOrThrowArgs>(args: SelectSubset<T, agentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends agentFindFirstArgs>(args?: SelectSubset<T, agentFindFirstArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends agentFindFirstOrThrowArgs>(args?: SelectSubset<T, agentFindFirstOrThrowArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `AgentId`
     * const agentWithAgentIdOnly = await prisma.agent.findMany({ select: { AgentId: true } })
     * 
     */
    findMany<T extends agentFindManyArgs>(args?: SelectSubset<T, agentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Agent.
     * @param {agentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends agentCreateArgs>(args: SelectSubset<T, agentCreateArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Agents.
     * @param {agentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends agentCreateManyArgs>(args?: SelectSubset<T, agentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Agent.
     * @param {agentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends agentDeleteArgs>(args: SelectSubset<T, agentDeleteArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Agent.
     * @param {agentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends agentUpdateArgs>(args: SelectSubset<T, agentUpdateArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Agents.
     * @param {agentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends agentDeleteManyArgs>(args?: SelectSubset<T, agentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends agentUpdateManyArgs>(args: SelectSubset<T, agentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agent.
     * @param {agentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends agentUpsertArgs>(args: SelectSubset<T, agentUpsertArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends agentCountArgs>(
      args?: Subset<T, agentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {agentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends agentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: agentGroupByArgs['orderBy'] }
        : { orderBy?: agentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, agentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the agent model
   */
  readonly fields: agentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__agentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userrole<T extends agent$userroleArgs<ExtArgs> = {}>(args?: Subset<T, agent$userroleArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends agent$customerArgs<ExtArgs> = {}>(args?: Subset<T, agent$customerArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customerauditlogs<T extends agent$customerauditlogsArgs<ExtArgs> = {}>(args?: Subset<T, agent$customerauditlogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerauditlogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    formvisibilitystatus<T extends agent$formvisibilitystatusArgs<ExtArgs> = {}>(args?: Subset<T, agent$formvisibilitystatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formvisibilitystatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    note<T extends agent$noteArgs<ExtArgs> = {}>(args?: Subset<T, agent$noteArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionagent<T extends agent$transactionagentArgs<ExtArgs> = {}>(args?: Subset<T, agent$transactionagentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionagentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the agent model
   */
  interface agentFieldRefs {
    readonly AgentId: FieldRef<"agent", 'Int'>
    readonly AwsId: FieldRef<"agent", 'String'>
    readonly UserRoleId: FieldRef<"agent", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * agent findUnique
   */
  export type agentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    /**
     * Filter, which agent to fetch.
     */
    where: agentWhereUniqueInput
  }

  /**
   * agent findUniqueOrThrow
   */
  export type agentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    /**
     * Filter, which agent to fetch.
     */
    where: agentWhereUniqueInput
  }

  /**
   * agent findFirst
   */
  export type agentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    /**
     * Filter, which agent to fetch.
     */
    where?: agentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agents to fetch.
     */
    orderBy?: agentOrderByWithRelationInput | agentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agents.
     */
    cursor?: agentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * agent findFirstOrThrow
   */
  export type agentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    /**
     * Filter, which agent to fetch.
     */
    where?: agentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agents to fetch.
     */
    orderBy?: agentOrderByWithRelationInput | agentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for agents.
     */
    cursor?: agentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * agent findMany
   */
  export type agentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    /**
     * Filter, which agents to fetch.
     */
    where?: agentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of agents to fetch.
     */
    orderBy?: agentOrderByWithRelationInput | agentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing agents.
     */
    cursor?: agentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * agent create
   */
  export type agentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    /**
     * The data needed to create a agent.
     */
    data?: XOR<agentCreateInput, agentUncheckedCreateInput>
  }

  /**
   * agent createMany
   */
  export type agentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many agents.
     */
    data: agentCreateManyInput | agentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * agent update
   */
  export type agentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    /**
     * The data needed to update a agent.
     */
    data: XOR<agentUpdateInput, agentUncheckedUpdateInput>
    /**
     * Choose, which agent to update.
     */
    where: agentWhereUniqueInput
  }

  /**
   * agent updateMany
   */
  export type agentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update agents.
     */
    data: XOR<agentUpdateManyMutationInput, agentUncheckedUpdateManyInput>
    /**
     * Filter which agents to update
     */
    where?: agentWhereInput
    /**
     * Limit how many agents to update.
     */
    limit?: number
  }

  /**
   * agent upsert
   */
  export type agentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    /**
     * The filter to search for the agent to update in case it exists.
     */
    where: agentWhereUniqueInput
    /**
     * In case the agent found by the `where` argument doesn't exist, create a new agent with this data.
     */
    create: XOR<agentCreateInput, agentUncheckedCreateInput>
    /**
     * In case the agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<agentUpdateInput, agentUncheckedUpdateInput>
  }

  /**
   * agent delete
   */
  export type agentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    /**
     * Filter which agent to delete.
     */
    where: agentWhereUniqueInput
  }

  /**
   * agent deleteMany
   */
  export type agentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which agents to delete
     */
    where?: agentWhereInput
    /**
     * Limit how many agents to delete.
     */
    limit?: number
  }

  /**
   * agent.userrole
   */
  export type agent$userroleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    where?: userroleWhereInput
  }

  /**
   * agent.customer
   */
  export type agent$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    cursor?: customerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * agent.customerauditlogs
   */
  export type agent$customerauditlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
    where?: customerauditlogsWhereInput
    orderBy?: customerauditlogsOrderByWithRelationInput | customerauditlogsOrderByWithRelationInput[]
    cursor?: customerauditlogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerauditlogsScalarFieldEnum | CustomerauditlogsScalarFieldEnum[]
  }

  /**
   * agent.formvisibilitystatus
   */
  export type agent$formvisibilitystatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formvisibilitystatus
     */
    select?: formvisibilitystatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formvisibilitystatus
     */
    omit?: formvisibilitystatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formvisibilitystatusInclude<ExtArgs> | null
    where?: formvisibilitystatusWhereInput
    orderBy?: formvisibilitystatusOrderByWithRelationInput | formvisibilitystatusOrderByWithRelationInput[]
    cursor?: formvisibilitystatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormvisibilitystatusScalarFieldEnum | FormvisibilitystatusScalarFieldEnum[]
  }

  /**
   * agent.note
   */
  export type agent$noteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
    where?: noteWhereInput
    orderBy?: noteOrderByWithRelationInput | noteOrderByWithRelationInput[]
    cursor?: noteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * agent.transactionagent
   */
  export type agent$transactionagentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
    where?: transactionagentWhereInput
    orderBy?: transactionagentOrderByWithRelationInput | transactionagentOrderByWithRelationInput[]
    cursor?: transactionagentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionagentScalarFieldEnum | TransactionagentScalarFieldEnum[]
  }

  /**
   * agent without action
   */
  export type agentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
  }


  /**
   * Model basecountry
   */

  export type AggregateBasecountry = {
    _count: BasecountryCountAggregateOutputType | null
    _avg: BasecountryAvgAggregateOutputType | null
    _sum: BasecountrySumAggregateOutputType | null
    _min: BasecountryMinAggregateOutputType | null
    _max: BasecountryMaxAggregateOutputType | null
  }

  export type BasecountryAvgAggregateOutputType = {
    BaseCountryID: number | null
  }

  export type BasecountrySumAggregateOutputType = {
    BaseCountryID: number | null
  }

  export type BasecountryMinAggregateOutputType = {
    BaseCountryID: number | null
    BaseCountryName: string | null
  }

  export type BasecountryMaxAggregateOutputType = {
    BaseCountryID: number | null
    BaseCountryName: string | null
  }

  export type BasecountryCountAggregateOutputType = {
    BaseCountryID: number
    BaseCountryName: number
    _all: number
  }


  export type BasecountryAvgAggregateInputType = {
    BaseCountryID?: true
  }

  export type BasecountrySumAggregateInputType = {
    BaseCountryID?: true
  }

  export type BasecountryMinAggregateInputType = {
    BaseCountryID?: true
    BaseCountryName?: true
  }

  export type BasecountryMaxAggregateInputType = {
    BaseCountryID?: true
    BaseCountryName?: true
  }

  export type BasecountryCountAggregateInputType = {
    BaseCountryID?: true
    BaseCountryName?: true
    _all?: true
  }

  export type BasecountryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which basecountry to aggregate.
     */
    where?: basecountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basecountries to fetch.
     */
    orderBy?: basecountryOrderByWithRelationInput | basecountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: basecountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basecountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basecountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned basecountries
    **/
    _count?: true | BasecountryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BasecountryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BasecountrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BasecountryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BasecountryMaxAggregateInputType
  }

  export type GetBasecountryAggregateType<T extends BasecountryAggregateArgs> = {
        [P in keyof T & keyof AggregateBasecountry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBasecountry[P]>
      : GetScalarType<T[P], AggregateBasecountry[P]>
  }




  export type basecountryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: basecountryWhereInput
    orderBy?: basecountryOrderByWithAggregationInput | basecountryOrderByWithAggregationInput[]
    by: BasecountryScalarFieldEnum[] | BasecountryScalarFieldEnum
    having?: basecountryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BasecountryCountAggregateInputType | true
    _avg?: BasecountryAvgAggregateInputType
    _sum?: BasecountrySumAggregateInputType
    _min?: BasecountryMinAggregateInputType
    _max?: BasecountryMaxAggregateInputType
  }

  export type BasecountryGroupByOutputType = {
    BaseCountryID: number
    BaseCountryName: string
    _count: BasecountryCountAggregateOutputType | null
    _avg: BasecountryAvgAggregateOutputType | null
    _sum: BasecountrySumAggregateOutputType | null
    _min: BasecountryMinAggregateOutputType | null
    _max: BasecountryMaxAggregateOutputType | null
  }

  type GetBasecountryGroupByPayload<T extends basecountryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BasecountryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BasecountryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BasecountryGroupByOutputType[P]>
            : GetScalarType<T[P], BasecountryGroupByOutputType[P]>
        }
      >
    >


  export type basecountrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    BaseCountryID?: boolean
    BaseCountryName?: boolean
    exchangerates?: boolean | basecountry$exchangeratesArgs<ExtArgs>
    fundraiser?: boolean | basecountry$fundraiserArgs<ExtArgs>
    _count?: boolean | BasecountryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["basecountry"]>



  export type basecountrySelectScalar = {
    BaseCountryID?: boolean
    BaseCountryName?: boolean
  }

  export type basecountryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"BaseCountryID" | "BaseCountryName", ExtArgs["result"]["basecountry"]>
  export type basecountryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exchangerates?: boolean | basecountry$exchangeratesArgs<ExtArgs>
    fundraiser?: boolean | basecountry$fundraiserArgs<ExtArgs>
    _count?: boolean | BasecountryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $basecountryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "basecountry"
    objects: {
      exchangerates: Prisma.$exchangeratesPayload<ExtArgs>[]
      fundraiser: Prisma.$fundraiserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      BaseCountryID: number
      BaseCountryName: string
    }, ExtArgs["result"]["basecountry"]>
    composites: {}
  }

  type basecountryGetPayload<S extends boolean | null | undefined | basecountryDefaultArgs> = $Result.GetResult<Prisma.$basecountryPayload, S>

  type basecountryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<basecountryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BasecountryCountAggregateInputType | true
    }

  export interface basecountryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['basecountry'], meta: { name: 'basecountry' } }
    /**
     * Find zero or one Basecountry that matches the filter.
     * @param {basecountryFindUniqueArgs} args - Arguments to find a Basecountry
     * @example
     * // Get one Basecountry
     * const basecountry = await prisma.basecountry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends basecountryFindUniqueArgs>(args: SelectSubset<T, basecountryFindUniqueArgs<ExtArgs>>): Prisma__basecountryClient<$Result.GetResult<Prisma.$basecountryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Basecountry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {basecountryFindUniqueOrThrowArgs} args - Arguments to find a Basecountry
     * @example
     * // Get one Basecountry
     * const basecountry = await prisma.basecountry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends basecountryFindUniqueOrThrowArgs>(args: SelectSubset<T, basecountryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__basecountryClient<$Result.GetResult<Prisma.$basecountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Basecountry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basecountryFindFirstArgs} args - Arguments to find a Basecountry
     * @example
     * // Get one Basecountry
     * const basecountry = await prisma.basecountry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends basecountryFindFirstArgs>(args?: SelectSubset<T, basecountryFindFirstArgs<ExtArgs>>): Prisma__basecountryClient<$Result.GetResult<Prisma.$basecountryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Basecountry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basecountryFindFirstOrThrowArgs} args - Arguments to find a Basecountry
     * @example
     * // Get one Basecountry
     * const basecountry = await prisma.basecountry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends basecountryFindFirstOrThrowArgs>(args?: SelectSubset<T, basecountryFindFirstOrThrowArgs<ExtArgs>>): Prisma__basecountryClient<$Result.GetResult<Prisma.$basecountryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Basecountries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basecountryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Basecountries
     * const basecountries = await prisma.basecountry.findMany()
     * 
     * // Get first 10 Basecountries
     * const basecountries = await prisma.basecountry.findMany({ take: 10 })
     * 
     * // Only select the `BaseCountryID`
     * const basecountryWithBaseCountryIDOnly = await prisma.basecountry.findMany({ select: { BaseCountryID: true } })
     * 
     */
    findMany<T extends basecountryFindManyArgs>(args?: SelectSubset<T, basecountryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$basecountryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Basecountry.
     * @param {basecountryCreateArgs} args - Arguments to create a Basecountry.
     * @example
     * // Create one Basecountry
     * const Basecountry = await prisma.basecountry.create({
     *   data: {
     *     // ... data to create a Basecountry
     *   }
     * })
     * 
     */
    create<T extends basecountryCreateArgs>(args: SelectSubset<T, basecountryCreateArgs<ExtArgs>>): Prisma__basecountryClient<$Result.GetResult<Prisma.$basecountryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Basecountries.
     * @param {basecountryCreateManyArgs} args - Arguments to create many Basecountries.
     * @example
     * // Create many Basecountries
     * const basecountry = await prisma.basecountry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends basecountryCreateManyArgs>(args?: SelectSubset<T, basecountryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Basecountry.
     * @param {basecountryDeleteArgs} args - Arguments to delete one Basecountry.
     * @example
     * // Delete one Basecountry
     * const Basecountry = await prisma.basecountry.delete({
     *   where: {
     *     // ... filter to delete one Basecountry
     *   }
     * })
     * 
     */
    delete<T extends basecountryDeleteArgs>(args: SelectSubset<T, basecountryDeleteArgs<ExtArgs>>): Prisma__basecountryClient<$Result.GetResult<Prisma.$basecountryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Basecountry.
     * @param {basecountryUpdateArgs} args - Arguments to update one Basecountry.
     * @example
     * // Update one Basecountry
     * const basecountry = await prisma.basecountry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends basecountryUpdateArgs>(args: SelectSubset<T, basecountryUpdateArgs<ExtArgs>>): Prisma__basecountryClient<$Result.GetResult<Prisma.$basecountryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Basecountries.
     * @param {basecountryDeleteManyArgs} args - Arguments to filter Basecountries to delete.
     * @example
     * // Delete a few Basecountries
     * const { count } = await prisma.basecountry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends basecountryDeleteManyArgs>(args?: SelectSubset<T, basecountryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Basecountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basecountryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Basecountries
     * const basecountry = await prisma.basecountry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends basecountryUpdateManyArgs>(args: SelectSubset<T, basecountryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Basecountry.
     * @param {basecountryUpsertArgs} args - Arguments to update or create a Basecountry.
     * @example
     * // Update or create a Basecountry
     * const basecountry = await prisma.basecountry.upsert({
     *   create: {
     *     // ... data to create a Basecountry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Basecountry we want to update
     *   }
     * })
     */
    upsert<T extends basecountryUpsertArgs>(args: SelectSubset<T, basecountryUpsertArgs<ExtArgs>>): Prisma__basecountryClient<$Result.GetResult<Prisma.$basecountryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Basecountries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basecountryCountArgs} args - Arguments to filter Basecountries to count.
     * @example
     * // Count the number of Basecountries
     * const count = await prisma.basecountry.count({
     *   where: {
     *     // ... the filter for the Basecountries we want to count
     *   }
     * })
    **/
    count<T extends basecountryCountArgs>(
      args?: Subset<T, basecountryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BasecountryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Basecountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BasecountryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BasecountryAggregateArgs>(args: Subset<T, BasecountryAggregateArgs>): Prisma.PrismaPromise<GetBasecountryAggregateType<T>>

    /**
     * Group by Basecountry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {basecountryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends basecountryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: basecountryGroupByArgs['orderBy'] }
        : { orderBy?: basecountryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, basecountryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBasecountryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the basecountry model
   */
  readonly fields: basecountryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for basecountry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__basecountryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exchangerates<T extends basecountry$exchangeratesArgs<ExtArgs> = {}>(args?: Subset<T, basecountry$exchangeratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exchangeratesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fundraiser<T extends basecountry$fundraiserArgs<ExtArgs> = {}>(args?: Subset<T, basecountry$fundraiserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the basecountry model
   */
  interface basecountryFieldRefs {
    readonly BaseCountryID: FieldRef<"basecountry", 'Int'>
    readonly BaseCountryName: FieldRef<"basecountry", 'String'>
  }
    

  // Custom InputTypes
  /**
   * basecountry findUnique
   */
  export type basecountryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basecountry
     */
    select?: basecountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the basecountry
     */
    omit?: basecountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basecountryInclude<ExtArgs> | null
    /**
     * Filter, which basecountry to fetch.
     */
    where: basecountryWhereUniqueInput
  }

  /**
   * basecountry findUniqueOrThrow
   */
  export type basecountryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basecountry
     */
    select?: basecountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the basecountry
     */
    omit?: basecountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basecountryInclude<ExtArgs> | null
    /**
     * Filter, which basecountry to fetch.
     */
    where: basecountryWhereUniqueInput
  }

  /**
   * basecountry findFirst
   */
  export type basecountryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basecountry
     */
    select?: basecountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the basecountry
     */
    omit?: basecountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basecountryInclude<ExtArgs> | null
    /**
     * Filter, which basecountry to fetch.
     */
    where?: basecountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basecountries to fetch.
     */
    orderBy?: basecountryOrderByWithRelationInput | basecountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for basecountries.
     */
    cursor?: basecountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basecountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basecountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of basecountries.
     */
    distinct?: BasecountryScalarFieldEnum | BasecountryScalarFieldEnum[]
  }

  /**
   * basecountry findFirstOrThrow
   */
  export type basecountryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basecountry
     */
    select?: basecountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the basecountry
     */
    omit?: basecountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basecountryInclude<ExtArgs> | null
    /**
     * Filter, which basecountry to fetch.
     */
    where?: basecountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basecountries to fetch.
     */
    orderBy?: basecountryOrderByWithRelationInput | basecountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for basecountries.
     */
    cursor?: basecountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basecountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basecountries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of basecountries.
     */
    distinct?: BasecountryScalarFieldEnum | BasecountryScalarFieldEnum[]
  }

  /**
   * basecountry findMany
   */
  export type basecountryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basecountry
     */
    select?: basecountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the basecountry
     */
    omit?: basecountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basecountryInclude<ExtArgs> | null
    /**
     * Filter, which basecountries to fetch.
     */
    where?: basecountryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of basecountries to fetch.
     */
    orderBy?: basecountryOrderByWithRelationInput | basecountryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing basecountries.
     */
    cursor?: basecountryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` basecountries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` basecountries.
     */
    skip?: number
    distinct?: BasecountryScalarFieldEnum | BasecountryScalarFieldEnum[]
  }

  /**
   * basecountry create
   */
  export type basecountryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basecountry
     */
    select?: basecountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the basecountry
     */
    omit?: basecountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basecountryInclude<ExtArgs> | null
    /**
     * The data needed to create a basecountry.
     */
    data: XOR<basecountryCreateInput, basecountryUncheckedCreateInput>
  }

  /**
   * basecountry createMany
   */
  export type basecountryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many basecountries.
     */
    data: basecountryCreateManyInput | basecountryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * basecountry update
   */
  export type basecountryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basecountry
     */
    select?: basecountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the basecountry
     */
    omit?: basecountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basecountryInclude<ExtArgs> | null
    /**
     * The data needed to update a basecountry.
     */
    data: XOR<basecountryUpdateInput, basecountryUncheckedUpdateInput>
    /**
     * Choose, which basecountry to update.
     */
    where: basecountryWhereUniqueInput
  }

  /**
   * basecountry updateMany
   */
  export type basecountryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update basecountries.
     */
    data: XOR<basecountryUpdateManyMutationInput, basecountryUncheckedUpdateManyInput>
    /**
     * Filter which basecountries to update
     */
    where?: basecountryWhereInput
    /**
     * Limit how many basecountries to update.
     */
    limit?: number
  }

  /**
   * basecountry upsert
   */
  export type basecountryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basecountry
     */
    select?: basecountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the basecountry
     */
    omit?: basecountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basecountryInclude<ExtArgs> | null
    /**
     * The filter to search for the basecountry to update in case it exists.
     */
    where: basecountryWhereUniqueInput
    /**
     * In case the basecountry found by the `where` argument doesn't exist, create a new basecountry with this data.
     */
    create: XOR<basecountryCreateInput, basecountryUncheckedCreateInput>
    /**
     * In case the basecountry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<basecountryUpdateInput, basecountryUncheckedUpdateInput>
  }

  /**
   * basecountry delete
   */
  export type basecountryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basecountry
     */
    select?: basecountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the basecountry
     */
    omit?: basecountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basecountryInclude<ExtArgs> | null
    /**
     * Filter which basecountry to delete.
     */
    where: basecountryWhereUniqueInput
  }

  /**
   * basecountry deleteMany
   */
  export type basecountryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which basecountries to delete
     */
    where?: basecountryWhereInput
    /**
     * Limit how many basecountries to delete.
     */
    limit?: number
  }

  /**
   * basecountry.exchangerates
   */
  export type basecountry$exchangeratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
    where?: exchangeratesWhereInput
    orderBy?: exchangeratesOrderByWithRelationInput | exchangeratesOrderByWithRelationInput[]
    cursor?: exchangeratesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangeratesScalarFieldEnum | ExchangeratesScalarFieldEnum[]
  }

  /**
   * basecountry.fundraiser
   */
  export type basecountry$fundraiserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    where?: fundraiserWhereInput
    orderBy?: fundraiserOrderByWithRelationInput | fundraiserOrderByWithRelationInput[]
    cursor?: fundraiserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FundraiserScalarFieldEnum | FundraiserScalarFieldEnum[]
  }

  /**
   * basecountry without action
   */
  export type basecountryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basecountry
     */
    select?: basecountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the basecountry
     */
    omit?: basecountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basecountryInclude<ExtArgs> | null
  }


  /**
   * Model currency
   */

  export type AggregateCurrency = {
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  export type CurrencyAvgAggregateOutputType = {
    CurrencyId: number | null
  }

  export type CurrencySumAggregateOutputType = {
    CurrencyId: number | null
  }

  export type CurrencyMinAggregateOutputType = {
    CurrencyId: number | null
    CurrencyCode: string | null
  }

  export type CurrencyMaxAggregateOutputType = {
    CurrencyId: number | null
    CurrencyCode: string | null
  }

  export type CurrencyCountAggregateOutputType = {
    CurrencyId: number
    CurrencyCode: number
    _all: number
  }


  export type CurrencyAvgAggregateInputType = {
    CurrencyId?: true
  }

  export type CurrencySumAggregateInputType = {
    CurrencyId?: true
  }

  export type CurrencyMinAggregateInputType = {
    CurrencyId?: true
    CurrencyCode?: true
  }

  export type CurrencyMaxAggregateInputType = {
    CurrencyId?: true
    CurrencyCode?: true
  }

  export type CurrencyCountAggregateInputType = {
    CurrencyId?: true
    CurrencyCode?: true
    _all?: true
  }

  export type CurrencyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which currency to aggregate.
     */
    where?: currencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currencies to fetch.
     */
    orderBy?: currencyOrderByWithRelationInput | currencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: currencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned currencies
    **/
    _count?: true | CurrencyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CurrencyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CurrencySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CurrencyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CurrencyMaxAggregateInputType
  }

  export type GetCurrencyAggregateType<T extends CurrencyAggregateArgs> = {
        [P in keyof T & keyof AggregateCurrency]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCurrency[P]>
      : GetScalarType<T[P], AggregateCurrency[P]>
  }




  export type currencyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: currencyWhereInput
    orderBy?: currencyOrderByWithAggregationInput | currencyOrderByWithAggregationInput[]
    by: CurrencyScalarFieldEnum[] | CurrencyScalarFieldEnum
    having?: currencyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CurrencyCountAggregateInputType | true
    _avg?: CurrencyAvgAggregateInputType
    _sum?: CurrencySumAggregateInputType
    _min?: CurrencyMinAggregateInputType
    _max?: CurrencyMaxAggregateInputType
  }

  export type CurrencyGroupByOutputType = {
    CurrencyId: number
    CurrencyCode: string | null
    _count: CurrencyCountAggregateOutputType | null
    _avg: CurrencyAvgAggregateOutputType | null
    _sum: CurrencySumAggregateOutputType | null
    _min: CurrencyMinAggregateOutputType | null
    _max: CurrencyMaxAggregateOutputType | null
  }

  type GetCurrencyGroupByPayload<T extends currencyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CurrencyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CurrencyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
            : GetScalarType<T[P], CurrencyGroupByOutputType[P]>
        }
      >
    >


  export type currencySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CurrencyId?: boolean
    CurrencyCode?: boolean
    exchangerates?: boolean | currency$exchangeratesArgs<ExtArgs>
    fundraiser_acceptedcurrencies?: boolean | currency$fundraiser_acceptedcurrenciesArgs<ExtArgs>
    minimumamount?: boolean | currency$minimumamountArgs<ExtArgs>
    wallet?: boolean | currency$walletArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["currency"]>



  export type currencySelectScalar = {
    CurrencyId?: boolean
    CurrencyCode?: boolean
  }

  export type currencyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"CurrencyId" | "CurrencyCode", ExtArgs["result"]["currency"]>
  export type currencyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    exchangerates?: boolean | currency$exchangeratesArgs<ExtArgs>
    fundraiser_acceptedcurrencies?: boolean | currency$fundraiser_acceptedcurrenciesArgs<ExtArgs>
    minimumamount?: boolean | currency$minimumamountArgs<ExtArgs>
    wallet?: boolean | currency$walletArgs<ExtArgs>
    _count?: boolean | CurrencyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $currencyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "currency"
    objects: {
      exchangerates: Prisma.$exchangeratesPayload<ExtArgs>[]
      fundraiser_acceptedcurrencies: Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>[]
      minimumamount: Prisma.$minimumamountPayload<ExtArgs>[]
      wallet: Prisma.$walletPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      CurrencyId: number
      CurrencyCode: string | null
    }, ExtArgs["result"]["currency"]>
    composites: {}
  }

  type currencyGetPayload<S extends boolean | null | undefined | currencyDefaultArgs> = $Result.GetResult<Prisma.$currencyPayload, S>

  type currencyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<currencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CurrencyCountAggregateInputType | true
    }

  export interface currencyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['currency'], meta: { name: 'currency' } }
    /**
     * Find zero or one Currency that matches the filter.
     * @param {currencyFindUniqueArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends currencyFindUniqueArgs>(args: SelectSubset<T, currencyFindUniqueArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Currency that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {currencyFindUniqueOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends currencyFindUniqueOrThrowArgs>(args: SelectSubset<T, currencyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currencyFindFirstArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends currencyFindFirstArgs>(args?: SelectSubset<T, currencyFindFirstArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Currency that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currencyFindFirstOrThrowArgs} args - Arguments to find a Currency
     * @example
     * // Get one Currency
     * const currency = await prisma.currency.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends currencyFindFirstOrThrowArgs>(args?: SelectSubset<T, currencyFindFirstOrThrowArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Currencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currencyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Currencies
     * const currencies = await prisma.currency.findMany()
     * 
     * // Get first 10 Currencies
     * const currencies = await prisma.currency.findMany({ take: 10 })
     * 
     * // Only select the `CurrencyId`
     * const currencyWithCurrencyIdOnly = await prisma.currency.findMany({ select: { CurrencyId: true } })
     * 
     */
    findMany<T extends currencyFindManyArgs>(args?: SelectSubset<T, currencyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Currency.
     * @param {currencyCreateArgs} args - Arguments to create a Currency.
     * @example
     * // Create one Currency
     * const Currency = await prisma.currency.create({
     *   data: {
     *     // ... data to create a Currency
     *   }
     * })
     * 
     */
    create<T extends currencyCreateArgs>(args: SelectSubset<T, currencyCreateArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Currencies.
     * @param {currencyCreateManyArgs} args - Arguments to create many Currencies.
     * @example
     * // Create many Currencies
     * const currency = await prisma.currency.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends currencyCreateManyArgs>(args?: SelectSubset<T, currencyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Currency.
     * @param {currencyDeleteArgs} args - Arguments to delete one Currency.
     * @example
     * // Delete one Currency
     * const Currency = await prisma.currency.delete({
     *   where: {
     *     // ... filter to delete one Currency
     *   }
     * })
     * 
     */
    delete<T extends currencyDeleteArgs>(args: SelectSubset<T, currencyDeleteArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Currency.
     * @param {currencyUpdateArgs} args - Arguments to update one Currency.
     * @example
     * // Update one Currency
     * const currency = await prisma.currency.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends currencyUpdateArgs>(args: SelectSubset<T, currencyUpdateArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Currencies.
     * @param {currencyDeleteManyArgs} args - Arguments to filter Currencies to delete.
     * @example
     * // Delete a few Currencies
     * const { count } = await prisma.currency.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends currencyDeleteManyArgs>(args?: SelectSubset<T, currencyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currencyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Currencies
     * const currency = await prisma.currency.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends currencyUpdateManyArgs>(args: SelectSubset<T, currencyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Currency.
     * @param {currencyUpsertArgs} args - Arguments to update or create a Currency.
     * @example
     * // Update or create a Currency
     * const currency = await prisma.currency.upsert({
     *   create: {
     *     // ... data to create a Currency
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Currency we want to update
     *   }
     * })
     */
    upsert<T extends currencyUpsertArgs>(args: SelectSubset<T, currencyUpsertArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Currencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currencyCountArgs} args - Arguments to filter Currencies to count.
     * @example
     * // Count the number of Currencies
     * const count = await prisma.currency.count({
     *   where: {
     *     // ... the filter for the Currencies we want to count
     *   }
     * })
    **/
    count<T extends currencyCountArgs>(
      args?: Subset<T, currencyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CurrencyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CurrencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CurrencyAggregateArgs>(args: Subset<T, CurrencyAggregateArgs>): Prisma.PrismaPromise<GetCurrencyAggregateType<T>>

    /**
     * Group by Currency.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {currencyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends currencyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: currencyGroupByArgs['orderBy'] }
        : { orderBy?: currencyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, currencyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCurrencyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the currency model
   */
  readonly fields: currencyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for currency.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__currencyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    exchangerates<T extends currency$exchangeratesArgs<ExtArgs> = {}>(args?: Subset<T, currency$exchangeratesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exchangeratesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fundraiser_acceptedcurrencies<T extends currency$fundraiser_acceptedcurrenciesArgs<ExtArgs> = {}>(args?: Subset<T, currency$fundraiser_acceptedcurrenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    minimumamount<T extends currency$minimumamountArgs<ExtArgs> = {}>(args?: Subset<T, currency$minimumamountArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$minimumamountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    wallet<T extends currency$walletArgs<ExtArgs> = {}>(args?: Subset<T, currency$walletArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the currency model
   */
  interface currencyFieldRefs {
    readonly CurrencyId: FieldRef<"currency", 'Int'>
    readonly CurrencyCode: FieldRef<"currency", 'String'>
  }
    

  // Custom InputTypes
  /**
   * currency findUnique
   */
  export type currencyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
    /**
     * Filter, which currency to fetch.
     */
    where: currencyWhereUniqueInput
  }

  /**
   * currency findUniqueOrThrow
   */
  export type currencyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
    /**
     * Filter, which currency to fetch.
     */
    where: currencyWhereUniqueInput
  }

  /**
   * currency findFirst
   */
  export type currencyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
    /**
     * Filter, which currency to fetch.
     */
    where?: currencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currencies to fetch.
     */
    orderBy?: currencyOrderByWithRelationInput | currencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for currencies.
     */
    cursor?: currencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * currency findFirstOrThrow
   */
  export type currencyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
    /**
     * Filter, which currency to fetch.
     */
    where?: currencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currencies to fetch.
     */
    orderBy?: currencyOrderByWithRelationInput | currencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for currencies.
     */
    cursor?: currencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of currencies.
     */
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * currency findMany
   */
  export type currencyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
    /**
     * Filter, which currencies to fetch.
     */
    where?: currencyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of currencies to fetch.
     */
    orderBy?: currencyOrderByWithRelationInput | currencyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing currencies.
     */
    cursor?: currencyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` currencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` currencies.
     */
    skip?: number
    distinct?: CurrencyScalarFieldEnum | CurrencyScalarFieldEnum[]
  }

  /**
   * currency create
   */
  export type currencyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
    /**
     * The data needed to create a currency.
     */
    data?: XOR<currencyCreateInput, currencyUncheckedCreateInput>
  }

  /**
   * currency createMany
   */
  export type currencyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many currencies.
     */
    data: currencyCreateManyInput | currencyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * currency update
   */
  export type currencyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
    /**
     * The data needed to update a currency.
     */
    data: XOR<currencyUpdateInput, currencyUncheckedUpdateInput>
    /**
     * Choose, which currency to update.
     */
    where: currencyWhereUniqueInput
  }

  /**
   * currency updateMany
   */
  export type currencyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update currencies.
     */
    data: XOR<currencyUpdateManyMutationInput, currencyUncheckedUpdateManyInput>
    /**
     * Filter which currencies to update
     */
    where?: currencyWhereInput
    /**
     * Limit how many currencies to update.
     */
    limit?: number
  }

  /**
   * currency upsert
   */
  export type currencyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
    /**
     * The filter to search for the currency to update in case it exists.
     */
    where: currencyWhereUniqueInput
    /**
     * In case the currency found by the `where` argument doesn't exist, create a new currency with this data.
     */
    create: XOR<currencyCreateInput, currencyUncheckedCreateInput>
    /**
     * In case the currency was found with the provided `where` argument, update it with this data.
     */
    update: XOR<currencyUpdateInput, currencyUncheckedUpdateInput>
  }

  /**
   * currency delete
   */
  export type currencyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
    /**
     * Filter which currency to delete.
     */
    where: currencyWhereUniqueInput
  }

  /**
   * currency deleteMany
   */
  export type currencyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which currencies to delete
     */
    where?: currencyWhereInput
    /**
     * Limit how many currencies to delete.
     */
    limit?: number
  }

  /**
   * currency.exchangerates
   */
  export type currency$exchangeratesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
    where?: exchangeratesWhereInput
    orderBy?: exchangeratesOrderByWithRelationInput | exchangeratesOrderByWithRelationInput[]
    cursor?: exchangeratesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExchangeratesScalarFieldEnum | ExchangeratesScalarFieldEnum[]
  }

  /**
   * currency.fundraiser_acceptedcurrencies
   */
  export type currency$fundraiser_acceptedcurrenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
    where?: fundraiser_acceptedcurrenciesWhereInput
    orderBy?: fundraiser_acceptedcurrenciesOrderByWithRelationInput | fundraiser_acceptedcurrenciesOrderByWithRelationInput[]
    cursor?: fundraiser_acceptedcurrenciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Fundraiser_acceptedcurrenciesScalarFieldEnum | Fundraiser_acceptedcurrenciesScalarFieldEnum[]
  }

  /**
   * currency.minimumamount
   */
  export type currency$minimumamountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the minimumamount
     */
    select?: minimumamountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the minimumamount
     */
    omit?: minimumamountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: minimumamountInclude<ExtArgs> | null
    where?: minimumamountWhereInput
    orderBy?: minimumamountOrderByWithRelationInput | minimumamountOrderByWithRelationInput[]
    cursor?: minimumamountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MinimumamountScalarFieldEnum | MinimumamountScalarFieldEnum[]
  }

  /**
   * currency.wallet
   */
  export type currency$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    where?: walletWhereInput
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    cursor?: walletWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * currency without action
   */
  export type currencyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
  }


  /**
   * Model customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerAvgAggregateOutputType = {
    CustomerId: number | null
    AgentId: number | null
    CardID: number | null
  }

  export type CustomerSumAggregateOutputType = {
    CustomerId: number | null
    AgentId: number | null
    CardID: number | null
  }

  export type CustomerMinAggregateOutputType = {
    CustomerId: number | null
    Name: string | null
    Email: string | null
    ManyChatId: string | null
    ExpireDate: Date | null
    UserCountry: string | null
    ContactLink: string | null
    AgentId: number | null
    CardID: number | null
  }

  export type CustomerMaxAggregateOutputType = {
    CustomerId: number | null
    Name: string | null
    Email: string | null
    ManyChatId: string | null
    ExpireDate: Date | null
    UserCountry: string | null
    ContactLink: string | null
    AgentId: number | null
    CardID: number | null
  }

  export type CustomerCountAggregateOutputType = {
    CustomerId: number
    Name: number
    Email: number
    ManyChatId: number
    ExpireDate: number
    UserCountry: number
    ContactLink: number
    AgentId: number
    CardID: number
    _all: number
  }


  export type CustomerAvgAggregateInputType = {
    CustomerId?: true
    AgentId?: true
    CardID?: true
  }

  export type CustomerSumAggregateInputType = {
    CustomerId?: true
    AgentId?: true
    CardID?: true
  }

  export type CustomerMinAggregateInputType = {
    CustomerId?: true
    Name?: true
    Email?: true
    ManyChatId?: true
    ExpireDate?: true
    UserCountry?: true
    ContactLink?: true
    AgentId?: true
    CardID?: true
  }

  export type CustomerMaxAggregateInputType = {
    CustomerId?: true
    Name?: true
    Email?: true
    ManyChatId?: true
    ExpireDate?: true
    UserCountry?: true
    ContactLink?: true
    AgentId?: true
    CardID?: true
  }

  export type CustomerCountAggregateInputType = {
    CustomerId?: true
    Name?: true
    Email?: true
    ManyChatId?: true
    ExpireDate?: true
    UserCountry?: true
    ContactLink?: true
    AgentId?: true
    CardID?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer to aggregate.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type customerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
    orderBy?: customerOrderByWithAggregationInput | customerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _avg?: CustomerAvgAggregateInputType
    _sum?: CustomerSumAggregateInputType
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    CustomerId: number
    Name: string | null
    Email: string | null
    ManyChatId: string | null
    ExpireDate: Date | null
    UserCountry: string | null
    ContactLink: string | null
    AgentId: number | null
    CardID: number | null
    _count: CustomerCountAggregateOutputType | null
    _avg: CustomerAvgAggregateOutputType | null
    _sum: CustomerSumAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends customerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type customerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CustomerId?: boolean
    Name?: boolean
    Email?: boolean
    ManyChatId?: boolean
    ExpireDate?: boolean
    UserCountry?: boolean
    ContactLink?: boolean
    AgentId?: boolean
    CardID?: boolean
    agent?: boolean | customer$agentArgs<ExtArgs>
    customerauditlogs?: boolean | customer$customerauditlogsArgs<ExtArgs>
    manychat?: boolean | customer$manychatArgs<ExtArgs>
    transactions?: boolean | customer$transactionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type customerSelectScalar = {
    CustomerId?: boolean
    Name?: boolean
    Email?: boolean
    ManyChatId?: boolean
    ExpireDate?: boolean
    UserCountry?: boolean
    ContactLink?: boolean
    AgentId?: boolean
    CardID?: boolean
  }

  export type customerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"CustomerId" | "Name" | "Email" | "ManyChatId" | "ExpireDate" | "UserCountry" | "ContactLink" | "AgentId" | "CardID", ExtArgs["result"]["customer"]>
  export type customerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | customer$agentArgs<ExtArgs>
    customerauditlogs?: boolean | customer$customerauditlogsArgs<ExtArgs>
    manychat?: boolean | customer$manychatArgs<ExtArgs>
    transactions?: boolean | customer$transactionsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $customerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer"
    objects: {
      agent: Prisma.$agentPayload<ExtArgs> | null
      customerauditlogs: Prisma.$customerauditlogsPayload<ExtArgs>[]
      manychat: Prisma.$manychatPayload<ExtArgs>[]
      transactions: Prisma.$transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      CustomerId: number
      Name: string | null
      Email: string | null
      ManyChatId: string | null
      ExpireDate: Date | null
      UserCountry: string | null
      ContactLink: string | null
      AgentId: number | null
      CardID: number | null
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type customerGetPayload<S extends boolean | null | undefined | customerDefaultArgs> = $Result.GetResult<Prisma.$customerPayload, S>

  type customerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface customerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer'], meta: { name: 'customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {customerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customerFindUniqueArgs>(args: SelectSubset<T, customerFindUniqueArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customerFindUniqueOrThrowArgs>(args: SelectSubset<T, customerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customerFindFirstArgs>(args?: SelectSubset<T, customerFindFirstArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customerFindFirstOrThrowArgs>(args?: SelectSubset<T, customerFindFirstOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `CustomerId`
     * const customerWithCustomerIdOnly = await prisma.customer.findMany({ select: { CustomerId: true } })
     * 
     */
    findMany<T extends customerFindManyArgs>(args?: SelectSubset<T, customerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {customerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends customerCreateArgs>(args: SelectSubset<T, customerCreateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {customerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customerCreateManyArgs>(args?: SelectSubset<T, customerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {customerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends customerDeleteArgs>(args: SelectSubset<T, customerDeleteArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {customerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customerUpdateArgs>(args: SelectSubset<T, customerUpdateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {customerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customerDeleteManyArgs>(args?: SelectSubset<T, customerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customerUpdateManyArgs>(args: SelectSubset<T, customerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {customerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends customerUpsertArgs>(args: SelectSubset<T, customerUpsertArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customerCountArgs>(
      args?: Subset<T, customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerGroupByArgs['orderBy'] }
        : { orderBy?: customerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer model
   */
  readonly fields: customerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends customer$agentArgs<ExtArgs> = {}>(args?: Subset<T, customer$agentArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customerauditlogs<T extends customer$customerauditlogsArgs<ExtArgs> = {}>(args?: Subset<T, customer$customerauditlogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerauditlogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    manychat<T extends customer$manychatArgs<ExtArgs> = {}>(args?: Subset<T, customer$manychatArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manychatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends customer$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, customer$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer model
   */
  interface customerFieldRefs {
    readonly CustomerId: FieldRef<"customer", 'Int'>
    readonly Name: FieldRef<"customer", 'String'>
    readonly Email: FieldRef<"customer", 'String'>
    readonly ManyChatId: FieldRef<"customer", 'String'>
    readonly ExpireDate: FieldRef<"customer", 'DateTime'>
    readonly UserCountry: FieldRef<"customer", 'String'>
    readonly ContactLink: FieldRef<"customer", 'String'>
    readonly AgentId: FieldRef<"customer", 'Int'>
    readonly CardID: FieldRef<"customer", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * customer findUnique
   */
  export type customerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findUniqueOrThrow
   */
  export type customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findFirst
   */
  export type customerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findFirstOrThrow
   */
  export type customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findMany
   */
  export type customerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer create
   */
  export type customerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to create a customer.
     */
    data?: XOR<customerCreateInput, customerUncheckedCreateInput>
  }

  /**
   * customer createMany
   */
  export type customerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customer update
   */
  export type customerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to update a customer.
     */
    data: XOR<customerUpdateInput, customerUncheckedUpdateInput>
    /**
     * Choose, which customer to update.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer updateMany
   */
  export type customerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customer upsert
   */
  export type customerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The filter to search for the customer to update in case it exists.
     */
    where: customerWhereUniqueInput
    /**
     * In case the customer found by the `where` argument doesn't exist, create a new customer with this data.
     */
    create: XOR<customerCreateInput, customerUncheckedCreateInput>
    /**
     * In case the customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerUpdateInput, customerUncheckedUpdateInput>
  }

  /**
   * customer delete
   */
  export type customerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter which customer to delete.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer deleteMany
   */
  export type customerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to delete.
     */
    limit?: number
  }

  /**
   * customer.agent
   */
  export type customer$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    where?: agentWhereInput
  }

  /**
   * customer.customerauditlogs
   */
  export type customer$customerauditlogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
    where?: customerauditlogsWhereInput
    orderBy?: customerauditlogsOrderByWithRelationInput | customerauditlogsOrderByWithRelationInput[]
    cursor?: customerauditlogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerauditlogsScalarFieldEnum | CustomerauditlogsScalarFieldEnum[]
  }

  /**
   * customer.manychat
   */
  export type customer$manychatArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manychat
     */
    select?: manychatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manychat
     */
    omit?: manychatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manychatInclude<ExtArgs> | null
    where?: manychatWhereInput
    orderBy?: manychatOrderByWithRelationInput | manychatOrderByWithRelationInput[]
    cursor?: manychatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ManychatScalarFieldEnum | ManychatScalarFieldEnum[]
  }

  /**
   * customer.transactions
   */
  export type customer$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * customer without action
   */
  export type customerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
  }


  /**
   * Model customerauditlogs
   */

  export type AggregateCustomerauditlogs = {
    _count: CustomerauditlogsCountAggregateOutputType | null
    _avg: CustomerauditlogsAvgAggregateOutputType | null
    _sum: CustomerauditlogsSumAggregateOutputType | null
    _min: CustomerauditlogsMinAggregateOutputType | null
    _max: CustomerauditlogsMaxAggregateOutputType | null
  }

  export type CustomerauditlogsAvgAggregateOutputType = {
    LogId: number | null
    AgentId: number | null
    CustomerId: number | null
  }

  export type CustomerauditlogsSumAggregateOutputType = {
    LogId: number | null
    AgentId: number | null
    CustomerId: number | null
  }

  export type CustomerauditlogsMinAggregateOutputType = {
    LogId: number | null
    AgentId: number | null
    FieldChanged: $Enums.customerauditlogs_FieldChanged | null
    OldValue: string | null
    NewValue: string | null
    CustomerId: number | null
    ChangeDate: Date | null
  }

  export type CustomerauditlogsMaxAggregateOutputType = {
    LogId: number | null
    AgentId: number | null
    FieldChanged: $Enums.customerauditlogs_FieldChanged | null
    OldValue: string | null
    NewValue: string | null
    CustomerId: number | null
    ChangeDate: Date | null
  }

  export type CustomerauditlogsCountAggregateOutputType = {
    LogId: number
    AgentId: number
    FieldChanged: number
    OldValue: number
    NewValue: number
    CustomerId: number
    ChangeDate: number
    _all: number
  }


  export type CustomerauditlogsAvgAggregateInputType = {
    LogId?: true
    AgentId?: true
    CustomerId?: true
  }

  export type CustomerauditlogsSumAggregateInputType = {
    LogId?: true
    AgentId?: true
    CustomerId?: true
  }

  export type CustomerauditlogsMinAggregateInputType = {
    LogId?: true
    AgentId?: true
    FieldChanged?: true
    OldValue?: true
    NewValue?: true
    CustomerId?: true
    ChangeDate?: true
  }

  export type CustomerauditlogsMaxAggregateInputType = {
    LogId?: true
    AgentId?: true
    FieldChanged?: true
    OldValue?: true
    NewValue?: true
    CustomerId?: true
    ChangeDate?: true
  }

  export type CustomerauditlogsCountAggregateInputType = {
    LogId?: true
    AgentId?: true
    FieldChanged?: true
    OldValue?: true
    NewValue?: true
    CustomerId?: true
    ChangeDate?: true
    _all?: true
  }

  export type CustomerauditlogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customerauditlogs to aggregate.
     */
    where?: customerauditlogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerauditlogs to fetch.
     */
    orderBy?: customerauditlogsOrderByWithRelationInput | customerauditlogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerauditlogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerauditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerauditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customerauditlogs
    **/
    _count?: true | CustomerauditlogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CustomerauditlogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CustomerauditlogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerauditlogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerauditlogsMaxAggregateInputType
  }

  export type GetCustomerauditlogsAggregateType<T extends CustomerauditlogsAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomerauditlogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomerauditlogs[P]>
      : GetScalarType<T[P], AggregateCustomerauditlogs[P]>
  }




  export type customerauditlogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerauditlogsWhereInput
    orderBy?: customerauditlogsOrderByWithAggregationInput | customerauditlogsOrderByWithAggregationInput[]
    by: CustomerauditlogsScalarFieldEnum[] | CustomerauditlogsScalarFieldEnum
    having?: customerauditlogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerauditlogsCountAggregateInputType | true
    _avg?: CustomerauditlogsAvgAggregateInputType
    _sum?: CustomerauditlogsSumAggregateInputType
    _min?: CustomerauditlogsMinAggregateInputType
    _max?: CustomerauditlogsMaxAggregateInputType
  }

  export type CustomerauditlogsGroupByOutputType = {
    LogId: number
    AgentId: number
    FieldChanged: $Enums.customerauditlogs_FieldChanged
    OldValue: string | null
    NewValue: string | null
    CustomerId: number
    ChangeDate: Date
    _count: CustomerauditlogsCountAggregateOutputType | null
    _avg: CustomerauditlogsAvgAggregateOutputType | null
    _sum: CustomerauditlogsSumAggregateOutputType | null
    _min: CustomerauditlogsMinAggregateOutputType | null
    _max: CustomerauditlogsMaxAggregateOutputType | null
  }

  type GetCustomerauditlogsGroupByPayload<T extends customerauditlogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerauditlogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerauditlogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerauditlogsGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerauditlogsGroupByOutputType[P]>
        }
      >
    >


  export type customerauditlogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    LogId?: boolean
    AgentId?: boolean
    FieldChanged?: boolean
    OldValue?: boolean
    NewValue?: boolean
    CustomerId?: boolean
    ChangeDate?: boolean
    agent?: boolean | agentDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customerauditlogs"]>



  export type customerauditlogsSelectScalar = {
    LogId?: boolean
    AgentId?: boolean
    FieldChanged?: boolean
    OldValue?: boolean
    NewValue?: boolean
    CustomerId?: boolean
    ChangeDate?: boolean
  }

  export type customerauditlogsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"LogId" | "AgentId" | "FieldChanged" | "OldValue" | "NewValue" | "CustomerId" | "ChangeDate", ExtArgs["result"]["customerauditlogs"]>
  export type customerauditlogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | agentDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }

  export type $customerauditlogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customerauditlogs"
    objects: {
      agent: Prisma.$agentPayload<ExtArgs>
      customer: Prisma.$customerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      LogId: number
      AgentId: number
      FieldChanged: $Enums.customerauditlogs_FieldChanged
      OldValue: string | null
      NewValue: string | null
      CustomerId: number
      ChangeDate: Date
    }, ExtArgs["result"]["customerauditlogs"]>
    composites: {}
  }

  type customerauditlogsGetPayload<S extends boolean | null | undefined | customerauditlogsDefaultArgs> = $Result.GetResult<Prisma.$customerauditlogsPayload, S>

  type customerauditlogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customerauditlogsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerauditlogsCountAggregateInputType | true
    }

  export interface customerauditlogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customerauditlogs'], meta: { name: 'customerauditlogs' } }
    /**
     * Find zero or one Customerauditlogs that matches the filter.
     * @param {customerauditlogsFindUniqueArgs} args - Arguments to find a Customerauditlogs
     * @example
     * // Get one Customerauditlogs
     * const customerauditlogs = await prisma.customerauditlogs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customerauditlogsFindUniqueArgs>(args: SelectSubset<T, customerauditlogsFindUniqueArgs<ExtArgs>>): Prisma__customerauditlogsClient<$Result.GetResult<Prisma.$customerauditlogsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customerauditlogs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customerauditlogsFindUniqueOrThrowArgs} args - Arguments to find a Customerauditlogs
     * @example
     * // Get one Customerauditlogs
     * const customerauditlogs = await prisma.customerauditlogs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customerauditlogsFindUniqueOrThrowArgs>(args: SelectSubset<T, customerauditlogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customerauditlogsClient<$Result.GetResult<Prisma.$customerauditlogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customerauditlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerauditlogsFindFirstArgs} args - Arguments to find a Customerauditlogs
     * @example
     * // Get one Customerauditlogs
     * const customerauditlogs = await prisma.customerauditlogs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customerauditlogsFindFirstArgs>(args?: SelectSubset<T, customerauditlogsFindFirstArgs<ExtArgs>>): Prisma__customerauditlogsClient<$Result.GetResult<Prisma.$customerauditlogsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customerauditlogs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerauditlogsFindFirstOrThrowArgs} args - Arguments to find a Customerauditlogs
     * @example
     * // Get one Customerauditlogs
     * const customerauditlogs = await prisma.customerauditlogs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customerauditlogsFindFirstOrThrowArgs>(args?: SelectSubset<T, customerauditlogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__customerauditlogsClient<$Result.GetResult<Prisma.$customerauditlogsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customerauditlogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerauditlogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customerauditlogs
     * const customerauditlogs = await prisma.customerauditlogs.findMany()
     * 
     * // Get first 10 Customerauditlogs
     * const customerauditlogs = await prisma.customerauditlogs.findMany({ take: 10 })
     * 
     * // Only select the `LogId`
     * const customerauditlogsWithLogIdOnly = await prisma.customerauditlogs.findMany({ select: { LogId: true } })
     * 
     */
    findMany<T extends customerauditlogsFindManyArgs>(args?: SelectSubset<T, customerauditlogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerauditlogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customerauditlogs.
     * @param {customerauditlogsCreateArgs} args - Arguments to create a Customerauditlogs.
     * @example
     * // Create one Customerauditlogs
     * const Customerauditlogs = await prisma.customerauditlogs.create({
     *   data: {
     *     // ... data to create a Customerauditlogs
     *   }
     * })
     * 
     */
    create<T extends customerauditlogsCreateArgs>(args: SelectSubset<T, customerauditlogsCreateArgs<ExtArgs>>): Prisma__customerauditlogsClient<$Result.GetResult<Prisma.$customerauditlogsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customerauditlogs.
     * @param {customerauditlogsCreateManyArgs} args - Arguments to create many Customerauditlogs.
     * @example
     * // Create many Customerauditlogs
     * const customerauditlogs = await prisma.customerauditlogs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customerauditlogsCreateManyArgs>(args?: SelectSubset<T, customerauditlogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customerauditlogs.
     * @param {customerauditlogsDeleteArgs} args - Arguments to delete one Customerauditlogs.
     * @example
     * // Delete one Customerauditlogs
     * const Customerauditlogs = await prisma.customerauditlogs.delete({
     *   where: {
     *     // ... filter to delete one Customerauditlogs
     *   }
     * })
     * 
     */
    delete<T extends customerauditlogsDeleteArgs>(args: SelectSubset<T, customerauditlogsDeleteArgs<ExtArgs>>): Prisma__customerauditlogsClient<$Result.GetResult<Prisma.$customerauditlogsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customerauditlogs.
     * @param {customerauditlogsUpdateArgs} args - Arguments to update one Customerauditlogs.
     * @example
     * // Update one Customerauditlogs
     * const customerauditlogs = await prisma.customerauditlogs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customerauditlogsUpdateArgs>(args: SelectSubset<T, customerauditlogsUpdateArgs<ExtArgs>>): Prisma__customerauditlogsClient<$Result.GetResult<Prisma.$customerauditlogsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customerauditlogs.
     * @param {customerauditlogsDeleteManyArgs} args - Arguments to filter Customerauditlogs to delete.
     * @example
     * // Delete a few Customerauditlogs
     * const { count } = await prisma.customerauditlogs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customerauditlogsDeleteManyArgs>(args?: SelectSubset<T, customerauditlogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customerauditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerauditlogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customerauditlogs
     * const customerauditlogs = await prisma.customerauditlogs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customerauditlogsUpdateManyArgs>(args: SelectSubset<T, customerauditlogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customerauditlogs.
     * @param {customerauditlogsUpsertArgs} args - Arguments to update or create a Customerauditlogs.
     * @example
     * // Update or create a Customerauditlogs
     * const customerauditlogs = await prisma.customerauditlogs.upsert({
     *   create: {
     *     // ... data to create a Customerauditlogs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customerauditlogs we want to update
     *   }
     * })
     */
    upsert<T extends customerauditlogsUpsertArgs>(args: SelectSubset<T, customerauditlogsUpsertArgs<ExtArgs>>): Prisma__customerauditlogsClient<$Result.GetResult<Prisma.$customerauditlogsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Customerauditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerauditlogsCountArgs} args - Arguments to filter Customerauditlogs to count.
     * @example
     * // Count the number of Customerauditlogs
     * const count = await prisma.customerauditlogs.count({
     *   where: {
     *     // ... the filter for the Customerauditlogs we want to count
     *   }
     * })
    **/
    count<T extends customerauditlogsCountArgs>(
      args?: Subset<T, customerauditlogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerauditlogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customerauditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerauditlogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerauditlogsAggregateArgs>(args: Subset<T, CustomerauditlogsAggregateArgs>): Prisma.PrismaPromise<GetCustomerauditlogsAggregateType<T>>

    /**
     * Group by Customerauditlogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerauditlogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerauditlogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerauditlogsGroupByArgs['orderBy'] }
        : { orderBy?: customerauditlogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerauditlogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerauditlogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customerauditlogs model
   */
  readonly fields: customerauditlogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customerauditlogs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerauditlogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends agentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, agentDefaultArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customerauditlogs model
   */
  interface customerauditlogsFieldRefs {
    readonly LogId: FieldRef<"customerauditlogs", 'Int'>
    readonly AgentId: FieldRef<"customerauditlogs", 'Int'>
    readonly FieldChanged: FieldRef<"customerauditlogs", 'customerauditlogs_FieldChanged'>
    readonly OldValue: FieldRef<"customerauditlogs", 'String'>
    readonly NewValue: FieldRef<"customerauditlogs", 'String'>
    readonly CustomerId: FieldRef<"customerauditlogs", 'Int'>
    readonly ChangeDate: FieldRef<"customerauditlogs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customerauditlogs findUnique
   */
  export type customerauditlogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
    /**
     * Filter, which customerauditlogs to fetch.
     */
    where: customerauditlogsWhereUniqueInput
  }

  /**
   * customerauditlogs findUniqueOrThrow
   */
  export type customerauditlogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
    /**
     * Filter, which customerauditlogs to fetch.
     */
    where: customerauditlogsWhereUniqueInput
  }

  /**
   * customerauditlogs findFirst
   */
  export type customerauditlogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
    /**
     * Filter, which customerauditlogs to fetch.
     */
    where?: customerauditlogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerauditlogs to fetch.
     */
    orderBy?: customerauditlogsOrderByWithRelationInput | customerauditlogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customerauditlogs.
     */
    cursor?: customerauditlogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerauditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerauditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customerauditlogs.
     */
    distinct?: CustomerauditlogsScalarFieldEnum | CustomerauditlogsScalarFieldEnum[]
  }

  /**
   * customerauditlogs findFirstOrThrow
   */
  export type customerauditlogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
    /**
     * Filter, which customerauditlogs to fetch.
     */
    where?: customerauditlogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerauditlogs to fetch.
     */
    orderBy?: customerauditlogsOrderByWithRelationInput | customerauditlogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customerauditlogs.
     */
    cursor?: customerauditlogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerauditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerauditlogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customerauditlogs.
     */
    distinct?: CustomerauditlogsScalarFieldEnum | CustomerauditlogsScalarFieldEnum[]
  }

  /**
   * customerauditlogs findMany
   */
  export type customerauditlogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
    /**
     * Filter, which customerauditlogs to fetch.
     */
    where?: customerauditlogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customerauditlogs to fetch.
     */
    orderBy?: customerauditlogsOrderByWithRelationInput | customerauditlogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customerauditlogs.
     */
    cursor?: customerauditlogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customerauditlogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customerauditlogs.
     */
    skip?: number
    distinct?: CustomerauditlogsScalarFieldEnum | CustomerauditlogsScalarFieldEnum[]
  }

  /**
   * customerauditlogs create
   */
  export type customerauditlogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
    /**
     * The data needed to create a customerauditlogs.
     */
    data: XOR<customerauditlogsCreateInput, customerauditlogsUncheckedCreateInput>
  }

  /**
   * customerauditlogs createMany
   */
  export type customerauditlogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customerauditlogs.
     */
    data: customerauditlogsCreateManyInput | customerauditlogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * customerauditlogs update
   */
  export type customerauditlogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
    /**
     * The data needed to update a customerauditlogs.
     */
    data: XOR<customerauditlogsUpdateInput, customerauditlogsUncheckedUpdateInput>
    /**
     * Choose, which customerauditlogs to update.
     */
    where: customerauditlogsWhereUniqueInput
  }

  /**
   * customerauditlogs updateMany
   */
  export type customerauditlogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customerauditlogs.
     */
    data: XOR<customerauditlogsUpdateManyMutationInput, customerauditlogsUncheckedUpdateManyInput>
    /**
     * Filter which customerauditlogs to update
     */
    where?: customerauditlogsWhereInput
    /**
     * Limit how many customerauditlogs to update.
     */
    limit?: number
  }

  /**
   * customerauditlogs upsert
   */
  export type customerauditlogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
    /**
     * The filter to search for the customerauditlogs to update in case it exists.
     */
    where: customerauditlogsWhereUniqueInput
    /**
     * In case the customerauditlogs found by the `where` argument doesn't exist, create a new customerauditlogs with this data.
     */
    create: XOR<customerauditlogsCreateInput, customerauditlogsUncheckedCreateInput>
    /**
     * In case the customerauditlogs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerauditlogsUpdateInput, customerauditlogsUncheckedUpdateInput>
  }

  /**
   * customerauditlogs delete
   */
  export type customerauditlogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
    /**
     * Filter which customerauditlogs to delete.
     */
    where: customerauditlogsWhereUniqueInput
  }

  /**
   * customerauditlogs deleteMany
   */
  export type customerauditlogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customerauditlogs to delete
     */
    where?: customerauditlogsWhereInput
    /**
     * Limit how many customerauditlogs to delete.
     */
    limit?: number
  }

  /**
   * customerauditlogs without action
   */
  export type customerauditlogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customerauditlogs
     */
    select?: customerauditlogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customerauditlogs
     */
    omit?: customerauditlogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerauditlogsInclude<ExtArgs> | null
  }


  /**
   * Model exchangerates
   */

  export type AggregateExchangerates = {
    _count: ExchangeratesCountAggregateOutputType | null
    _avg: ExchangeratesAvgAggregateOutputType | null
    _sum: ExchangeratesSumAggregateOutputType | null
    _min: ExchangeratesMinAggregateOutputType | null
    _max: ExchangeratesMaxAggregateOutputType | null
  }

  export type ExchangeratesAvgAggregateOutputType = {
    ExchangeRateId: number | null
    BaseCountryId: number | null
    CurrencyId: number | null
    ExchangeRate: Decimal | null
  }

  export type ExchangeratesSumAggregateOutputType = {
    ExchangeRateId: number | null
    BaseCountryId: number | null
    CurrencyId: number | null
    ExchangeRate: Decimal | null
  }

  export type ExchangeratesMinAggregateOutputType = {
    ExchangeRateId: number | null
    BaseCountryId: number | null
    CurrencyId: number | null
    ExchangeRate: Decimal | null
    CreateAt: Date | null
    UpdatedAt: Date | null
  }

  export type ExchangeratesMaxAggregateOutputType = {
    ExchangeRateId: number | null
    BaseCountryId: number | null
    CurrencyId: number | null
    ExchangeRate: Decimal | null
    CreateAt: Date | null
    UpdatedAt: Date | null
  }

  export type ExchangeratesCountAggregateOutputType = {
    ExchangeRateId: number
    BaseCountryId: number
    CurrencyId: number
    ExchangeRate: number
    CreateAt: number
    UpdatedAt: number
    _all: number
  }


  export type ExchangeratesAvgAggregateInputType = {
    ExchangeRateId?: true
    BaseCountryId?: true
    CurrencyId?: true
    ExchangeRate?: true
  }

  export type ExchangeratesSumAggregateInputType = {
    ExchangeRateId?: true
    BaseCountryId?: true
    CurrencyId?: true
    ExchangeRate?: true
  }

  export type ExchangeratesMinAggregateInputType = {
    ExchangeRateId?: true
    BaseCountryId?: true
    CurrencyId?: true
    ExchangeRate?: true
    CreateAt?: true
    UpdatedAt?: true
  }

  export type ExchangeratesMaxAggregateInputType = {
    ExchangeRateId?: true
    BaseCountryId?: true
    CurrencyId?: true
    ExchangeRate?: true
    CreateAt?: true
    UpdatedAt?: true
  }

  export type ExchangeratesCountAggregateInputType = {
    ExchangeRateId?: true
    BaseCountryId?: true
    CurrencyId?: true
    ExchangeRate?: true
    CreateAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type ExchangeratesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exchangerates to aggregate.
     */
    where?: exchangeratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchangerates to fetch.
     */
    orderBy?: exchangeratesOrderByWithRelationInput | exchangeratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: exchangeratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchangerates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchangerates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned exchangerates
    **/
    _count?: true | ExchangeratesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExchangeratesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExchangeratesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExchangeratesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExchangeratesMaxAggregateInputType
  }

  export type GetExchangeratesAggregateType<T extends ExchangeratesAggregateArgs> = {
        [P in keyof T & keyof AggregateExchangerates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchangerates[P]>
      : GetScalarType<T[P], AggregateExchangerates[P]>
  }




  export type exchangeratesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: exchangeratesWhereInput
    orderBy?: exchangeratesOrderByWithAggregationInput | exchangeratesOrderByWithAggregationInput[]
    by: ExchangeratesScalarFieldEnum[] | ExchangeratesScalarFieldEnum
    having?: exchangeratesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExchangeratesCountAggregateInputType | true
    _avg?: ExchangeratesAvgAggregateInputType
    _sum?: ExchangeratesSumAggregateInputType
    _min?: ExchangeratesMinAggregateInputType
    _max?: ExchangeratesMaxAggregateInputType
  }

  export type ExchangeratesGroupByOutputType = {
    ExchangeRateId: number
    BaseCountryId: number
    CurrencyId: number
    ExchangeRate: Decimal
    CreateAt: Date
    UpdatedAt: Date
    _count: ExchangeratesCountAggregateOutputType | null
    _avg: ExchangeratesAvgAggregateOutputType | null
    _sum: ExchangeratesSumAggregateOutputType | null
    _min: ExchangeratesMinAggregateOutputType | null
    _max: ExchangeratesMaxAggregateOutputType | null
  }

  type GetExchangeratesGroupByPayload<T extends exchangeratesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExchangeratesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExchangeratesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExchangeratesGroupByOutputType[P]>
            : GetScalarType<T[P], ExchangeratesGroupByOutputType[P]>
        }
      >
    >


  export type exchangeratesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ExchangeRateId?: boolean
    BaseCountryId?: boolean
    CurrencyId?: boolean
    ExchangeRate?: boolean
    CreateAt?: boolean
    UpdatedAt?: boolean
    basecountry?: boolean | basecountryDefaultArgs<ExtArgs>
    currency?: boolean | currencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exchangerates"]>



  export type exchangeratesSelectScalar = {
    ExchangeRateId?: boolean
    BaseCountryId?: boolean
    CurrencyId?: boolean
    ExchangeRate?: boolean
    CreateAt?: boolean
    UpdatedAt?: boolean
  }

  export type exchangeratesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ExchangeRateId" | "BaseCountryId" | "CurrencyId" | "ExchangeRate" | "CreateAt" | "UpdatedAt", ExtArgs["result"]["exchangerates"]>
  export type exchangeratesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    basecountry?: boolean | basecountryDefaultArgs<ExtArgs>
    currency?: boolean | currencyDefaultArgs<ExtArgs>
  }

  export type $exchangeratesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "exchangerates"
    objects: {
      basecountry: Prisma.$basecountryPayload<ExtArgs>
      currency: Prisma.$currencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ExchangeRateId: number
      BaseCountryId: number
      CurrencyId: number
      ExchangeRate: Prisma.Decimal
      CreateAt: Date
      UpdatedAt: Date
    }, ExtArgs["result"]["exchangerates"]>
    composites: {}
  }

  type exchangeratesGetPayload<S extends boolean | null | undefined | exchangeratesDefaultArgs> = $Result.GetResult<Prisma.$exchangeratesPayload, S>

  type exchangeratesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<exchangeratesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ExchangeratesCountAggregateInputType | true
    }

  export interface exchangeratesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['exchangerates'], meta: { name: 'exchangerates' } }
    /**
     * Find zero or one Exchangerates that matches the filter.
     * @param {exchangeratesFindUniqueArgs} args - Arguments to find a Exchangerates
     * @example
     * // Get one Exchangerates
     * const exchangerates = await prisma.exchangerates.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends exchangeratesFindUniqueArgs>(args: SelectSubset<T, exchangeratesFindUniqueArgs<ExtArgs>>): Prisma__exchangeratesClient<$Result.GetResult<Prisma.$exchangeratesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Exchangerates that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {exchangeratesFindUniqueOrThrowArgs} args - Arguments to find a Exchangerates
     * @example
     * // Get one Exchangerates
     * const exchangerates = await prisma.exchangerates.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends exchangeratesFindUniqueOrThrowArgs>(args: SelectSubset<T, exchangeratesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__exchangeratesClient<$Result.GetResult<Prisma.$exchangeratesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exchangerates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchangeratesFindFirstArgs} args - Arguments to find a Exchangerates
     * @example
     * // Get one Exchangerates
     * const exchangerates = await prisma.exchangerates.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends exchangeratesFindFirstArgs>(args?: SelectSubset<T, exchangeratesFindFirstArgs<ExtArgs>>): Prisma__exchangeratesClient<$Result.GetResult<Prisma.$exchangeratesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Exchangerates that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchangeratesFindFirstOrThrowArgs} args - Arguments to find a Exchangerates
     * @example
     * // Get one Exchangerates
     * const exchangerates = await prisma.exchangerates.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends exchangeratesFindFirstOrThrowArgs>(args?: SelectSubset<T, exchangeratesFindFirstOrThrowArgs<ExtArgs>>): Prisma__exchangeratesClient<$Result.GetResult<Prisma.$exchangeratesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Exchangerates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchangeratesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exchangerates
     * const exchangerates = await prisma.exchangerates.findMany()
     * 
     * // Get first 10 Exchangerates
     * const exchangerates = await prisma.exchangerates.findMany({ take: 10 })
     * 
     * // Only select the `ExchangeRateId`
     * const exchangeratesWithExchangeRateIdOnly = await prisma.exchangerates.findMany({ select: { ExchangeRateId: true } })
     * 
     */
    findMany<T extends exchangeratesFindManyArgs>(args?: SelectSubset<T, exchangeratesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$exchangeratesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Exchangerates.
     * @param {exchangeratesCreateArgs} args - Arguments to create a Exchangerates.
     * @example
     * // Create one Exchangerates
     * const Exchangerates = await prisma.exchangerates.create({
     *   data: {
     *     // ... data to create a Exchangerates
     *   }
     * })
     * 
     */
    create<T extends exchangeratesCreateArgs>(args: SelectSubset<T, exchangeratesCreateArgs<ExtArgs>>): Prisma__exchangeratesClient<$Result.GetResult<Prisma.$exchangeratesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Exchangerates.
     * @param {exchangeratesCreateManyArgs} args - Arguments to create many Exchangerates.
     * @example
     * // Create many Exchangerates
     * const exchangerates = await prisma.exchangerates.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends exchangeratesCreateManyArgs>(args?: SelectSubset<T, exchangeratesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Exchangerates.
     * @param {exchangeratesDeleteArgs} args - Arguments to delete one Exchangerates.
     * @example
     * // Delete one Exchangerates
     * const Exchangerates = await prisma.exchangerates.delete({
     *   where: {
     *     // ... filter to delete one Exchangerates
     *   }
     * })
     * 
     */
    delete<T extends exchangeratesDeleteArgs>(args: SelectSubset<T, exchangeratesDeleteArgs<ExtArgs>>): Prisma__exchangeratesClient<$Result.GetResult<Prisma.$exchangeratesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Exchangerates.
     * @param {exchangeratesUpdateArgs} args - Arguments to update one Exchangerates.
     * @example
     * // Update one Exchangerates
     * const exchangerates = await prisma.exchangerates.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends exchangeratesUpdateArgs>(args: SelectSubset<T, exchangeratesUpdateArgs<ExtArgs>>): Prisma__exchangeratesClient<$Result.GetResult<Prisma.$exchangeratesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Exchangerates.
     * @param {exchangeratesDeleteManyArgs} args - Arguments to filter Exchangerates to delete.
     * @example
     * // Delete a few Exchangerates
     * const { count } = await prisma.exchangerates.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends exchangeratesDeleteManyArgs>(args?: SelectSubset<T, exchangeratesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exchangerates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchangeratesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exchangerates
     * const exchangerates = await prisma.exchangerates.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends exchangeratesUpdateManyArgs>(args: SelectSubset<T, exchangeratesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exchangerates.
     * @param {exchangeratesUpsertArgs} args - Arguments to update or create a Exchangerates.
     * @example
     * // Update or create a Exchangerates
     * const exchangerates = await prisma.exchangerates.upsert({
     *   create: {
     *     // ... data to create a Exchangerates
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exchangerates we want to update
     *   }
     * })
     */
    upsert<T extends exchangeratesUpsertArgs>(args: SelectSubset<T, exchangeratesUpsertArgs<ExtArgs>>): Prisma__exchangeratesClient<$Result.GetResult<Prisma.$exchangeratesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Exchangerates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchangeratesCountArgs} args - Arguments to filter Exchangerates to count.
     * @example
     * // Count the number of Exchangerates
     * const count = await prisma.exchangerates.count({
     *   where: {
     *     // ... the filter for the Exchangerates we want to count
     *   }
     * })
    **/
    count<T extends exchangeratesCountArgs>(
      args?: Subset<T, exchangeratesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExchangeratesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exchangerates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeratesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExchangeratesAggregateArgs>(args: Subset<T, ExchangeratesAggregateArgs>): Prisma.PrismaPromise<GetExchangeratesAggregateType<T>>

    /**
     * Group by Exchangerates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {exchangeratesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends exchangeratesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: exchangeratesGroupByArgs['orderBy'] }
        : { orderBy?: exchangeratesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, exchangeratesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchangeratesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the exchangerates model
   */
  readonly fields: exchangeratesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for exchangerates.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__exchangeratesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    basecountry<T extends basecountryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, basecountryDefaultArgs<ExtArgs>>): Prisma__basecountryClient<$Result.GetResult<Prisma.$basecountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    currency<T extends currencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, currencyDefaultArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the exchangerates model
   */
  interface exchangeratesFieldRefs {
    readonly ExchangeRateId: FieldRef<"exchangerates", 'Int'>
    readonly BaseCountryId: FieldRef<"exchangerates", 'Int'>
    readonly CurrencyId: FieldRef<"exchangerates", 'Int'>
    readonly ExchangeRate: FieldRef<"exchangerates", 'Decimal'>
    readonly CreateAt: FieldRef<"exchangerates", 'DateTime'>
    readonly UpdatedAt: FieldRef<"exchangerates", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * exchangerates findUnique
   */
  export type exchangeratesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
    /**
     * Filter, which exchangerates to fetch.
     */
    where: exchangeratesWhereUniqueInput
  }

  /**
   * exchangerates findUniqueOrThrow
   */
  export type exchangeratesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
    /**
     * Filter, which exchangerates to fetch.
     */
    where: exchangeratesWhereUniqueInput
  }

  /**
   * exchangerates findFirst
   */
  export type exchangeratesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
    /**
     * Filter, which exchangerates to fetch.
     */
    where?: exchangeratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchangerates to fetch.
     */
    orderBy?: exchangeratesOrderByWithRelationInput | exchangeratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exchangerates.
     */
    cursor?: exchangeratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchangerates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchangerates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exchangerates.
     */
    distinct?: ExchangeratesScalarFieldEnum | ExchangeratesScalarFieldEnum[]
  }

  /**
   * exchangerates findFirstOrThrow
   */
  export type exchangeratesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
    /**
     * Filter, which exchangerates to fetch.
     */
    where?: exchangeratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchangerates to fetch.
     */
    orderBy?: exchangeratesOrderByWithRelationInput | exchangeratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for exchangerates.
     */
    cursor?: exchangeratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchangerates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchangerates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of exchangerates.
     */
    distinct?: ExchangeratesScalarFieldEnum | ExchangeratesScalarFieldEnum[]
  }

  /**
   * exchangerates findMany
   */
  export type exchangeratesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
    /**
     * Filter, which exchangerates to fetch.
     */
    where?: exchangeratesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of exchangerates to fetch.
     */
    orderBy?: exchangeratesOrderByWithRelationInput | exchangeratesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing exchangerates.
     */
    cursor?: exchangeratesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` exchangerates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` exchangerates.
     */
    skip?: number
    distinct?: ExchangeratesScalarFieldEnum | ExchangeratesScalarFieldEnum[]
  }

  /**
   * exchangerates create
   */
  export type exchangeratesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
    /**
     * The data needed to create a exchangerates.
     */
    data: XOR<exchangeratesCreateInput, exchangeratesUncheckedCreateInput>
  }

  /**
   * exchangerates createMany
   */
  export type exchangeratesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many exchangerates.
     */
    data: exchangeratesCreateManyInput | exchangeratesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * exchangerates update
   */
  export type exchangeratesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
    /**
     * The data needed to update a exchangerates.
     */
    data: XOR<exchangeratesUpdateInput, exchangeratesUncheckedUpdateInput>
    /**
     * Choose, which exchangerates to update.
     */
    where: exchangeratesWhereUniqueInput
  }

  /**
   * exchangerates updateMany
   */
  export type exchangeratesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update exchangerates.
     */
    data: XOR<exchangeratesUpdateManyMutationInput, exchangeratesUncheckedUpdateManyInput>
    /**
     * Filter which exchangerates to update
     */
    where?: exchangeratesWhereInput
    /**
     * Limit how many exchangerates to update.
     */
    limit?: number
  }

  /**
   * exchangerates upsert
   */
  export type exchangeratesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
    /**
     * The filter to search for the exchangerates to update in case it exists.
     */
    where: exchangeratesWhereUniqueInput
    /**
     * In case the exchangerates found by the `where` argument doesn't exist, create a new exchangerates with this data.
     */
    create: XOR<exchangeratesCreateInput, exchangeratesUncheckedCreateInput>
    /**
     * In case the exchangerates was found with the provided `where` argument, update it with this data.
     */
    update: XOR<exchangeratesUpdateInput, exchangeratesUncheckedUpdateInput>
  }

  /**
   * exchangerates delete
   */
  export type exchangeratesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
    /**
     * Filter which exchangerates to delete.
     */
    where: exchangeratesWhereUniqueInput
  }

  /**
   * exchangerates deleteMany
   */
  export type exchangeratesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which exchangerates to delete
     */
    where?: exchangeratesWhereInput
    /**
     * Limit how many exchangerates to delete.
     */
    limit?: number
  }

  /**
   * exchangerates without action
   */
  export type exchangeratesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the exchangerates
     */
    select?: exchangeratesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the exchangerates
     */
    omit?: exchangeratesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: exchangeratesInclude<ExtArgs> | null
  }


  /**
   * Model formstatus
   */

  export type AggregateFormstatus = {
    _count: FormstatusCountAggregateOutputType | null
    _avg: FormstatusAvgAggregateOutputType | null
    _sum: FormstatusSumAggregateOutputType | null
    _min: FormstatusMinAggregateOutputType | null
    _max: FormstatusMaxAggregateOutputType | null
  }

  export type FormstatusAvgAggregateOutputType = {
    FormStatusID: number | null
    TransactionID: number | null
    TransactionStatusID: number | null
  }

  export type FormstatusSumAggregateOutputType = {
    FormStatusID: number | null
    TransactionID: number | null
    TransactionStatusID: number | null
  }

  export type FormstatusMinAggregateOutputType = {
    FormStatusID: number | null
    TransactionID: number | null
    TransactionStatusID: number | null
  }

  export type FormstatusMaxAggregateOutputType = {
    FormStatusID: number | null
    TransactionID: number | null
    TransactionStatusID: number | null
  }

  export type FormstatusCountAggregateOutputType = {
    FormStatusID: number
    TransactionID: number
    TransactionStatusID: number
    _all: number
  }


  export type FormstatusAvgAggregateInputType = {
    FormStatusID?: true
    TransactionID?: true
    TransactionStatusID?: true
  }

  export type FormstatusSumAggregateInputType = {
    FormStatusID?: true
    TransactionID?: true
    TransactionStatusID?: true
  }

  export type FormstatusMinAggregateInputType = {
    FormStatusID?: true
    TransactionID?: true
    TransactionStatusID?: true
  }

  export type FormstatusMaxAggregateInputType = {
    FormStatusID?: true
    TransactionID?: true
    TransactionStatusID?: true
  }

  export type FormstatusCountAggregateInputType = {
    FormStatusID?: true
    TransactionID?: true
    TransactionStatusID?: true
    _all?: true
  }

  export type FormstatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formstatus to aggregate.
     */
    where?: formstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formstatuses to fetch.
     */
    orderBy?: formstatusOrderByWithRelationInput | formstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: formstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formstatuses
    **/
    _count?: true | FormstatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormstatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormstatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormstatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormstatusMaxAggregateInputType
  }

  export type GetFormstatusAggregateType<T extends FormstatusAggregateArgs> = {
        [P in keyof T & keyof AggregateFormstatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormstatus[P]>
      : GetScalarType<T[P], AggregateFormstatus[P]>
  }




  export type formstatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formstatusWhereInput
    orderBy?: formstatusOrderByWithAggregationInput | formstatusOrderByWithAggregationInput[]
    by: FormstatusScalarFieldEnum[] | FormstatusScalarFieldEnum
    having?: formstatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormstatusCountAggregateInputType | true
    _avg?: FormstatusAvgAggregateInputType
    _sum?: FormstatusSumAggregateInputType
    _min?: FormstatusMinAggregateInputType
    _max?: FormstatusMaxAggregateInputType
  }

  export type FormstatusGroupByOutputType = {
    FormStatusID: number
    TransactionID: number | null
    TransactionStatusID: number | null
    _count: FormstatusCountAggregateOutputType | null
    _avg: FormstatusAvgAggregateOutputType | null
    _sum: FormstatusSumAggregateOutputType | null
    _min: FormstatusMinAggregateOutputType | null
    _max: FormstatusMaxAggregateOutputType | null
  }

  type GetFormstatusGroupByPayload<T extends formstatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormstatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormstatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormstatusGroupByOutputType[P]>
            : GetScalarType<T[P], FormstatusGroupByOutputType[P]>
        }
      >
    >


  export type formstatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FormStatusID?: boolean
    TransactionID?: boolean
    TransactionStatusID?: boolean
    transactions?: boolean | formstatus$transactionsArgs<ExtArgs>
    transactionstatus?: boolean | formstatus$transactionstatusArgs<ExtArgs>
  }, ExtArgs["result"]["formstatus"]>



  export type formstatusSelectScalar = {
    FormStatusID?: boolean
    TransactionID?: boolean
    TransactionStatusID?: boolean
  }

  export type formstatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"FormStatusID" | "TransactionID" | "TransactionStatusID", ExtArgs["result"]["formstatus"]>
  export type formstatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | formstatus$transactionsArgs<ExtArgs>
    transactionstatus?: boolean | formstatus$transactionstatusArgs<ExtArgs>
  }

  export type $formstatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "formstatus"
    objects: {
      transactions: Prisma.$transactionsPayload<ExtArgs> | null
      transactionstatus: Prisma.$transactionstatusPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      FormStatusID: number
      TransactionID: number | null
      TransactionStatusID: number | null
    }, ExtArgs["result"]["formstatus"]>
    composites: {}
  }

  type formstatusGetPayload<S extends boolean | null | undefined | formstatusDefaultArgs> = $Result.GetResult<Prisma.$formstatusPayload, S>

  type formstatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<formstatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormstatusCountAggregateInputType | true
    }

  export interface formstatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['formstatus'], meta: { name: 'formstatus' } }
    /**
     * Find zero or one Formstatus that matches the filter.
     * @param {formstatusFindUniqueArgs} args - Arguments to find a Formstatus
     * @example
     * // Get one Formstatus
     * const formstatus = await prisma.formstatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends formstatusFindUniqueArgs>(args: SelectSubset<T, formstatusFindUniqueArgs<ExtArgs>>): Prisma__formstatusClient<$Result.GetResult<Prisma.$formstatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Formstatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {formstatusFindUniqueOrThrowArgs} args - Arguments to find a Formstatus
     * @example
     * // Get one Formstatus
     * const formstatus = await prisma.formstatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends formstatusFindUniqueOrThrowArgs>(args: SelectSubset<T, formstatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__formstatusClient<$Result.GetResult<Prisma.$formstatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Formstatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formstatusFindFirstArgs} args - Arguments to find a Formstatus
     * @example
     * // Get one Formstatus
     * const formstatus = await prisma.formstatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends formstatusFindFirstArgs>(args?: SelectSubset<T, formstatusFindFirstArgs<ExtArgs>>): Prisma__formstatusClient<$Result.GetResult<Prisma.$formstatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Formstatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formstatusFindFirstOrThrowArgs} args - Arguments to find a Formstatus
     * @example
     * // Get one Formstatus
     * const formstatus = await prisma.formstatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends formstatusFindFirstOrThrowArgs>(args?: SelectSubset<T, formstatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__formstatusClient<$Result.GetResult<Prisma.$formstatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Formstatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formstatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Formstatuses
     * const formstatuses = await prisma.formstatus.findMany()
     * 
     * // Get first 10 Formstatuses
     * const formstatuses = await prisma.formstatus.findMany({ take: 10 })
     * 
     * // Only select the `FormStatusID`
     * const formstatusWithFormStatusIDOnly = await prisma.formstatus.findMany({ select: { FormStatusID: true } })
     * 
     */
    findMany<T extends formstatusFindManyArgs>(args?: SelectSubset<T, formstatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formstatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Formstatus.
     * @param {formstatusCreateArgs} args - Arguments to create a Formstatus.
     * @example
     * // Create one Formstatus
     * const Formstatus = await prisma.formstatus.create({
     *   data: {
     *     // ... data to create a Formstatus
     *   }
     * })
     * 
     */
    create<T extends formstatusCreateArgs>(args: SelectSubset<T, formstatusCreateArgs<ExtArgs>>): Prisma__formstatusClient<$Result.GetResult<Prisma.$formstatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Formstatuses.
     * @param {formstatusCreateManyArgs} args - Arguments to create many Formstatuses.
     * @example
     * // Create many Formstatuses
     * const formstatus = await prisma.formstatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends formstatusCreateManyArgs>(args?: SelectSubset<T, formstatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Formstatus.
     * @param {formstatusDeleteArgs} args - Arguments to delete one Formstatus.
     * @example
     * // Delete one Formstatus
     * const Formstatus = await prisma.formstatus.delete({
     *   where: {
     *     // ... filter to delete one Formstatus
     *   }
     * })
     * 
     */
    delete<T extends formstatusDeleteArgs>(args: SelectSubset<T, formstatusDeleteArgs<ExtArgs>>): Prisma__formstatusClient<$Result.GetResult<Prisma.$formstatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Formstatus.
     * @param {formstatusUpdateArgs} args - Arguments to update one Formstatus.
     * @example
     * // Update one Formstatus
     * const formstatus = await prisma.formstatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends formstatusUpdateArgs>(args: SelectSubset<T, formstatusUpdateArgs<ExtArgs>>): Prisma__formstatusClient<$Result.GetResult<Prisma.$formstatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Formstatuses.
     * @param {formstatusDeleteManyArgs} args - Arguments to filter Formstatuses to delete.
     * @example
     * // Delete a few Formstatuses
     * const { count } = await prisma.formstatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends formstatusDeleteManyArgs>(args?: SelectSubset<T, formstatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formstatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Formstatuses
     * const formstatus = await prisma.formstatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends formstatusUpdateManyArgs>(args: SelectSubset<T, formstatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Formstatus.
     * @param {formstatusUpsertArgs} args - Arguments to update or create a Formstatus.
     * @example
     * // Update or create a Formstatus
     * const formstatus = await prisma.formstatus.upsert({
     *   create: {
     *     // ... data to create a Formstatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Formstatus we want to update
     *   }
     * })
     */
    upsert<T extends formstatusUpsertArgs>(args: SelectSubset<T, formstatusUpsertArgs<ExtArgs>>): Prisma__formstatusClient<$Result.GetResult<Prisma.$formstatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Formstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formstatusCountArgs} args - Arguments to filter Formstatuses to count.
     * @example
     * // Count the number of Formstatuses
     * const count = await prisma.formstatus.count({
     *   where: {
     *     // ... the filter for the Formstatuses we want to count
     *   }
     * })
    **/
    count<T extends formstatusCountArgs>(
      args?: Subset<T, formstatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormstatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Formstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormstatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormstatusAggregateArgs>(args: Subset<T, FormstatusAggregateArgs>): Prisma.PrismaPromise<GetFormstatusAggregateType<T>>

    /**
     * Group by Formstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formstatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends formstatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: formstatusGroupByArgs['orderBy'] }
        : { orderBy?: formstatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, formstatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormstatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the formstatus model
   */
  readonly fields: formstatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for formstatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__formstatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends formstatus$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, formstatus$transactionsArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactionstatus<T extends formstatus$transactionstatusArgs<ExtArgs> = {}>(args?: Subset<T, formstatus$transactionstatusArgs<ExtArgs>>): Prisma__transactionstatusClient<$Result.GetResult<Prisma.$transactionstatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the formstatus model
   */
  interface formstatusFieldRefs {
    readonly FormStatusID: FieldRef<"formstatus", 'Int'>
    readonly TransactionID: FieldRef<"formstatus", 'Int'>
    readonly TransactionStatusID: FieldRef<"formstatus", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * formstatus findUnique
   */
  export type formstatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
    /**
     * Filter, which formstatus to fetch.
     */
    where: formstatusWhereUniqueInput
  }

  /**
   * formstatus findUniqueOrThrow
   */
  export type formstatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
    /**
     * Filter, which formstatus to fetch.
     */
    where: formstatusWhereUniqueInput
  }

  /**
   * formstatus findFirst
   */
  export type formstatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
    /**
     * Filter, which formstatus to fetch.
     */
    where?: formstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formstatuses to fetch.
     */
    orderBy?: formstatusOrderByWithRelationInput | formstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formstatuses.
     */
    cursor?: formstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formstatuses.
     */
    distinct?: FormstatusScalarFieldEnum | FormstatusScalarFieldEnum[]
  }

  /**
   * formstatus findFirstOrThrow
   */
  export type formstatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
    /**
     * Filter, which formstatus to fetch.
     */
    where?: formstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formstatuses to fetch.
     */
    orderBy?: formstatusOrderByWithRelationInput | formstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formstatuses.
     */
    cursor?: formstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formstatuses.
     */
    distinct?: FormstatusScalarFieldEnum | FormstatusScalarFieldEnum[]
  }

  /**
   * formstatus findMany
   */
  export type formstatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
    /**
     * Filter, which formstatuses to fetch.
     */
    where?: formstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formstatuses to fetch.
     */
    orderBy?: formstatusOrderByWithRelationInput | formstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formstatuses.
     */
    cursor?: formstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formstatuses.
     */
    skip?: number
    distinct?: FormstatusScalarFieldEnum | FormstatusScalarFieldEnum[]
  }

  /**
   * formstatus create
   */
  export type formstatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
    /**
     * The data needed to create a formstatus.
     */
    data?: XOR<formstatusCreateInput, formstatusUncheckedCreateInput>
  }

  /**
   * formstatus createMany
   */
  export type formstatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many formstatuses.
     */
    data: formstatusCreateManyInput | formstatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * formstatus update
   */
  export type formstatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
    /**
     * The data needed to update a formstatus.
     */
    data: XOR<formstatusUpdateInput, formstatusUncheckedUpdateInput>
    /**
     * Choose, which formstatus to update.
     */
    where: formstatusWhereUniqueInput
  }

  /**
   * formstatus updateMany
   */
  export type formstatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update formstatuses.
     */
    data: XOR<formstatusUpdateManyMutationInput, formstatusUncheckedUpdateManyInput>
    /**
     * Filter which formstatuses to update
     */
    where?: formstatusWhereInput
    /**
     * Limit how many formstatuses to update.
     */
    limit?: number
  }

  /**
   * formstatus upsert
   */
  export type formstatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
    /**
     * The filter to search for the formstatus to update in case it exists.
     */
    where: formstatusWhereUniqueInput
    /**
     * In case the formstatus found by the `where` argument doesn't exist, create a new formstatus with this data.
     */
    create: XOR<formstatusCreateInput, formstatusUncheckedCreateInput>
    /**
     * In case the formstatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<formstatusUpdateInput, formstatusUncheckedUpdateInput>
  }

  /**
   * formstatus delete
   */
  export type formstatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
    /**
     * Filter which formstatus to delete.
     */
    where: formstatusWhereUniqueInput
  }

  /**
   * formstatus deleteMany
   */
  export type formstatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formstatuses to delete
     */
    where?: formstatusWhereInput
    /**
     * Limit how many formstatuses to delete.
     */
    limit?: number
  }

  /**
   * formstatus.transactions
   */
  export type formstatus$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
  }

  /**
   * formstatus.transactionstatus
   */
  export type formstatus$transactionstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionstatus
     */
    select?: transactionstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionstatus
     */
    omit?: transactionstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionstatusInclude<ExtArgs> | null
    where?: transactionstatusWhereInput
  }

  /**
   * formstatus without action
   */
  export type formstatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
  }


  /**
   * Model formvisibilitystatus
   */

  export type AggregateFormvisibilitystatus = {
    _count: FormvisibilitystatusCountAggregateOutputType | null
    _avg: FormvisibilitystatusAvgAggregateOutputType | null
    _sum: FormvisibilitystatusSumAggregateOutputType | null
    _min: FormvisibilitystatusMinAggregateOutputType | null
    _max: FormvisibilitystatusMaxAggregateOutputType | null
  }

  export type FormvisibilitystatusAvgAggregateOutputType = {
    VisibilityStatusId: number | null
    AgentId: number | null
  }

  export type FormvisibilitystatusSumAggregateOutputType = {
    VisibilityStatusId: number | null
    AgentId: number | null
  }

  export type FormvisibilitystatusMinAggregateOutputType = {
    VisibilityStatusId: number | null
    AgentId: number | null
    IsFormOpen: boolean | null
    FormTimeStamp: Date | null
  }

  export type FormvisibilitystatusMaxAggregateOutputType = {
    VisibilityStatusId: number | null
    AgentId: number | null
    IsFormOpen: boolean | null
    FormTimeStamp: Date | null
  }

  export type FormvisibilitystatusCountAggregateOutputType = {
    VisibilityStatusId: number
    AgentId: number
    IsFormOpen: number
    FormTimeStamp: number
    _all: number
  }


  export type FormvisibilitystatusAvgAggregateInputType = {
    VisibilityStatusId?: true
    AgentId?: true
  }

  export type FormvisibilitystatusSumAggregateInputType = {
    VisibilityStatusId?: true
    AgentId?: true
  }

  export type FormvisibilitystatusMinAggregateInputType = {
    VisibilityStatusId?: true
    AgentId?: true
    IsFormOpen?: true
    FormTimeStamp?: true
  }

  export type FormvisibilitystatusMaxAggregateInputType = {
    VisibilityStatusId?: true
    AgentId?: true
    IsFormOpen?: true
    FormTimeStamp?: true
  }

  export type FormvisibilitystatusCountAggregateInputType = {
    VisibilityStatusId?: true
    AgentId?: true
    IsFormOpen?: true
    FormTimeStamp?: true
    _all?: true
  }

  export type FormvisibilitystatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formvisibilitystatus to aggregate.
     */
    where?: formvisibilitystatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formvisibilitystatuses to fetch.
     */
    orderBy?: formvisibilitystatusOrderByWithRelationInput | formvisibilitystatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: formvisibilitystatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formvisibilitystatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formvisibilitystatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned formvisibilitystatuses
    **/
    _count?: true | FormvisibilitystatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FormvisibilitystatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FormvisibilitystatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FormvisibilitystatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FormvisibilitystatusMaxAggregateInputType
  }

  export type GetFormvisibilitystatusAggregateType<T extends FormvisibilitystatusAggregateArgs> = {
        [P in keyof T & keyof AggregateFormvisibilitystatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFormvisibilitystatus[P]>
      : GetScalarType<T[P], AggregateFormvisibilitystatus[P]>
  }




  export type formvisibilitystatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: formvisibilitystatusWhereInput
    orderBy?: formvisibilitystatusOrderByWithAggregationInput | formvisibilitystatusOrderByWithAggregationInput[]
    by: FormvisibilitystatusScalarFieldEnum[] | FormvisibilitystatusScalarFieldEnum
    having?: formvisibilitystatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FormvisibilitystatusCountAggregateInputType | true
    _avg?: FormvisibilitystatusAvgAggregateInputType
    _sum?: FormvisibilitystatusSumAggregateInputType
    _min?: FormvisibilitystatusMinAggregateInputType
    _max?: FormvisibilitystatusMaxAggregateInputType
  }

  export type FormvisibilitystatusGroupByOutputType = {
    VisibilityStatusId: number
    AgentId: number
    IsFormOpen: boolean
    FormTimeStamp: Date
    _count: FormvisibilitystatusCountAggregateOutputType | null
    _avg: FormvisibilitystatusAvgAggregateOutputType | null
    _sum: FormvisibilitystatusSumAggregateOutputType | null
    _min: FormvisibilitystatusMinAggregateOutputType | null
    _max: FormvisibilitystatusMaxAggregateOutputType | null
  }

  type GetFormvisibilitystatusGroupByPayload<T extends formvisibilitystatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FormvisibilitystatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FormvisibilitystatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FormvisibilitystatusGroupByOutputType[P]>
            : GetScalarType<T[P], FormvisibilitystatusGroupByOutputType[P]>
        }
      >
    >


  export type formvisibilitystatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    VisibilityStatusId?: boolean
    AgentId?: boolean
    IsFormOpen?: boolean
    FormTimeStamp?: boolean
    agent?: boolean | agentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["formvisibilitystatus"]>



  export type formvisibilitystatusSelectScalar = {
    VisibilityStatusId?: boolean
    AgentId?: boolean
    IsFormOpen?: boolean
    FormTimeStamp?: boolean
  }

  export type formvisibilitystatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"VisibilityStatusId" | "AgentId" | "IsFormOpen" | "FormTimeStamp", ExtArgs["result"]["formvisibilitystatus"]>
  export type formvisibilitystatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | agentDefaultArgs<ExtArgs>
  }

  export type $formvisibilitystatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "formvisibilitystatus"
    objects: {
      agent: Prisma.$agentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      VisibilityStatusId: number
      AgentId: number
      IsFormOpen: boolean
      FormTimeStamp: Date
    }, ExtArgs["result"]["formvisibilitystatus"]>
    composites: {}
  }

  type formvisibilitystatusGetPayload<S extends boolean | null | undefined | formvisibilitystatusDefaultArgs> = $Result.GetResult<Prisma.$formvisibilitystatusPayload, S>

  type formvisibilitystatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<formvisibilitystatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FormvisibilitystatusCountAggregateInputType | true
    }

  export interface formvisibilitystatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['formvisibilitystatus'], meta: { name: 'formvisibilitystatus' } }
    /**
     * Find zero or one Formvisibilitystatus that matches the filter.
     * @param {formvisibilitystatusFindUniqueArgs} args - Arguments to find a Formvisibilitystatus
     * @example
     * // Get one Formvisibilitystatus
     * const formvisibilitystatus = await prisma.formvisibilitystatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends formvisibilitystatusFindUniqueArgs>(args: SelectSubset<T, formvisibilitystatusFindUniqueArgs<ExtArgs>>): Prisma__formvisibilitystatusClient<$Result.GetResult<Prisma.$formvisibilitystatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Formvisibilitystatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {formvisibilitystatusFindUniqueOrThrowArgs} args - Arguments to find a Formvisibilitystatus
     * @example
     * // Get one Formvisibilitystatus
     * const formvisibilitystatus = await prisma.formvisibilitystatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends formvisibilitystatusFindUniqueOrThrowArgs>(args: SelectSubset<T, formvisibilitystatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__formvisibilitystatusClient<$Result.GetResult<Prisma.$formvisibilitystatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Formvisibilitystatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formvisibilitystatusFindFirstArgs} args - Arguments to find a Formvisibilitystatus
     * @example
     * // Get one Formvisibilitystatus
     * const formvisibilitystatus = await prisma.formvisibilitystatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends formvisibilitystatusFindFirstArgs>(args?: SelectSubset<T, formvisibilitystatusFindFirstArgs<ExtArgs>>): Prisma__formvisibilitystatusClient<$Result.GetResult<Prisma.$formvisibilitystatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Formvisibilitystatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formvisibilitystatusFindFirstOrThrowArgs} args - Arguments to find a Formvisibilitystatus
     * @example
     * // Get one Formvisibilitystatus
     * const formvisibilitystatus = await prisma.formvisibilitystatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends formvisibilitystatusFindFirstOrThrowArgs>(args?: SelectSubset<T, formvisibilitystatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__formvisibilitystatusClient<$Result.GetResult<Prisma.$formvisibilitystatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Formvisibilitystatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formvisibilitystatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Formvisibilitystatuses
     * const formvisibilitystatuses = await prisma.formvisibilitystatus.findMany()
     * 
     * // Get first 10 Formvisibilitystatuses
     * const formvisibilitystatuses = await prisma.formvisibilitystatus.findMany({ take: 10 })
     * 
     * // Only select the `VisibilityStatusId`
     * const formvisibilitystatusWithVisibilityStatusIdOnly = await prisma.formvisibilitystatus.findMany({ select: { VisibilityStatusId: true } })
     * 
     */
    findMany<T extends formvisibilitystatusFindManyArgs>(args?: SelectSubset<T, formvisibilitystatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formvisibilitystatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Formvisibilitystatus.
     * @param {formvisibilitystatusCreateArgs} args - Arguments to create a Formvisibilitystatus.
     * @example
     * // Create one Formvisibilitystatus
     * const Formvisibilitystatus = await prisma.formvisibilitystatus.create({
     *   data: {
     *     // ... data to create a Formvisibilitystatus
     *   }
     * })
     * 
     */
    create<T extends formvisibilitystatusCreateArgs>(args: SelectSubset<T, formvisibilitystatusCreateArgs<ExtArgs>>): Prisma__formvisibilitystatusClient<$Result.GetResult<Prisma.$formvisibilitystatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Formvisibilitystatuses.
     * @param {formvisibilitystatusCreateManyArgs} args - Arguments to create many Formvisibilitystatuses.
     * @example
     * // Create many Formvisibilitystatuses
     * const formvisibilitystatus = await prisma.formvisibilitystatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends formvisibilitystatusCreateManyArgs>(args?: SelectSubset<T, formvisibilitystatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Formvisibilitystatus.
     * @param {formvisibilitystatusDeleteArgs} args - Arguments to delete one Formvisibilitystatus.
     * @example
     * // Delete one Formvisibilitystatus
     * const Formvisibilitystatus = await prisma.formvisibilitystatus.delete({
     *   where: {
     *     // ... filter to delete one Formvisibilitystatus
     *   }
     * })
     * 
     */
    delete<T extends formvisibilitystatusDeleteArgs>(args: SelectSubset<T, formvisibilitystatusDeleteArgs<ExtArgs>>): Prisma__formvisibilitystatusClient<$Result.GetResult<Prisma.$formvisibilitystatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Formvisibilitystatus.
     * @param {formvisibilitystatusUpdateArgs} args - Arguments to update one Formvisibilitystatus.
     * @example
     * // Update one Formvisibilitystatus
     * const formvisibilitystatus = await prisma.formvisibilitystatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends formvisibilitystatusUpdateArgs>(args: SelectSubset<T, formvisibilitystatusUpdateArgs<ExtArgs>>): Prisma__formvisibilitystatusClient<$Result.GetResult<Prisma.$formvisibilitystatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Formvisibilitystatuses.
     * @param {formvisibilitystatusDeleteManyArgs} args - Arguments to filter Formvisibilitystatuses to delete.
     * @example
     * // Delete a few Formvisibilitystatuses
     * const { count } = await prisma.formvisibilitystatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends formvisibilitystatusDeleteManyArgs>(args?: SelectSubset<T, formvisibilitystatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Formvisibilitystatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formvisibilitystatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Formvisibilitystatuses
     * const formvisibilitystatus = await prisma.formvisibilitystatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends formvisibilitystatusUpdateManyArgs>(args: SelectSubset<T, formvisibilitystatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Formvisibilitystatus.
     * @param {formvisibilitystatusUpsertArgs} args - Arguments to update or create a Formvisibilitystatus.
     * @example
     * // Update or create a Formvisibilitystatus
     * const formvisibilitystatus = await prisma.formvisibilitystatus.upsert({
     *   create: {
     *     // ... data to create a Formvisibilitystatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Formvisibilitystatus we want to update
     *   }
     * })
     */
    upsert<T extends formvisibilitystatusUpsertArgs>(args: SelectSubset<T, formvisibilitystatusUpsertArgs<ExtArgs>>): Prisma__formvisibilitystatusClient<$Result.GetResult<Prisma.$formvisibilitystatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Formvisibilitystatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formvisibilitystatusCountArgs} args - Arguments to filter Formvisibilitystatuses to count.
     * @example
     * // Count the number of Formvisibilitystatuses
     * const count = await prisma.formvisibilitystatus.count({
     *   where: {
     *     // ... the filter for the Formvisibilitystatuses we want to count
     *   }
     * })
    **/
    count<T extends formvisibilitystatusCountArgs>(
      args?: Subset<T, formvisibilitystatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FormvisibilitystatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Formvisibilitystatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FormvisibilitystatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FormvisibilitystatusAggregateArgs>(args: Subset<T, FormvisibilitystatusAggregateArgs>): Prisma.PrismaPromise<GetFormvisibilitystatusAggregateType<T>>

    /**
     * Group by Formvisibilitystatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {formvisibilitystatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends formvisibilitystatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: formvisibilitystatusGroupByArgs['orderBy'] }
        : { orderBy?: formvisibilitystatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, formvisibilitystatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFormvisibilitystatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the formvisibilitystatus model
   */
  readonly fields: formvisibilitystatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for formvisibilitystatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__formvisibilitystatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends agentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, agentDefaultArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the formvisibilitystatus model
   */
  interface formvisibilitystatusFieldRefs {
    readonly VisibilityStatusId: FieldRef<"formvisibilitystatus", 'Int'>
    readonly AgentId: FieldRef<"formvisibilitystatus", 'Int'>
    readonly IsFormOpen: FieldRef<"formvisibilitystatus", 'Boolean'>
    readonly FormTimeStamp: FieldRef<"formvisibilitystatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * formvisibilitystatus findUnique
   */
  export type formvisibilitystatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formvisibilitystatus
     */
    select?: formvisibilitystatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formvisibilitystatus
     */
    omit?: formvisibilitystatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formvisibilitystatusInclude<ExtArgs> | null
    /**
     * Filter, which formvisibilitystatus to fetch.
     */
    where: formvisibilitystatusWhereUniqueInput
  }

  /**
   * formvisibilitystatus findUniqueOrThrow
   */
  export type formvisibilitystatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formvisibilitystatus
     */
    select?: formvisibilitystatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formvisibilitystatus
     */
    omit?: formvisibilitystatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formvisibilitystatusInclude<ExtArgs> | null
    /**
     * Filter, which formvisibilitystatus to fetch.
     */
    where: formvisibilitystatusWhereUniqueInput
  }

  /**
   * formvisibilitystatus findFirst
   */
  export type formvisibilitystatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formvisibilitystatus
     */
    select?: formvisibilitystatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formvisibilitystatus
     */
    omit?: formvisibilitystatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formvisibilitystatusInclude<ExtArgs> | null
    /**
     * Filter, which formvisibilitystatus to fetch.
     */
    where?: formvisibilitystatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formvisibilitystatuses to fetch.
     */
    orderBy?: formvisibilitystatusOrderByWithRelationInput | formvisibilitystatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formvisibilitystatuses.
     */
    cursor?: formvisibilitystatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formvisibilitystatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formvisibilitystatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formvisibilitystatuses.
     */
    distinct?: FormvisibilitystatusScalarFieldEnum | FormvisibilitystatusScalarFieldEnum[]
  }

  /**
   * formvisibilitystatus findFirstOrThrow
   */
  export type formvisibilitystatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formvisibilitystatus
     */
    select?: formvisibilitystatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formvisibilitystatus
     */
    omit?: formvisibilitystatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formvisibilitystatusInclude<ExtArgs> | null
    /**
     * Filter, which formvisibilitystatus to fetch.
     */
    where?: formvisibilitystatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formvisibilitystatuses to fetch.
     */
    orderBy?: formvisibilitystatusOrderByWithRelationInput | formvisibilitystatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for formvisibilitystatuses.
     */
    cursor?: formvisibilitystatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formvisibilitystatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formvisibilitystatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of formvisibilitystatuses.
     */
    distinct?: FormvisibilitystatusScalarFieldEnum | FormvisibilitystatusScalarFieldEnum[]
  }

  /**
   * formvisibilitystatus findMany
   */
  export type formvisibilitystatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formvisibilitystatus
     */
    select?: formvisibilitystatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formvisibilitystatus
     */
    omit?: formvisibilitystatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formvisibilitystatusInclude<ExtArgs> | null
    /**
     * Filter, which formvisibilitystatuses to fetch.
     */
    where?: formvisibilitystatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of formvisibilitystatuses to fetch.
     */
    orderBy?: formvisibilitystatusOrderByWithRelationInput | formvisibilitystatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing formvisibilitystatuses.
     */
    cursor?: formvisibilitystatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` formvisibilitystatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` formvisibilitystatuses.
     */
    skip?: number
    distinct?: FormvisibilitystatusScalarFieldEnum | FormvisibilitystatusScalarFieldEnum[]
  }

  /**
   * formvisibilitystatus create
   */
  export type formvisibilitystatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formvisibilitystatus
     */
    select?: formvisibilitystatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formvisibilitystatus
     */
    omit?: formvisibilitystatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formvisibilitystatusInclude<ExtArgs> | null
    /**
     * The data needed to create a formvisibilitystatus.
     */
    data: XOR<formvisibilitystatusCreateInput, formvisibilitystatusUncheckedCreateInput>
  }

  /**
   * formvisibilitystatus createMany
   */
  export type formvisibilitystatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many formvisibilitystatuses.
     */
    data: formvisibilitystatusCreateManyInput | formvisibilitystatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * formvisibilitystatus update
   */
  export type formvisibilitystatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formvisibilitystatus
     */
    select?: formvisibilitystatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formvisibilitystatus
     */
    omit?: formvisibilitystatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formvisibilitystatusInclude<ExtArgs> | null
    /**
     * The data needed to update a formvisibilitystatus.
     */
    data: XOR<formvisibilitystatusUpdateInput, formvisibilitystatusUncheckedUpdateInput>
    /**
     * Choose, which formvisibilitystatus to update.
     */
    where: formvisibilitystatusWhereUniqueInput
  }

  /**
   * formvisibilitystatus updateMany
   */
  export type formvisibilitystatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update formvisibilitystatuses.
     */
    data: XOR<formvisibilitystatusUpdateManyMutationInput, formvisibilitystatusUncheckedUpdateManyInput>
    /**
     * Filter which formvisibilitystatuses to update
     */
    where?: formvisibilitystatusWhereInput
    /**
     * Limit how many formvisibilitystatuses to update.
     */
    limit?: number
  }

  /**
   * formvisibilitystatus upsert
   */
  export type formvisibilitystatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formvisibilitystatus
     */
    select?: formvisibilitystatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formvisibilitystatus
     */
    omit?: formvisibilitystatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formvisibilitystatusInclude<ExtArgs> | null
    /**
     * The filter to search for the formvisibilitystatus to update in case it exists.
     */
    where: formvisibilitystatusWhereUniqueInput
    /**
     * In case the formvisibilitystatus found by the `where` argument doesn't exist, create a new formvisibilitystatus with this data.
     */
    create: XOR<formvisibilitystatusCreateInput, formvisibilitystatusUncheckedCreateInput>
    /**
     * In case the formvisibilitystatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<formvisibilitystatusUpdateInput, formvisibilitystatusUncheckedUpdateInput>
  }

  /**
   * formvisibilitystatus delete
   */
  export type formvisibilitystatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formvisibilitystatus
     */
    select?: formvisibilitystatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formvisibilitystatus
     */
    omit?: formvisibilitystatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formvisibilitystatusInclude<ExtArgs> | null
    /**
     * Filter which formvisibilitystatus to delete.
     */
    where: formvisibilitystatusWhereUniqueInput
  }

  /**
   * formvisibilitystatus deleteMany
   */
  export type formvisibilitystatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which formvisibilitystatuses to delete
     */
    where?: formvisibilitystatusWhereInput
    /**
     * Limit how many formvisibilitystatuses to delete.
     */
    limit?: number
  }

  /**
   * formvisibilitystatus without action
   */
  export type formvisibilitystatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formvisibilitystatus
     */
    select?: formvisibilitystatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formvisibilitystatus
     */
    omit?: formvisibilitystatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formvisibilitystatusInclude<ExtArgs> | null
  }


  /**
   * Model fundraiser
   */

  export type AggregateFundraiser = {
    _count: FundraiserCountAggregateOutputType | null
    _avg: FundraiserAvgAggregateOutputType | null
    _sum: FundraiserSumAggregateOutputType | null
    _min: FundraiserMinAggregateOutputType | null
    _max: FundraiserMaxAggregateOutputType | null
  }

  export type FundraiserAvgAggregateOutputType = {
    FundraiserID: number | null
    BaseCountryID: number | null
    FundraiserCentralID: number | null
  }

  export type FundraiserSumAggregateOutputType = {
    FundraiserID: number | null
    BaseCountryID: number | null
    FundraiserCentralID: number | null
  }

  export type FundraiserMinAggregateOutputType = {
    FundraiserID: number | null
    FundraiserName: string | null
    FundraiserEmail: string | null
    FundraiserLogo: string | null
    BaseCountryID: number | null
    FundraiserCentralID: number | null
  }

  export type FundraiserMaxAggregateOutputType = {
    FundraiserID: number | null
    FundraiserName: string | null
    FundraiserEmail: string | null
    FundraiserLogo: string | null
    BaseCountryID: number | null
    FundraiserCentralID: number | null
  }

  export type FundraiserCountAggregateOutputType = {
    FundraiserID: number
    FundraiserName: number
    FundraiserEmail: number
    FundraiserLogo: number
    BaseCountryID: number
    FundraiserCentralID: number
    _all: number
  }


  export type FundraiserAvgAggregateInputType = {
    FundraiserID?: true
    BaseCountryID?: true
    FundraiserCentralID?: true
  }

  export type FundraiserSumAggregateInputType = {
    FundraiserID?: true
    BaseCountryID?: true
    FundraiserCentralID?: true
  }

  export type FundraiserMinAggregateInputType = {
    FundraiserID?: true
    FundraiserName?: true
    FundraiserEmail?: true
    FundraiserLogo?: true
    BaseCountryID?: true
    FundraiserCentralID?: true
  }

  export type FundraiserMaxAggregateInputType = {
    FundraiserID?: true
    FundraiserName?: true
    FundraiserEmail?: true
    FundraiserLogo?: true
    BaseCountryID?: true
    FundraiserCentralID?: true
  }

  export type FundraiserCountAggregateInputType = {
    FundraiserID?: true
    FundraiserName?: true
    FundraiserEmail?: true
    FundraiserLogo?: true
    BaseCountryID?: true
    FundraiserCentralID?: true
    _all?: true
  }

  export type FundraiserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fundraiser to aggregate.
     */
    where?: fundraiserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraisers to fetch.
     */
    orderBy?: fundraiserOrderByWithRelationInput | fundraiserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fundraiserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraisers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraisers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fundraisers
    **/
    _count?: true | FundraiserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FundraiserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FundraiserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FundraiserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FundraiserMaxAggregateInputType
  }

  export type GetFundraiserAggregateType<T extends FundraiserAggregateArgs> = {
        [P in keyof T & keyof AggregateFundraiser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFundraiser[P]>
      : GetScalarType<T[P], AggregateFundraiser[P]>
  }




  export type fundraiserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fundraiserWhereInput
    orderBy?: fundraiserOrderByWithAggregationInput | fundraiserOrderByWithAggregationInput[]
    by: FundraiserScalarFieldEnum[] | FundraiserScalarFieldEnum
    having?: fundraiserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FundraiserCountAggregateInputType | true
    _avg?: FundraiserAvgAggregateInputType
    _sum?: FundraiserSumAggregateInputType
    _min?: FundraiserMinAggregateInputType
    _max?: FundraiserMaxAggregateInputType
  }

  export type FundraiserGroupByOutputType = {
    FundraiserID: number
    FundraiserName: string
    FundraiserEmail: string
    FundraiserLogo: string | null
    BaseCountryID: number | null
    FundraiserCentralID: number | null
    _count: FundraiserCountAggregateOutputType | null
    _avg: FundraiserAvgAggregateOutputType | null
    _sum: FundraiserSumAggregateOutputType | null
    _min: FundraiserMinAggregateOutputType | null
    _max: FundraiserMaxAggregateOutputType | null
  }

  type GetFundraiserGroupByPayload<T extends fundraiserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FundraiserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FundraiserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FundraiserGroupByOutputType[P]>
            : GetScalarType<T[P], FundraiserGroupByOutputType[P]>
        }
      >
    >


  export type fundraiserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FundraiserID?: boolean
    FundraiserName?: boolean
    FundraiserEmail?: boolean
    FundraiserLogo?: boolean
    BaseCountryID?: boolean
    FundraiserCentralID?: boolean
    basecountry?: boolean | fundraiser$basecountryArgs<ExtArgs>
    fundraiser_acceptedcurrencies?: boolean | fundraiser$fundraiser_acceptedcurrenciesArgs<ExtArgs>
    fundraiser_contactlinks?: boolean | fundraiser$fundraiser_contactlinksArgs<ExtArgs>
    _count?: boolean | FundraiserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fundraiser"]>



  export type fundraiserSelectScalar = {
    FundraiserID?: boolean
    FundraiserName?: boolean
    FundraiserEmail?: boolean
    FundraiserLogo?: boolean
    BaseCountryID?: boolean
    FundraiserCentralID?: boolean
  }

  export type fundraiserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"FundraiserID" | "FundraiserName" | "FundraiserEmail" | "FundraiserLogo" | "BaseCountryID" | "FundraiserCentralID", ExtArgs["result"]["fundraiser"]>
  export type fundraiserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    basecountry?: boolean | fundraiser$basecountryArgs<ExtArgs>
    fundraiser_acceptedcurrencies?: boolean | fundraiser$fundraiser_acceptedcurrenciesArgs<ExtArgs>
    fundraiser_contactlinks?: boolean | fundraiser$fundraiser_contactlinksArgs<ExtArgs>
    _count?: boolean | FundraiserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $fundraiserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fundraiser"
    objects: {
      basecountry: Prisma.$basecountryPayload<ExtArgs> | null
      fundraiser_acceptedcurrencies: Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>[]
      fundraiser_contactlinks: Prisma.$fundraiser_contactlinksPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      FundraiserID: number
      FundraiserName: string
      FundraiserEmail: string
      FundraiserLogo: string | null
      BaseCountryID: number | null
      FundraiserCentralID: number | null
    }, ExtArgs["result"]["fundraiser"]>
    composites: {}
  }

  type fundraiserGetPayload<S extends boolean | null | undefined | fundraiserDefaultArgs> = $Result.GetResult<Prisma.$fundraiserPayload, S>

  type fundraiserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<fundraiserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FundraiserCountAggregateInputType | true
    }

  export interface fundraiserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fundraiser'], meta: { name: 'fundraiser' } }
    /**
     * Find zero or one Fundraiser that matches the filter.
     * @param {fundraiserFindUniqueArgs} args - Arguments to find a Fundraiser
     * @example
     * // Get one Fundraiser
     * const fundraiser = await prisma.fundraiser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fundraiserFindUniqueArgs>(args: SelectSubset<T, fundraiserFindUniqueArgs<ExtArgs>>): Prisma__fundraiserClient<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fundraiser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fundraiserFindUniqueOrThrowArgs} args - Arguments to find a Fundraiser
     * @example
     * // Get one Fundraiser
     * const fundraiser = await prisma.fundraiser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fundraiserFindUniqueOrThrowArgs>(args: SelectSubset<T, fundraiserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__fundraiserClient<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fundraiser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiserFindFirstArgs} args - Arguments to find a Fundraiser
     * @example
     * // Get one Fundraiser
     * const fundraiser = await prisma.fundraiser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fundraiserFindFirstArgs>(args?: SelectSubset<T, fundraiserFindFirstArgs<ExtArgs>>): Prisma__fundraiserClient<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fundraiser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiserFindFirstOrThrowArgs} args - Arguments to find a Fundraiser
     * @example
     * // Get one Fundraiser
     * const fundraiser = await prisma.fundraiser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fundraiserFindFirstOrThrowArgs>(args?: SelectSubset<T, fundraiserFindFirstOrThrowArgs<ExtArgs>>): Prisma__fundraiserClient<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fundraisers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fundraisers
     * const fundraisers = await prisma.fundraiser.findMany()
     * 
     * // Get first 10 Fundraisers
     * const fundraisers = await prisma.fundraiser.findMany({ take: 10 })
     * 
     * // Only select the `FundraiserID`
     * const fundraiserWithFundraiserIDOnly = await prisma.fundraiser.findMany({ select: { FundraiserID: true } })
     * 
     */
    findMany<T extends fundraiserFindManyArgs>(args?: SelectSubset<T, fundraiserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fundraiser.
     * @param {fundraiserCreateArgs} args - Arguments to create a Fundraiser.
     * @example
     * // Create one Fundraiser
     * const Fundraiser = await prisma.fundraiser.create({
     *   data: {
     *     // ... data to create a Fundraiser
     *   }
     * })
     * 
     */
    create<T extends fundraiserCreateArgs>(args: SelectSubset<T, fundraiserCreateArgs<ExtArgs>>): Prisma__fundraiserClient<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fundraisers.
     * @param {fundraiserCreateManyArgs} args - Arguments to create many Fundraisers.
     * @example
     * // Create many Fundraisers
     * const fundraiser = await prisma.fundraiser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fundraiserCreateManyArgs>(args?: SelectSubset<T, fundraiserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fundraiser.
     * @param {fundraiserDeleteArgs} args - Arguments to delete one Fundraiser.
     * @example
     * // Delete one Fundraiser
     * const Fundraiser = await prisma.fundraiser.delete({
     *   where: {
     *     // ... filter to delete one Fundraiser
     *   }
     * })
     * 
     */
    delete<T extends fundraiserDeleteArgs>(args: SelectSubset<T, fundraiserDeleteArgs<ExtArgs>>): Prisma__fundraiserClient<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fundraiser.
     * @param {fundraiserUpdateArgs} args - Arguments to update one Fundraiser.
     * @example
     * // Update one Fundraiser
     * const fundraiser = await prisma.fundraiser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fundraiserUpdateArgs>(args: SelectSubset<T, fundraiserUpdateArgs<ExtArgs>>): Prisma__fundraiserClient<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fundraisers.
     * @param {fundraiserDeleteManyArgs} args - Arguments to filter Fundraisers to delete.
     * @example
     * // Delete a few Fundraisers
     * const { count } = await prisma.fundraiser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fundraiserDeleteManyArgs>(args?: SelectSubset<T, fundraiserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fundraisers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fundraisers
     * const fundraiser = await prisma.fundraiser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fundraiserUpdateManyArgs>(args: SelectSubset<T, fundraiserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fundraiser.
     * @param {fundraiserUpsertArgs} args - Arguments to update or create a Fundraiser.
     * @example
     * // Update or create a Fundraiser
     * const fundraiser = await prisma.fundraiser.upsert({
     *   create: {
     *     // ... data to create a Fundraiser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fundraiser we want to update
     *   }
     * })
     */
    upsert<T extends fundraiserUpsertArgs>(args: SelectSubset<T, fundraiserUpsertArgs<ExtArgs>>): Prisma__fundraiserClient<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fundraisers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiserCountArgs} args - Arguments to filter Fundraisers to count.
     * @example
     * // Count the number of Fundraisers
     * const count = await prisma.fundraiser.count({
     *   where: {
     *     // ... the filter for the Fundraisers we want to count
     *   }
     * })
    **/
    count<T extends fundraiserCountArgs>(
      args?: Subset<T, fundraiserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FundraiserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fundraiser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FundraiserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FundraiserAggregateArgs>(args: Subset<T, FundraiserAggregateArgs>): Prisma.PrismaPromise<GetFundraiserAggregateType<T>>

    /**
     * Group by Fundraiser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fundraiserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fundraiserGroupByArgs['orderBy'] }
        : { orderBy?: fundraiserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fundraiserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFundraiserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fundraiser model
   */
  readonly fields: fundraiserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fundraiser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fundraiserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    basecountry<T extends fundraiser$basecountryArgs<ExtArgs> = {}>(args?: Subset<T, fundraiser$basecountryArgs<ExtArgs>>): Prisma__basecountryClient<$Result.GetResult<Prisma.$basecountryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fundraiser_acceptedcurrencies<T extends fundraiser$fundraiser_acceptedcurrenciesArgs<ExtArgs> = {}>(args?: Subset<T, fundraiser$fundraiser_acceptedcurrenciesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fundraiser_contactlinks<T extends fundraiser$fundraiser_contactlinksArgs<ExtArgs> = {}>(args?: Subset<T, fundraiser$fundraiser_contactlinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fundraiser_contactlinksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fundraiser model
   */
  interface fundraiserFieldRefs {
    readonly FundraiserID: FieldRef<"fundraiser", 'Int'>
    readonly FundraiserName: FieldRef<"fundraiser", 'String'>
    readonly FundraiserEmail: FieldRef<"fundraiser", 'String'>
    readonly FundraiserLogo: FieldRef<"fundraiser", 'String'>
    readonly BaseCountryID: FieldRef<"fundraiser", 'Int'>
    readonly FundraiserCentralID: FieldRef<"fundraiser", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * fundraiser findUnique
   */
  export type fundraiserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser to fetch.
     */
    where: fundraiserWhereUniqueInput
  }

  /**
   * fundraiser findUniqueOrThrow
   */
  export type fundraiserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser to fetch.
     */
    where: fundraiserWhereUniqueInput
  }

  /**
   * fundraiser findFirst
   */
  export type fundraiserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser to fetch.
     */
    where?: fundraiserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraisers to fetch.
     */
    orderBy?: fundraiserOrderByWithRelationInput | fundraiserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fundraisers.
     */
    cursor?: fundraiserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraisers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraisers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fundraisers.
     */
    distinct?: FundraiserScalarFieldEnum | FundraiserScalarFieldEnum[]
  }

  /**
   * fundraiser findFirstOrThrow
   */
  export type fundraiserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser to fetch.
     */
    where?: fundraiserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraisers to fetch.
     */
    orderBy?: fundraiserOrderByWithRelationInput | fundraiserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fundraisers.
     */
    cursor?: fundraiserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraisers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraisers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fundraisers.
     */
    distinct?: FundraiserScalarFieldEnum | FundraiserScalarFieldEnum[]
  }

  /**
   * fundraiser findMany
   */
  export type fundraiserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    /**
     * Filter, which fundraisers to fetch.
     */
    where?: fundraiserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraisers to fetch.
     */
    orderBy?: fundraiserOrderByWithRelationInput | fundraiserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fundraisers.
     */
    cursor?: fundraiserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraisers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraisers.
     */
    skip?: number
    distinct?: FundraiserScalarFieldEnum | FundraiserScalarFieldEnum[]
  }

  /**
   * fundraiser create
   */
  export type fundraiserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    /**
     * The data needed to create a fundraiser.
     */
    data: XOR<fundraiserCreateInput, fundraiserUncheckedCreateInput>
  }

  /**
   * fundraiser createMany
   */
  export type fundraiserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fundraisers.
     */
    data: fundraiserCreateManyInput | fundraiserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * fundraiser update
   */
  export type fundraiserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    /**
     * The data needed to update a fundraiser.
     */
    data: XOR<fundraiserUpdateInput, fundraiserUncheckedUpdateInput>
    /**
     * Choose, which fundraiser to update.
     */
    where: fundraiserWhereUniqueInput
  }

  /**
   * fundraiser updateMany
   */
  export type fundraiserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fundraisers.
     */
    data: XOR<fundraiserUpdateManyMutationInput, fundraiserUncheckedUpdateManyInput>
    /**
     * Filter which fundraisers to update
     */
    where?: fundraiserWhereInput
    /**
     * Limit how many fundraisers to update.
     */
    limit?: number
  }

  /**
   * fundraiser upsert
   */
  export type fundraiserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    /**
     * The filter to search for the fundraiser to update in case it exists.
     */
    where: fundraiserWhereUniqueInput
    /**
     * In case the fundraiser found by the `where` argument doesn't exist, create a new fundraiser with this data.
     */
    create: XOR<fundraiserCreateInput, fundraiserUncheckedCreateInput>
    /**
     * In case the fundraiser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fundraiserUpdateInput, fundraiserUncheckedUpdateInput>
  }

  /**
   * fundraiser delete
   */
  export type fundraiserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    /**
     * Filter which fundraiser to delete.
     */
    where: fundraiserWhereUniqueInput
  }

  /**
   * fundraiser deleteMany
   */
  export type fundraiserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fundraisers to delete
     */
    where?: fundraiserWhereInput
    /**
     * Limit how many fundraisers to delete.
     */
    limit?: number
  }

  /**
   * fundraiser.basecountry
   */
  export type fundraiser$basecountryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the basecountry
     */
    select?: basecountrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the basecountry
     */
    omit?: basecountryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: basecountryInclude<ExtArgs> | null
    where?: basecountryWhereInput
  }

  /**
   * fundraiser.fundraiser_acceptedcurrencies
   */
  export type fundraiser$fundraiser_acceptedcurrenciesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
    where?: fundraiser_acceptedcurrenciesWhereInput
    orderBy?: fundraiser_acceptedcurrenciesOrderByWithRelationInput | fundraiser_acceptedcurrenciesOrderByWithRelationInput[]
    cursor?: fundraiser_acceptedcurrenciesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Fundraiser_acceptedcurrenciesScalarFieldEnum | Fundraiser_acceptedcurrenciesScalarFieldEnum[]
  }

  /**
   * fundraiser.fundraiser_contactlinks
   */
  export type fundraiser$fundraiser_contactlinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_contactlinks
     */
    select?: fundraiser_contactlinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_contactlinks
     */
    omit?: fundraiser_contactlinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_contactlinksInclude<ExtArgs> | null
    where?: fundraiser_contactlinksWhereInput
    orderBy?: fundraiser_contactlinksOrderByWithRelationInput | fundraiser_contactlinksOrderByWithRelationInput[]
    cursor?: fundraiser_contactlinksWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Fundraiser_contactlinksScalarFieldEnum | Fundraiser_contactlinksScalarFieldEnum[]
  }

  /**
   * fundraiser without action
   */
  export type fundraiserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
  }


  /**
   * Model fundraiser_acceptedcurrencies
   */

  export type AggregateFundraiser_acceptedcurrencies = {
    _count: Fundraiser_acceptedcurrenciesCountAggregateOutputType | null
    _avg: Fundraiser_acceptedcurrenciesAvgAggregateOutputType | null
    _sum: Fundraiser_acceptedcurrenciesSumAggregateOutputType | null
    _min: Fundraiser_acceptedcurrenciesMinAggregateOutputType | null
    _max: Fundraiser_acceptedcurrenciesMaxAggregateOutputType | null
  }

  export type Fundraiser_acceptedcurrenciesAvgAggregateOutputType = {
    FundraiserAcceptedCurrencyID: number | null
    FundraiserID: number | null
    CurrencyID: number | null
  }

  export type Fundraiser_acceptedcurrenciesSumAggregateOutputType = {
    FundraiserAcceptedCurrencyID: number | null
    FundraiserID: number | null
    CurrencyID: number | null
  }

  export type Fundraiser_acceptedcurrenciesMinAggregateOutputType = {
    FundraiserAcceptedCurrencyID: number | null
    FundraiserID: number | null
    CurrencyID: number | null
  }

  export type Fundraiser_acceptedcurrenciesMaxAggregateOutputType = {
    FundraiserAcceptedCurrencyID: number | null
    FundraiserID: number | null
    CurrencyID: number | null
  }

  export type Fundraiser_acceptedcurrenciesCountAggregateOutputType = {
    FundraiserAcceptedCurrencyID: number
    FundraiserID: number
    CurrencyID: number
    _all: number
  }


  export type Fundraiser_acceptedcurrenciesAvgAggregateInputType = {
    FundraiserAcceptedCurrencyID?: true
    FundraiserID?: true
    CurrencyID?: true
  }

  export type Fundraiser_acceptedcurrenciesSumAggregateInputType = {
    FundraiserAcceptedCurrencyID?: true
    FundraiserID?: true
    CurrencyID?: true
  }

  export type Fundraiser_acceptedcurrenciesMinAggregateInputType = {
    FundraiserAcceptedCurrencyID?: true
    FundraiserID?: true
    CurrencyID?: true
  }

  export type Fundraiser_acceptedcurrenciesMaxAggregateInputType = {
    FundraiserAcceptedCurrencyID?: true
    FundraiserID?: true
    CurrencyID?: true
  }

  export type Fundraiser_acceptedcurrenciesCountAggregateInputType = {
    FundraiserAcceptedCurrencyID?: true
    FundraiserID?: true
    CurrencyID?: true
    _all?: true
  }

  export type Fundraiser_acceptedcurrenciesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fundraiser_acceptedcurrencies to aggregate.
     */
    where?: fundraiser_acceptedcurrenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraiser_acceptedcurrencies to fetch.
     */
    orderBy?: fundraiser_acceptedcurrenciesOrderByWithRelationInput | fundraiser_acceptedcurrenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fundraiser_acceptedcurrenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraiser_acceptedcurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraiser_acceptedcurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fundraiser_acceptedcurrencies
    **/
    _count?: true | Fundraiser_acceptedcurrenciesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fundraiser_acceptedcurrenciesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fundraiser_acceptedcurrenciesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fundraiser_acceptedcurrenciesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fundraiser_acceptedcurrenciesMaxAggregateInputType
  }

  export type GetFundraiser_acceptedcurrenciesAggregateType<T extends Fundraiser_acceptedcurrenciesAggregateArgs> = {
        [P in keyof T & keyof AggregateFundraiser_acceptedcurrencies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFundraiser_acceptedcurrencies[P]>
      : GetScalarType<T[P], AggregateFundraiser_acceptedcurrencies[P]>
  }




  export type fundraiser_acceptedcurrenciesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fundraiser_acceptedcurrenciesWhereInput
    orderBy?: fundraiser_acceptedcurrenciesOrderByWithAggregationInput | fundraiser_acceptedcurrenciesOrderByWithAggregationInput[]
    by: Fundraiser_acceptedcurrenciesScalarFieldEnum[] | Fundraiser_acceptedcurrenciesScalarFieldEnum
    having?: fundraiser_acceptedcurrenciesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fundraiser_acceptedcurrenciesCountAggregateInputType | true
    _avg?: Fundraiser_acceptedcurrenciesAvgAggregateInputType
    _sum?: Fundraiser_acceptedcurrenciesSumAggregateInputType
    _min?: Fundraiser_acceptedcurrenciesMinAggregateInputType
    _max?: Fundraiser_acceptedcurrenciesMaxAggregateInputType
  }

  export type Fundraiser_acceptedcurrenciesGroupByOutputType = {
    FundraiserAcceptedCurrencyID: number
    FundraiserID: number | null
    CurrencyID: number | null
    _count: Fundraiser_acceptedcurrenciesCountAggregateOutputType | null
    _avg: Fundraiser_acceptedcurrenciesAvgAggregateOutputType | null
    _sum: Fundraiser_acceptedcurrenciesSumAggregateOutputType | null
    _min: Fundraiser_acceptedcurrenciesMinAggregateOutputType | null
    _max: Fundraiser_acceptedcurrenciesMaxAggregateOutputType | null
  }

  type GetFundraiser_acceptedcurrenciesGroupByPayload<T extends fundraiser_acceptedcurrenciesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fundraiser_acceptedcurrenciesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fundraiser_acceptedcurrenciesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fundraiser_acceptedcurrenciesGroupByOutputType[P]>
            : GetScalarType<T[P], Fundraiser_acceptedcurrenciesGroupByOutputType[P]>
        }
      >
    >


  export type fundraiser_acceptedcurrenciesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    FundraiserAcceptedCurrencyID?: boolean
    FundraiserID?: boolean
    CurrencyID?: boolean
    fundraiser?: boolean | fundraiser_acceptedcurrencies$fundraiserArgs<ExtArgs>
    currency?: boolean | fundraiser_acceptedcurrencies$currencyArgs<ExtArgs>
  }, ExtArgs["result"]["fundraiser_acceptedcurrencies"]>



  export type fundraiser_acceptedcurrenciesSelectScalar = {
    FundraiserAcceptedCurrencyID?: boolean
    FundraiserID?: boolean
    CurrencyID?: boolean
  }

  export type fundraiser_acceptedcurrenciesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"FundraiserAcceptedCurrencyID" | "FundraiserID" | "CurrencyID", ExtArgs["result"]["fundraiser_acceptedcurrencies"]>
  export type fundraiser_acceptedcurrenciesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fundraiser?: boolean | fundraiser_acceptedcurrencies$fundraiserArgs<ExtArgs>
    currency?: boolean | fundraiser_acceptedcurrencies$currencyArgs<ExtArgs>
  }

  export type $fundraiser_acceptedcurrenciesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fundraiser_acceptedcurrencies"
    objects: {
      fundraiser: Prisma.$fundraiserPayload<ExtArgs> | null
      currency: Prisma.$currencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      FundraiserAcceptedCurrencyID: number
      FundraiserID: number | null
      CurrencyID: number | null
    }, ExtArgs["result"]["fundraiser_acceptedcurrencies"]>
    composites: {}
  }

  type fundraiser_acceptedcurrenciesGetPayload<S extends boolean | null | undefined | fundraiser_acceptedcurrenciesDefaultArgs> = $Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload, S>

  type fundraiser_acceptedcurrenciesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<fundraiser_acceptedcurrenciesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Fundraiser_acceptedcurrenciesCountAggregateInputType | true
    }

  export interface fundraiser_acceptedcurrenciesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fundraiser_acceptedcurrencies'], meta: { name: 'fundraiser_acceptedcurrencies' } }
    /**
     * Find zero or one Fundraiser_acceptedcurrencies that matches the filter.
     * @param {fundraiser_acceptedcurrenciesFindUniqueArgs} args - Arguments to find a Fundraiser_acceptedcurrencies
     * @example
     * // Get one Fundraiser_acceptedcurrencies
     * const fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fundraiser_acceptedcurrenciesFindUniqueArgs>(args: SelectSubset<T, fundraiser_acceptedcurrenciesFindUniqueArgs<ExtArgs>>): Prisma__fundraiser_acceptedcurrenciesClient<$Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fundraiser_acceptedcurrencies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fundraiser_acceptedcurrenciesFindUniqueOrThrowArgs} args - Arguments to find a Fundraiser_acceptedcurrencies
     * @example
     * // Get one Fundraiser_acceptedcurrencies
     * const fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fundraiser_acceptedcurrenciesFindUniqueOrThrowArgs>(args: SelectSubset<T, fundraiser_acceptedcurrenciesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__fundraiser_acceptedcurrenciesClient<$Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fundraiser_acceptedcurrencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_acceptedcurrenciesFindFirstArgs} args - Arguments to find a Fundraiser_acceptedcurrencies
     * @example
     * // Get one Fundraiser_acceptedcurrencies
     * const fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fundraiser_acceptedcurrenciesFindFirstArgs>(args?: SelectSubset<T, fundraiser_acceptedcurrenciesFindFirstArgs<ExtArgs>>): Prisma__fundraiser_acceptedcurrenciesClient<$Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fundraiser_acceptedcurrencies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_acceptedcurrenciesFindFirstOrThrowArgs} args - Arguments to find a Fundraiser_acceptedcurrencies
     * @example
     * // Get one Fundraiser_acceptedcurrencies
     * const fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fundraiser_acceptedcurrenciesFindFirstOrThrowArgs>(args?: SelectSubset<T, fundraiser_acceptedcurrenciesFindFirstOrThrowArgs<ExtArgs>>): Prisma__fundraiser_acceptedcurrenciesClient<$Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fundraiser_acceptedcurrencies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_acceptedcurrenciesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fundraiser_acceptedcurrencies
     * const fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.findMany()
     * 
     * // Get first 10 Fundraiser_acceptedcurrencies
     * const fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.findMany({ take: 10 })
     * 
     * // Only select the `FundraiserAcceptedCurrencyID`
     * const fundraiser_acceptedcurrenciesWithFundraiserAcceptedCurrencyIDOnly = await prisma.fundraiser_acceptedcurrencies.findMany({ select: { FundraiserAcceptedCurrencyID: true } })
     * 
     */
    findMany<T extends fundraiser_acceptedcurrenciesFindManyArgs>(args?: SelectSubset<T, fundraiser_acceptedcurrenciesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fundraiser_acceptedcurrencies.
     * @param {fundraiser_acceptedcurrenciesCreateArgs} args - Arguments to create a Fundraiser_acceptedcurrencies.
     * @example
     * // Create one Fundraiser_acceptedcurrencies
     * const Fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.create({
     *   data: {
     *     // ... data to create a Fundraiser_acceptedcurrencies
     *   }
     * })
     * 
     */
    create<T extends fundraiser_acceptedcurrenciesCreateArgs>(args: SelectSubset<T, fundraiser_acceptedcurrenciesCreateArgs<ExtArgs>>): Prisma__fundraiser_acceptedcurrenciesClient<$Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fundraiser_acceptedcurrencies.
     * @param {fundraiser_acceptedcurrenciesCreateManyArgs} args - Arguments to create many Fundraiser_acceptedcurrencies.
     * @example
     * // Create many Fundraiser_acceptedcurrencies
     * const fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fundraiser_acceptedcurrenciesCreateManyArgs>(args?: SelectSubset<T, fundraiser_acceptedcurrenciesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fundraiser_acceptedcurrencies.
     * @param {fundraiser_acceptedcurrenciesDeleteArgs} args - Arguments to delete one Fundraiser_acceptedcurrencies.
     * @example
     * // Delete one Fundraiser_acceptedcurrencies
     * const Fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.delete({
     *   where: {
     *     // ... filter to delete one Fundraiser_acceptedcurrencies
     *   }
     * })
     * 
     */
    delete<T extends fundraiser_acceptedcurrenciesDeleteArgs>(args: SelectSubset<T, fundraiser_acceptedcurrenciesDeleteArgs<ExtArgs>>): Prisma__fundraiser_acceptedcurrenciesClient<$Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fundraiser_acceptedcurrencies.
     * @param {fundraiser_acceptedcurrenciesUpdateArgs} args - Arguments to update one Fundraiser_acceptedcurrencies.
     * @example
     * // Update one Fundraiser_acceptedcurrencies
     * const fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fundraiser_acceptedcurrenciesUpdateArgs>(args: SelectSubset<T, fundraiser_acceptedcurrenciesUpdateArgs<ExtArgs>>): Prisma__fundraiser_acceptedcurrenciesClient<$Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fundraiser_acceptedcurrencies.
     * @param {fundraiser_acceptedcurrenciesDeleteManyArgs} args - Arguments to filter Fundraiser_acceptedcurrencies to delete.
     * @example
     * // Delete a few Fundraiser_acceptedcurrencies
     * const { count } = await prisma.fundraiser_acceptedcurrencies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fundraiser_acceptedcurrenciesDeleteManyArgs>(args?: SelectSubset<T, fundraiser_acceptedcurrenciesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fundraiser_acceptedcurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_acceptedcurrenciesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fundraiser_acceptedcurrencies
     * const fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fundraiser_acceptedcurrenciesUpdateManyArgs>(args: SelectSubset<T, fundraiser_acceptedcurrenciesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fundraiser_acceptedcurrencies.
     * @param {fundraiser_acceptedcurrenciesUpsertArgs} args - Arguments to update or create a Fundraiser_acceptedcurrencies.
     * @example
     * // Update or create a Fundraiser_acceptedcurrencies
     * const fundraiser_acceptedcurrencies = await prisma.fundraiser_acceptedcurrencies.upsert({
     *   create: {
     *     // ... data to create a Fundraiser_acceptedcurrencies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fundraiser_acceptedcurrencies we want to update
     *   }
     * })
     */
    upsert<T extends fundraiser_acceptedcurrenciesUpsertArgs>(args: SelectSubset<T, fundraiser_acceptedcurrenciesUpsertArgs<ExtArgs>>): Prisma__fundraiser_acceptedcurrenciesClient<$Result.GetResult<Prisma.$fundraiser_acceptedcurrenciesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fundraiser_acceptedcurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_acceptedcurrenciesCountArgs} args - Arguments to filter Fundraiser_acceptedcurrencies to count.
     * @example
     * // Count the number of Fundraiser_acceptedcurrencies
     * const count = await prisma.fundraiser_acceptedcurrencies.count({
     *   where: {
     *     // ... the filter for the Fundraiser_acceptedcurrencies we want to count
     *   }
     * })
    **/
    count<T extends fundraiser_acceptedcurrenciesCountArgs>(
      args?: Subset<T, fundraiser_acceptedcurrenciesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fundraiser_acceptedcurrenciesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fundraiser_acceptedcurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fundraiser_acceptedcurrenciesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fundraiser_acceptedcurrenciesAggregateArgs>(args: Subset<T, Fundraiser_acceptedcurrenciesAggregateArgs>): Prisma.PrismaPromise<GetFundraiser_acceptedcurrenciesAggregateType<T>>

    /**
     * Group by Fundraiser_acceptedcurrencies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_acceptedcurrenciesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fundraiser_acceptedcurrenciesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fundraiser_acceptedcurrenciesGroupByArgs['orderBy'] }
        : { orderBy?: fundraiser_acceptedcurrenciesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fundraiser_acceptedcurrenciesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFundraiser_acceptedcurrenciesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fundraiser_acceptedcurrencies model
   */
  readonly fields: fundraiser_acceptedcurrenciesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fundraiser_acceptedcurrencies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fundraiser_acceptedcurrenciesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fundraiser<T extends fundraiser_acceptedcurrencies$fundraiserArgs<ExtArgs> = {}>(args?: Subset<T, fundraiser_acceptedcurrencies$fundraiserArgs<ExtArgs>>): Prisma__fundraiserClient<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    currency<T extends fundraiser_acceptedcurrencies$currencyArgs<ExtArgs> = {}>(args?: Subset<T, fundraiser_acceptedcurrencies$currencyArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fundraiser_acceptedcurrencies model
   */
  interface fundraiser_acceptedcurrenciesFieldRefs {
    readonly FundraiserAcceptedCurrencyID: FieldRef<"fundraiser_acceptedcurrencies", 'Int'>
    readonly FundraiserID: FieldRef<"fundraiser_acceptedcurrencies", 'Int'>
    readonly CurrencyID: FieldRef<"fundraiser_acceptedcurrencies", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * fundraiser_acceptedcurrencies findUnique
   */
  export type fundraiser_acceptedcurrenciesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser_acceptedcurrencies to fetch.
     */
    where: fundraiser_acceptedcurrenciesWhereUniqueInput
  }

  /**
   * fundraiser_acceptedcurrencies findUniqueOrThrow
   */
  export type fundraiser_acceptedcurrenciesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser_acceptedcurrencies to fetch.
     */
    where: fundraiser_acceptedcurrenciesWhereUniqueInput
  }

  /**
   * fundraiser_acceptedcurrencies findFirst
   */
  export type fundraiser_acceptedcurrenciesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser_acceptedcurrencies to fetch.
     */
    where?: fundraiser_acceptedcurrenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraiser_acceptedcurrencies to fetch.
     */
    orderBy?: fundraiser_acceptedcurrenciesOrderByWithRelationInput | fundraiser_acceptedcurrenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fundraiser_acceptedcurrencies.
     */
    cursor?: fundraiser_acceptedcurrenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraiser_acceptedcurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraiser_acceptedcurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fundraiser_acceptedcurrencies.
     */
    distinct?: Fundraiser_acceptedcurrenciesScalarFieldEnum | Fundraiser_acceptedcurrenciesScalarFieldEnum[]
  }

  /**
   * fundraiser_acceptedcurrencies findFirstOrThrow
   */
  export type fundraiser_acceptedcurrenciesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser_acceptedcurrencies to fetch.
     */
    where?: fundraiser_acceptedcurrenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraiser_acceptedcurrencies to fetch.
     */
    orderBy?: fundraiser_acceptedcurrenciesOrderByWithRelationInput | fundraiser_acceptedcurrenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fundraiser_acceptedcurrencies.
     */
    cursor?: fundraiser_acceptedcurrenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraiser_acceptedcurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraiser_acceptedcurrencies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fundraiser_acceptedcurrencies.
     */
    distinct?: Fundraiser_acceptedcurrenciesScalarFieldEnum | Fundraiser_acceptedcurrenciesScalarFieldEnum[]
  }

  /**
   * fundraiser_acceptedcurrencies findMany
   */
  export type fundraiser_acceptedcurrenciesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser_acceptedcurrencies to fetch.
     */
    where?: fundraiser_acceptedcurrenciesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraiser_acceptedcurrencies to fetch.
     */
    orderBy?: fundraiser_acceptedcurrenciesOrderByWithRelationInput | fundraiser_acceptedcurrenciesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fundraiser_acceptedcurrencies.
     */
    cursor?: fundraiser_acceptedcurrenciesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraiser_acceptedcurrencies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraiser_acceptedcurrencies.
     */
    skip?: number
    distinct?: Fundraiser_acceptedcurrenciesScalarFieldEnum | Fundraiser_acceptedcurrenciesScalarFieldEnum[]
  }

  /**
   * fundraiser_acceptedcurrencies create
   */
  export type fundraiser_acceptedcurrenciesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
    /**
     * The data needed to create a fundraiser_acceptedcurrencies.
     */
    data?: XOR<fundraiser_acceptedcurrenciesCreateInput, fundraiser_acceptedcurrenciesUncheckedCreateInput>
  }

  /**
   * fundraiser_acceptedcurrencies createMany
   */
  export type fundraiser_acceptedcurrenciesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fundraiser_acceptedcurrencies.
     */
    data: fundraiser_acceptedcurrenciesCreateManyInput | fundraiser_acceptedcurrenciesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * fundraiser_acceptedcurrencies update
   */
  export type fundraiser_acceptedcurrenciesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
    /**
     * The data needed to update a fundraiser_acceptedcurrencies.
     */
    data: XOR<fundraiser_acceptedcurrenciesUpdateInput, fundraiser_acceptedcurrenciesUncheckedUpdateInput>
    /**
     * Choose, which fundraiser_acceptedcurrencies to update.
     */
    where: fundraiser_acceptedcurrenciesWhereUniqueInput
  }

  /**
   * fundraiser_acceptedcurrencies updateMany
   */
  export type fundraiser_acceptedcurrenciesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fundraiser_acceptedcurrencies.
     */
    data: XOR<fundraiser_acceptedcurrenciesUpdateManyMutationInput, fundraiser_acceptedcurrenciesUncheckedUpdateManyInput>
    /**
     * Filter which fundraiser_acceptedcurrencies to update
     */
    where?: fundraiser_acceptedcurrenciesWhereInput
    /**
     * Limit how many fundraiser_acceptedcurrencies to update.
     */
    limit?: number
  }

  /**
   * fundraiser_acceptedcurrencies upsert
   */
  export type fundraiser_acceptedcurrenciesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
    /**
     * The filter to search for the fundraiser_acceptedcurrencies to update in case it exists.
     */
    where: fundraiser_acceptedcurrenciesWhereUniqueInput
    /**
     * In case the fundraiser_acceptedcurrencies found by the `where` argument doesn't exist, create a new fundraiser_acceptedcurrencies with this data.
     */
    create: XOR<fundraiser_acceptedcurrenciesCreateInput, fundraiser_acceptedcurrenciesUncheckedCreateInput>
    /**
     * In case the fundraiser_acceptedcurrencies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fundraiser_acceptedcurrenciesUpdateInput, fundraiser_acceptedcurrenciesUncheckedUpdateInput>
  }

  /**
   * fundraiser_acceptedcurrencies delete
   */
  export type fundraiser_acceptedcurrenciesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
    /**
     * Filter which fundraiser_acceptedcurrencies to delete.
     */
    where: fundraiser_acceptedcurrenciesWhereUniqueInput
  }

  /**
   * fundraiser_acceptedcurrencies deleteMany
   */
  export type fundraiser_acceptedcurrenciesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fundraiser_acceptedcurrencies to delete
     */
    where?: fundraiser_acceptedcurrenciesWhereInput
    /**
     * Limit how many fundraiser_acceptedcurrencies to delete.
     */
    limit?: number
  }

  /**
   * fundraiser_acceptedcurrencies.fundraiser
   */
  export type fundraiser_acceptedcurrencies$fundraiserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    where?: fundraiserWhereInput
  }

  /**
   * fundraiser_acceptedcurrencies.currency
   */
  export type fundraiser_acceptedcurrencies$currencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
    where?: currencyWhereInput
  }

  /**
   * fundraiser_acceptedcurrencies without action
   */
  export type fundraiser_acceptedcurrenciesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_acceptedcurrencies
     */
    select?: fundraiser_acceptedcurrenciesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_acceptedcurrencies
     */
    omit?: fundraiser_acceptedcurrenciesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_acceptedcurrenciesInclude<ExtArgs> | null
  }


  /**
   * Model fundraiser_contactlinks
   */

  export type AggregateFundraiser_contactlinks = {
    _count: Fundraiser_contactlinksCountAggregateOutputType | null
    _avg: Fundraiser_contactlinksAvgAggregateOutputType | null
    _sum: Fundraiser_contactlinksSumAggregateOutputType | null
    _min: Fundraiser_contactlinksMinAggregateOutputType | null
    _max: Fundraiser_contactlinksMaxAggregateOutputType | null
  }

  export type Fundraiser_contactlinksAvgAggregateOutputType = {
    ContactID: number | null
    FundraiserID: number | null
    Platform: number | null
  }

  export type Fundraiser_contactlinksSumAggregateOutputType = {
    ContactID: number | null
    FundraiserID: number | null
    Platform: number | null
  }

  export type Fundraiser_contactlinksMinAggregateOutputType = {
    ContactID: number | null
    FundraiserID: number | null
    Platform: number | null
    ContactURL: string | null
  }

  export type Fundraiser_contactlinksMaxAggregateOutputType = {
    ContactID: number | null
    FundraiserID: number | null
    Platform: number | null
    ContactURL: string | null
  }

  export type Fundraiser_contactlinksCountAggregateOutputType = {
    ContactID: number
    FundraiserID: number
    Platform: number
    ContactURL: number
    _all: number
  }


  export type Fundraiser_contactlinksAvgAggregateInputType = {
    ContactID?: true
    FundraiserID?: true
    Platform?: true
  }

  export type Fundraiser_contactlinksSumAggregateInputType = {
    ContactID?: true
    FundraiserID?: true
    Platform?: true
  }

  export type Fundraiser_contactlinksMinAggregateInputType = {
    ContactID?: true
    FundraiserID?: true
    Platform?: true
    ContactURL?: true
  }

  export type Fundraiser_contactlinksMaxAggregateInputType = {
    ContactID?: true
    FundraiserID?: true
    Platform?: true
    ContactURL?: true
  }

  export type Fundraiser_contactlinksCountAggregateInputType = {
    ContactID?: true
    FundraiserID?: true
    Platform?: true
    ContactURL?: true
    _all?: true
  }

  export type Fundraiser_contactlinksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fundraiser_contactlinks to aggregate.
     */
    where?: fundraiser_contactlinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraiser_contactlinks to fetch.
     */
    orderBy?: fundraiser_contactlinksOrderByWithRelationInput | fundraiser_contactlinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fundraiser_contactlinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraiser_contactlinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraiser_contactlinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned fundraiser_contactlinks
    **/
    _count?: true | Fundraiser_contactlinksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Fundraiser_contactlinksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Fundraiser_contactlinksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Fundraiser_contactlinksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Fundraiser_contactlinksMaxAggregateInputType
  }

  export type GetFundraiser_contactlinksAggregateType<T extends Fundraiser_contactlinksAggregateArgs> = {
        [P in keyof T & keyof AggregateFundraiser_contactlinks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFundraiser_contactlinks[P]>
      : GetScalarType<T[P], AggregateFundraiser_contactlinks[P]>
  }




  export type fundraiser_contactlinksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: fundraiser_contactlinksWhereInput
    orderBy?: fundraiser_contactlinksOrderByWithAggregationInput | fundraiser_contactlinksOrderByWithAggregationInput[]
    by: Fundraiser_contactlinksScalarFieldEnum[] | Fundraiser_contactlinksScalarFieldEnum
    having?: fundraiser_contactlinksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Fundraiser_contactlinksCountAggregateInputType | true
    _avg?: Fundraiser_contactlinksAvgAggregateInputType
    _sum?: Fundraiser_contactlinksSumAggregateInputType
    _min?: Fundraiser_contactlinksMinAggregateInputType
    _max?: Fundraiser_contactlinksMaxAggregateInputType
  }

  export type Fundraiser_contactlinksGroupByOutputType = {
    ContactID: number
    FundraiserID: number | null
    Platform: number | null
    ContactURL: string
    _count: Fundraiser_contactlinksCountAggregateOutputType | null
    _avg: Fundraiser_contactlinksAvgAggregateOutputType | null
    _sum: Fundraiser_contactlinksSumAggregateOutputType | null
    _min: Fundraiser_contactlinksMinAggregateOutputType | null
    _max: Fundraiser_contactlinksMaxAggregateOutputType | null
  }

  type GetFundraiser_contactlinksGroupByPayload<T extends fundraiser_contactlinksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Fundraiser_contactlinksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Fundraiser_contactlinksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Fundraiser_contactlinksGroupByOutputType[P]>
            : GetScalarType<T[P], Fundraiser_contactlinksGroupByOutputType[P]>
        }
      >
    >


  export type fundraiser_contactlinksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ContactID?: boolean
    FundraiserID?: boolean
    Platform?: boolean
    ContactURL?: boolean
    fundraiser?: boolean | fundraiser_contactlinks$fundraiserArgs<ExtArgs>
  }, ExtArgs["result"]["fundraiser_contactlinks"]>



  export type fundraiser_contactlinksSelectScalar = {
    ContactID?: boolean
    FundraiserID?: boolean
    Platform?: boolean
    ContactURL?: boolean
  }

  export type fundraiser_contactlinksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ContactID" | "FundraiserID" | "Platform" | "ContactURL", ExtArgs["result"]["fundraiser_contactlinks"]>
  export type fundraiser_contactlinksInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fundraiser?: boolean | fundraiser_contactlinks$fundraiserArgs<ExtArgs>
  }

  export type $fundraiser_contactlinksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "fundraiser_contactlinks"
    objects: {
      fundraiser: Prisma.$fundraiserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ContactID: number
      FundraiserID: number | null
      Platform: number | null
      ContactURL: string
    }, ExtArgs["result"]["fundraiser_contactlinks"]>
    composites: {}
  }

  type fundraiser_contactlinksGetPayload<S extends boolean | null | undefined | fundraiser_contactlinksDefaultArgs> = $Result.GetResult<Prisma.$fundraiser_contactlinksPayload, S>

  type fundraiser_contactlinksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<fundraiser_contactlinksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Fundraiser_contactlinksCountAggregateInputType | true
    }

  export interface fundraiser_contactlinksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['fundraiser_contactlinks'], meta: { name: 'fundraiser_contactlinks' } }
    /**
     * Find zero or one Fundraiser_contactlinks that matches the filter.
     * @param {fundraiser_contactlinksFindUniqueArgs} args - Arguments to find a Fundraiser_contactlinks
     * @example
     * // Get one Fundraiser_contactlinks
     * const fundraiser_contactlinks = await prisma.fundraiser_contactlinks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends fundraiser_contactlinksFindUniqueArgs>(args: SelectSubset<T, fundraiser_contactlinksFindUniqueArgs<ExtArgs>>): Prisma__fundraiser_contactlinksClient<$Result.GetResult<Prisma.$fundraiser_contactlinksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fundraiser_contactlinks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {fundraiser_contactlinksFindUniqueOrThrowArgs} args - Arguments to find a Fundraiser_contactlinks
     * @example
     * // Get one Fundraiser_contactlinks
     * const fundraiser_contactlinks = await prisma.fundraiser_contactlinks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends fundraiser_contactlinksFindUniqueOrThrowArgs>(args: SelectSubset<T, fundraiser_contactlinksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__fundraiser_contactlinksClient<$Result.GetResult<Prisma.$fundraiser_contactlinksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fundraiser_contactlinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_contactlinksFindFirstArgs} args - Arguments to find a Fundraiser_contactlinks
     * @example
     * // Get one Fundraiser_contactlinks
     * const fundraiser_contactlinks = await prisma.fundraiser_contactlinks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends fundraiser_contactlinksFindFirstArgs>(args?: SelectSubset<T, fundraiser_contactlinksFindFirstArgs<ExtArgs>>): Prisma__fundraiser_contactlinksClient<$Result.GetResult<Prisma.$fundraiser_contactlinksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fundraiser_contactlinks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_contactlinksFindFirstOrThrowArgs} args - Arguments to find a Fundraiser_contactlinks
     * @example
     * // Get one Fundraiser_contactlinks
     * const fundraiser_contactlinks = await prisma.fundraiser_contactlinks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends fundraiser_contactlinksFindFirstOrThrowArgs>(args?: SelectSubset<T, fundraiser_contactlinksFindFirstOrThrowArgs<ExtArgs>>): Prisma__fundraiser_contactlinksClient<$Result.GetResult<Prisma.$fundraiser_contactlinksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fundraiser_contactlinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_contactlinksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fundraiser_contactlinks
     * const fundraiser_contactlinks = await prisma.fundraiser_contactlinks.findMany()
     * 
     * // Get first 10 Fundraiser_contactlinks
     * const fundraiser_contactlinks = await prisma.fundraiser_contactlinks.findMany({ take: 10 })
     * 
     * // Only select the `ContactID`
     * const fundraiser_contactlinksWithContactIDOnly = await prisma.fundraiser_contactlinks.findMany({ select: { ContactID: true } })
     * 
     */
    findMany<T extends fundraiser_contactlinksFindManyArgs>(args?: SelectSubset<T, fundraiser_contactlinksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$fundraiser_contactlinksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fundraiser_contactlinks.
     * @param {fundraiser_contactlinksCreateArgs} args - Arguments to create a Fundraiser_contactlinks.
     * @example
     * // Create one Fundraiser_contactlinks
     * const Fundraiser_contactlinks = await prisma.fundraiser_contactlinks.create({
     *   data: {
     *     // ... data to create a Fundraiser_contactlinks
     *   }
     * })
     * 
     */
    create<T extends fundraiser_contactlinksCreateArgs>(args: SelectSubset<T, fundraiser_contactlinksCreateArgs<ExtArgs>>): Prisma__fundraiser_contactlinksClient<$Result.GetResult<Prisma.$fundraiser_contactlinksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fundraiser_contactlinks.
     * @param {fundraiser_contactlinksCreateManyArgs} args - Arguments to create many Fundraiser_contactlinks.
     * @example
     * // Create many Fundraiser_contactlinks
     * const fundraiser_contactlinks = await prisma.fundraiser_contactlinks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends fundraiser_contactlinksCreateManyArgs>(args?: SelectSubset<T, fundraiser_contactlinksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Fundraiser_contactlinks.
     * @param {fundraiser_contactlinksDeleteArgs} args - Arguments to delete one Fundraiser_contactlinks.
     * @example
     * // Delete one Fundraiser_contactlinks
     * const Fundraiser_contactlinks = await prisma.fundraiser_contactlinks.delete({
     *   where: {
     *     // ... filter to delete one Fundraiser_contactlinks
     *   }
     * })
     * 
     */
    delete<T extends fundraiser_contactlinksDeleteArgs>(args: SelectSubset<T, fundraiser_contactlinksDeleteArgs<ExtArgs>>): Prisma__fundraiser_contactlinksClient<$Result.GetResult<Prisma.$fundraiser_contactlinksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fundraiser_contactlinks.
     * @param {fundraiser_contactlinksUpdateArgs} args - Arguments to update one Fundraiser_contactlinks.
     * @example
     * // Update one Fundraiser_contactlinks
     * const fundraiser_contactlinks = await prisma.fundraiser_contactlinks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends fundraiser_contactlinksUpdateArgs>(args: SelectSubset<T, fundraiser_contactlinksUpdateArgs<ExtArgs>>): Prisma__fundraiser_contactlinksClient<$Result.GetResult<Prisma.$fundraiser_contactlinksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fundraiser_contactlinks.
     * @param {fundraiser_contactlinksDeleteManyArgs} args - Arguments to filter Fundraiser_contactlinks to delete.
     * @example
     * // Delete a few Fundraiser_contactlinks
     * const { count } = await prisma.fundraiser_contactlinks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends fundraiser_contactlinksDeleteManyArgs>(args?: SelectSubset<T, fundraiser_contactlinksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fundraiser_contactlinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_contactlinksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fundraiser_contactlinks
     * const fundraiser_contactlinks = await prisma.fundraiser_contactlinks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends fundraiser_contactlinksUpdateManyArgs>(args: SelectSubset<T, fundraiser_contactlinksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fundraiser_contactlinks.
     * @param {fundraiser_contactlinksUpsertArgs} args - Arguments to update or create a Fundraiser_contactlinks.
     * @example
     * // Update or create a Fundraiser_contactlinks
     * const fundraiser_contactlinks = await prisma.fundraiser_contactlinks.upsert({
     *   create: {
     *     // ... data to create a Fundraiser_contactlinks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fundraiser_contactlinks we want to update
     *   }
     * })
     */
    upsert<T extends fundraiser_contactlinksUpsertArgs>(args: SelectSubset<T, fundraiser_contactlinksUpsertArgs<ExtArgs>>): Prisma__fundraiser_contactlinksClient<$Result.GetResult<Prisma.$fundraiser_contactlinksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fundraiser_contactlinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_contactlinksCountArgs} args - Arguments to filter Fundraiser_contactlinks to count.
     * @example
     * // Count the number of Fundraiser_contactlinks
     * const count = await prisma.fundraiser_contactlinks.count({
     *   where: {
     *     // ... the filter for the Fundraiser_contactlinks we want to count
     *   }
     * })
    **/
    count<T extends fundraiser_contactlinksCountArgs>(
      args?: Subset<T, fundraiser_contactlinksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Fundraiser_contactlinksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fundraiser_contactlinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Fundraiser_contactlinksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Fundraiser_contactlinksAggregateArgs>(args: Subset<T, Fundraiser_contactlinksAggregateArgs>): Prisma.PrismaPromise<GetFundraiser_contactlinksAggregateType<T>>

    /**
     * Group by Fundraiser_contactlinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fundraiser_contactlinksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends fundraiser_contactlinksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: fundraiser_contactlinksGroupByArgs['orderBy'] }
        : { orderBy?: fundraiser_contactlinksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, fundraiser_contactlinksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFundraiser_contactlinksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the fundraiser_contactlinks model
   */
  readonly fields: fundraiser_contactlinksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for fundraiser_contactlinks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__fundraiser_contactlinksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fundraiser<T extends fundraiser_contactlinks$fundraiserArgs<ExtArgs> = {}>(args?: Subset<T, fundraiser_contactlinks$fundraiserArgs<ExtArgs>>): Prisma__fundraiserClient<$Result.GetResult<Prisma.$fundraiserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the fundraiser_contactlinks model
   */
  interface fundraiser_contactlinksFieldRefs {
    readonly ContactID: FieldRef<"fundraiser_contactlinks", 'Int'>
    readonly FundraiserID: FieldRef<"fundraiser_contactlinks", 'Int'>
    readonly Platform: FieldRef<"fundraiser_contactlinks", 'Int'>
    readonly ContactURL: FieldRef<"fundraiser_contactlinks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * fundraiser_contactlinks findUnique
   */
  export type fundraiser_contactlinksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_contactlinks
     */
    select?: fundraiser_contactlinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_contactlinks
     */
    omit?: fundraiser_contactlinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_contactlinksInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser_contactlinks to fetch.
     */
    where: fundraiser_contactlinksWhereUniqueInput
  }

  /**
   * fundraiser_contactlinks findUniqueOrThrow
   */
  export type fundraiser_contactlinksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_contactlinks
     */
    select?: fundraiser_contactlinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_contactlinks
     */
    omit?: fundraiser_contactlinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_contactlinksInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser_contactlinks to fetch.
     */
    where: fundraiser_contactlinksWhereUniqueInput
  }

  /**
   * fundraiser_contactlinks findFirst
   */
  export type fundraiser_contactlinksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_contactlinks
     */
    select?: fundraiser_contactlinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_contactlinks
     */
    omit?: fundraiser_contactlinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_contactlinksInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser_contactlinks to fetch.
     */
    where?: fundraiser_contactlinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraiser_contactlinks to fetch.
     */
    orderBy?: fundraiser_contactlinksOrderByWithRelationInput | fundraiser_contactlinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fundraiser_contactlinks.
     */
    cursor?: fundraiser_contactlinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraiser_contactlinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraiser_contactlinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fundraiser_contactlinks.
     */
    distinct?: Fundraiser_contactlinksScalarFieldEnum | Fundraiser_contactlinksScalarFieldEnum[]
  }

  /**
   * fundraiser_contactlinks findFirstOrThrow
   */
  export type fundraiser_contactlinksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_contactlinks
     */
    select?: fundraiser_contactlinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_contactlinks
     */
    omit?: fundraiser_contactlinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_contactlinksInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser_contactlinks to fetch.
     */
    where?: fundraiser_contactlinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraiser_contactlinks to fetch.
     */
    orderBy?: fundraiser_contactlinksOrderByWithRelationInput | fundraiser_contactlinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for fundraiser_contactlinks.
     */
    cursor?: fundraiser_contactlinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraiser_contactlinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraiser_contactlinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of fundraiser_contactlinks.
     */
    distinct?: Fundraiser_contactlinksScalarFieldEnum | Fundraiser_contactlinksScalarFieldEnum[]
  }

  /**
   * fundraiser_contactlinks findMany
   */
  export type fundraiser_contactlinksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_contactlinks
     */
    select?: fundraiser_contactlinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_contactlinks
     */
    omit?: fundraiser_contactlinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_contactlinksInclude<ExtArgs> | null
    /**
     * Filter, which fundraiser_contactlinks to fetch.
     */
    where?: fundraiser_contactlinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of fundraiser_contactlinks to fetch.
     */
    orderBy?: fundraiser_contactlinksOrderByWithRelationInput | fundraiser_contactlinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing fundraiser_contactlinks.
     */
    cursor?: fundraiser_contactlinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` fundraiser_contactlinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` fundraiser_contactlinks.
     */
    skip?: number
    distinct?: Fundraiser_contactlinksScalarFieldEnum | Fundraiser_contactlinksScalarFieldEnum[]
  }

  /**
   * fundraiser_contactlinks create
   */
  export type fundraiser_contactlinksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_contactlinks
     */
    select?: fundraiser_contactlinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_contactlinks
     */
    omit?: fundraiser_contactlinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_contactlinksInclude<ExtArgs> | null
    /**
     * The data needed to create a fundraiser_contactlinks.
     */
    data: XOR<fundraiser_contactlinksCreateInput, fundraiser_contactlinksUncheckedCreateInput>
  }

  /**
   * fundraiser_contactlinks createMany
   */
  export type fundraiser_contactlinksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many fundraiser_contactlinks.
     */
    data: fundraiser_contactlinksCreateManyInput | fundraiser_contactlinksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * fundraiser_contactlinks update
   */
  export type fundraiser_contactlinksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_contactlinks
     */
    select?: fundraiser_contactlinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_contactlinks
     */
    omit?: fundraiser_contactlinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_contactlinksInclude<ExtArgs> | null
    /**
     * The data needed to update a fundraiser_contactlinks.
     */
    data: XOR<fundraiser_contactlinksUpdateInput, fundraiser_contactlinksUncheckedUpdateInput>
    /**
     * Choose, which fundraiser_contactlinks to update.
     */
    where: fundraiser_contactlinksWhereUniqueInput
  }

  /**
   * fundraiser_contactlinks updateMany
   */
  export type fundraiser_contactlinksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update fundraiser_contactlinks.
     */
    data: XOR<fundraiser_contactlinksUpdateManyMutationInput, fundraiser_contactlinksUncheckedUpdateManyInput>
    /**
     * Filter which fundraiser_contactlinks to update
     */
    where?: fundraiser_contactlinksWhereInput
    /**
     * Limit how many fundraiser_contactlinks to update.
     */
    limit?: number
  }

  /**
   * fundraiser_contactlinks upsert
   */
  export type fundraiser_contactlinksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_contactlinks
     */
    select?: fundraiser_contactlinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_contactlinks
     */
    omit?: fundraiser_contactlinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_contactlinksInclude<ExtArgs> | null
    /**
     * The filter to search for the fundraiser_contactlinks to update in case it exists.
     */
    where: fundraiser_contactlinksWhereUniqueInput
    /**
     * In case the fundraiser_contactlinks found by the `where` argument doesn't exist, create a new fundraiser_contactlinks with this data.
     */
    create: XOR<fundraiser_contactlinksCreateInput, fundraiser_contactlinksUncheckedCreateInput>
    /**
     * In case the fundraiser_contactlinks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fundraiser_contactlinksUpdateInput, fundraiser_contactlinksUncheckedUpdateInput>
  }

  /**
   * fundraiser_contactlinks delete
   */
  export type fundraiser_contactlinksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_contactlinks
     */
    select?: fundraiser_contactlinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_contactlinks
     */
    omit?: fundraiser_contactlinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_contactlinksInclude<ExtArgs> | null
    /**
     * Filter which fundraiser_contactlinks to delete.
     */
    where: fundraiser_contactlinksWhereUniqueInput
  }

  /**
   * fundraiser_contactlinks deleteMany
   */
  export type fundraiser_contactlinksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which fundraiser_contactlinks to delete
     */
    where?: fundraiser_contactlinksWhereInput
    /**
     * Limit how many fundraiser_contactlinks to delete.
     */
    limit?: number
  }

  /**
   * fundraiser_contactlinks.fundraiser
   */
  export type fundraiser_contactlinks$fundraiserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser
     */
    select?: fundraiserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser
     */
    omit?: fundraiserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiserInclude<ExtArgs> | null
    where?: fundraiserWhereInput
  }

  /**
   * fundraiser_contactlinks without action
   */
  export type fundraiser_contactlinksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the fundraiser_contactlinks
     */
    select?: fundraiser_contactlinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the fundraiser_contactlinks
     */
    omit?: fundraiser_contactlinksOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: fundraiser_contactlinksInclude<ExtArgs> | null
  }


  /**
   * Model manychat
   */

  export type AggregateManychat = {
    _count: ManychatCountAggregateOutputType | null
    _avg: ManychatAvgAggregateOutputType | null
    _sum: ManychatSumAggregateOutputType | null
    _min: ManychatMinAggregateOutputType | null
    _max: ManychatMaxAggregateOutputType | null
  }

  export type ManychatAvgAggregateOutputType = {
    ManyChatId: number | null
    CustomerId: number | null
  }

  export type ManychatSumAggregateOutputType = {
    ManyChatId: number | null
    CustomerId: number | null
  }

  export type ManychatMinAggregateOutputType = {
    ManyChatId: number | null
    ConversationId: string | null
    CustomerId: number | null
    CreateAt: Date | null
    UpdateAt: Date | null
  }

  export type ManychatMaxAggregateOutputType = {
    ManyChatId: number | null
    ConversationId: string | null
    CustomerId: number | null
    CreateAt: Date | null
    UpdateAt: Date | null
  }

  export type ManychatCountAggregateOutputType = {
    ManyChatId: number
    ConversationId: number
    CustomerId: number
    CreateAt: number
    UpdateAt: number
    _all: number
  }


  export type ManychatAvgAggregateInputType = {
    ManyChatId?: true
    CustomerId?: true
  }

  export type ManychatSumAggregateInputType = {
    ManyChatId?: true
    CustomerId?: true
  }

  export type ManychatMinAggregateInputType = {
    ManyChatId?: true
    ConversationId?: true
    CustomerId?: true
    CreateAt?: true
    UpdateAt?: true
  }

  export type ManychatMaxAggregateInputType = {
    ManyChatId?: true
    ConversationId?: true
    CustomerId?: true
    CreateAt?: true
    UpdateAt?: true
  }

  export type ManychatCountAggregateInputType = {
    ManyChatId?: true
    ConversationId?: true
    CustomerId?: true
    CreateAt?: true
    UpdateAt?: true
    _all?: true
  }

  export type ManychatAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manychat to aggregate.
     */
    where?: manychatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manychats to fetch.
     */
    orderBy?: manychatOrderByWithRelationInput | manychatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: manychatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manychats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manychats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned manychats
    **/
    _count?: true | ManychatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManychatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManychatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManychatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManychatMaxAggregateInputType
  }

  export type GetManychatAggregateType<T extends ManychatAggregateArgs> = {
        [P in keyof T & keyof AggregateManychat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManychat[P]>
      : GetScalarType<T[P], AggregateManychat[P]>
  }




  export type manychatGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: manychatWhereInput
    orderBy?: manychatOrderByWithAggregationInput | manychatOrderByWithAggregationInput[]
    by: ManychatScalarFieldEnum[] | ManychatScalarFieldEnum
    having?: manychatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManychatCountAggregateInputType | true
    _avg?: ManychatAvgAggregateInputType
    _sum?: ManychatSumAggregateInputType
    _min?: ManychatMinAggregateInputType
    _max?: ManychatMaxAggregateInputType
  }

  export type ManychatGroupByOutputType = {
    ManyChatId: number
    ConversationId: string
    CustomerId: number
    CreateAt: Date
    UpdateAt: Date
    _count: ManychatCountAggregateOutputType | null
    _avg: ManychatAvgAggregateOutputType | null
    _sum: ManychatSumAggregateOutputType | null
    _min: ManychatMinAggregateOutputType | null
    _max: ManychatMaxAggregateOutputType | null
  }

  type GetManychatGroupByPayload<T extends manychatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ManychatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManychatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManychatGroupByOutputType[P]>
            : GetScalarType<T[P], ManychatGroupByOutputType[P]>
        }
      >
    >


  export type manychatSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ManyChatId?: boolean
    ConversationId?: boolean
    CustomerId?: boolean
    CreateAt?: boolean
    UpdateAt?: boolean
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["manychat"]>



  export type manychatSelectScalar = {
    ManyChatId?: boolean
    ConversationId?: boolean
    CustomerId?: boolean
    CreateAt?: boolean
    UpdateAt?: boolean
  }

  export type manychatOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ManyChatId" | "ConversationId" | "CustomerId" | "CreateAt" | "UpdateAt", ExtArgs["result"]["manychat"]>
  export type manychatInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customer?: boolean | customerDefaultArgs<ExtArgs>
  }

  export type $manychatPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "manychat"
    objects: {
      customer: Prisma.$customerPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ManyChatId: number
      ConversationId: string
      CustomerId: number
      CreateAt: Date
      UpdateAt: Date
    }, ExtArgs["result"]["manychat"]>
    composites: {}
  }

  type manychatGetPayload<S extends boolean | null | undefined | manychatDefaultArgs> = $Result.GetResult<Prisma.$manychatPayload, S>

  type manychatCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<manychatFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ManychatCountAggregateInputType | true
    }

  export interface manychatDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['manychat'], meta: { name: 'manychat' } }
    /**
     * Find zero or one Manychat that matches the filter.
     * @param {manychatFindUniqueArgs} args - Arguments to find a Manychat
     * @example
     * // Get one Manychat
     * const manychat = await prisma.manychat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends manychatFindUniqueArgs>(args: SelectSubset<T, manychatFindUniqueArgs<ExtArgs>>): Prisma__manychatClient<$Result.GetResult<Prisma.$manychatPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Manychat that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {manychatFindUniqueOrThrowArgs} args - Arguments to find a Manychat
     * @example
     * // Get one Manychat
     * const manychat = await prisma.manychat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends manychatFindUniqueOrThrowArgs>(args: SelectSubset<T, manychatFindUniqueOrThrowArgs<ExtArgs>>): Prisma__manychatClient<$Result.GetResult<Prisma.$manychatPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manychat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manychatFindFirstArgs} args - Arguments to find a Manychat
     * @example
     * // Get one Manychat
     * const manychat = await prisma.manychat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends manychatFindFirstArgs>(args?: SelectSubset<T, manychatFindFirstArgs<ExtArgs>>): Prisma__manychatClient<$Result.GetResult<Prisma.$manychatPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Manychat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manychatFindFirstOrThrowArgs} args - Arguments to find a Manychat
     * @example
     * // Get one Manychat
     * const manychat = await prisma.manychat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends manychatFindFirstOrThrowArgs>(args?: SelectSubset<T, manychatFindFirstOrThrowArgs<ExtArgs>>): Prisma__manychatClient<$Result.GetResult<Prisma.$manychatPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Manychats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manychatFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manychats
     * const manychats = await prisma.manychat.findMany()
     * 
     * // Get first 10 Manychats
     * const manychats = await prisma.manychat.findMany({ take: 10 })
     * 
     * // Only select the `ManyChatId`
     * const manychatWithManyChatIdOnly = await prisma.manychat.findMany({ select: { ManyChatId: true } })
     * 
     */
    findMany<T extends manychatFindManyArgs>(args?: SelectSubset<T, manychatFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$manychatPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Manychat.
     * @param {manychatCreateArgs} args - Arguments to create a Manychat.
     * @example
     * // Create one Manychat
     * const Manychat = await prisma.manychat.create({
     *   data: {
     *     // ... data to create a Manychat
     *   }
     * })
     * 
     */
    create<T extends manychatCreateArgs>(args: SelectSubset<T, manychatCreateArgs<ExtArgs>>): Prisma__manychatClient<$Result.GetResult<Prisma.$manychatPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Manychats.
     * @param {manychatCreateManyArgs} args - Arguments to create many Manychats.
     * @example
     * // Create many Manychats
     * const manychat = await prisma.manychat.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends manychatCreateManyArgs>(args?: SelectSubset<T, manychatCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Manychat.
     * @param {manychatDeleteArgs} args - Arguments to delete one Manychat.
     * @example
     * // Delete one Manychat
     * const Manychat = await prisma.manychat.delete({
     *   where: {
     *     // ... filter to delete one Manychat
     *   }
     * })
     * 
     */
    delete<T extends manychatDeleteArgs>(args: SelectSubset<T, manychatDeleteArgs<ExtArgs>>): Prisma__manychatClient<$Result.GetResult<Prisma.$manychatPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Manychat.
     * @param {manychatUpdateArgs} args - Arguments to update one Manychat.
     * @example
     * // Update one Manychat
     * const manychat = await prisma.manychat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends manychatUpdateArgs>(args: SelectSubset<T, manychatUpdateArgs<ExtArgs>>): Prisma__manychatClient<$Result.GetResult<Prisma.$manychatPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Manychats.
     * @param {manychatDeleteManyArgs} args - Arguments to filter Manychats to delete.
     * @example
     * // Delete a few Manychats
     * const { count } = await prisma.manychat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends manychatDeleteManyArgs>(args?: SelectSubset<T, manychatDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manychats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manychatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manychats
     * const manychat = await prisma.manychat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends manychatUpdateManyArgs>(args: SelectSubset<T, manychatUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Manychat.
     * @param {manychatUpsertArgs} args - Arguments to update or create a Manychat.
     * @example
     * // Update or create a Manychat
     * const manychat = await prisma.manychat.upsert({
     *   create: {
     *     // ... data to create a Manychat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manychat we want to update
     *   }
     * })
     */
    upsert<T extends manychatUpsertArgs>(args: SelectSubset<T, manychatUpsertArgs<ExtArgs>>): Prisma__manychatClient<$Result.GetResult<Prisma.$manychatPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Manychats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manychatCountArgs} args - Arguments to filter Manychats to count.
     * @example
     * // Count the number of Manychats
     * const count = await prisma.manychat.count({
     *   where: {
     *     // ... the filter for the Manychats we want to count
     *   }
     * })
    **/
    count<T extends manychatCountArgs>(
      args?: Subset<T, manychatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManychatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manychat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManychatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManychatAggregateArgs>(args: Subset<T, ManychatAggregateArgs>): Prisma.PrismaPromise<GetManychatAggregateType<T>>

    /**
     * Group by Manychat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {manychatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends manychatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: manychatGroupByArgs['orderBy'] }
        : { orderBy?: manychatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, manychatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManychatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the manychat model
   */
  readonly fields: manychatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for manychat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__manychatClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the manychat model
   */
  interface manychatFieldRefs {
    readonly ManyChatId: FieldRef<"manychat", 'Int'>
    readonly ConversationId: FieldRef<"manychat", 'String'>
    readonly CustomerId: FieldRef<"manychat", 'Int'>
    readonly CreateAt: FieldRef<"manychat", 'DateTime'>
    readonly UpdateAt: FieldRef<"manychat", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * manychat findUnique
   */
  export type manychatFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manychat
     */
    select?: manychatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manychat
     */
    omit?: manychatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manychatInclude<ExtArgs> | null
    /**
     * Filter, which manychat to fetch.
     */
    where: manychatWhereUniqueInput
  }

  /**
   * manychat findUniqueOrThrow
   */
  export type manychatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manychat
     */
    select?: manychatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manychat
     */
    omit?: manychatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manychatInclude<ExtArgs> | null
    /**
     * Filter, which manychat to fetch.
     */
    where: manychatWhereUniqueInput
  }

  /**
   * manychat findFirst
   */
  export type manychatFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manychat
     */
    select?: manychatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manychat
     */
    omit?: manychatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manychatInclude<ExtArgs> | null
    /**
     * Filter, which manychat to fetch.
     */
    where?: manychatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manychats to fetch.
     */
    orderBy?: manychatOrderByWithRelationInput | manychatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manychats.
     */
    cursor?: manychatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manychats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manychats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manychats.
     */
    distinct?: ManychatScalarFieldEnum | ManychatScalarFieldEnum[]
  }

  /**
   * manychat findFirstOrThrow
   */
  export type manychatFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manychat
     */
    select?: manychatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manychat
     */
    omit?: manychatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manychatInclude<ExtArgs> | null
    /**
     * Filter, which manychat to fetch.
     */
    where?: manychatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manychats to fetch.
     */
    orderBy?: manychatOrderByWithRelationInput | manychatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for manychats.
     */
    cursor?: manychatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manychats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manychats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of manychats.
     */
    distinct?: ManychatScalarFieldEnum | ManychatScalarFieldEnum[]
  }

  /**
   * manychat findMany
   */
  export type manychatFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manychat
     */
    select?: manychatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manychat
     */
    omit?: manychatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manychatInclude<ExtArgs> | null
    /**
     * Filter, which manychats to fetch.
     */
    where?: manychatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of manychats to fetch.
     */
    orderBy?: manychatOrderByWithRelationInput | manychatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing manychats.
     */
    cursor?: manychatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` manychats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` manychats.
     */
    skip?: number
    distinct?: ManychatScalarFieldEnum | ManychatScalarFieldEnum[]
  }

  /**
   * manychat create
   */
  export type manychatCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manychat
     */
    select?: manychatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manychat
     */
    omit?: manychatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manychatInclude<ExtArgs> | null
    /**
     * The data needed to create a manychat.
     */
    data: XOR<manychatCreateInput, manychatUncheckedCreateInput>
  }

  /**
   * manychat createMany
   */
  export type manychatCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many manychats.
     */
    data: manychatCreateManyInput | manychatCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * manychat update
   */
  export type manychatUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manychat
     */
    select?: manychatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manychat
     */
    omit?: manychatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manychatInclude<ExtArgs> | null
    /**
     * The data needed to update a manychat.
     */
    data: XOR<manychatUpdateInput, manychatUncheckedUpdateInput>
    /**
     * Choose, which manychat to update.
     */
    where: manychatWhereUniqueInput
  }

  /**
   * manychat updateMany
   */
  export type manychatUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update manychats.
     */
    data: XOR<manychatUpdateManyMutationInput, manychatUncheckedUpdateManyInput>
    /**
     * Filter which manychats to update
     */
    where?: manychatWhereInput
    /**
     * Limit how many manychats to update.
     */
    limit?: number
  }

  /**
   * manychat upsert
   */
  export type manychatUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manychat
     */
    select?: manychatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manychat
     */
    omit?: manychatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manychatInclude<ExtArgs> | null
    /**
     * The filter to search for the manychat to update in case it exists.
     */
    where: manychatWhereUniqueInput
    /**
     * In case the manychat found by the `where` argument doesn't exist, create a new manychat with this data.
     */
    create: XOR<manychatCreateInput, manychatUncheckedCreateInput>
    /**
     * In case the manychat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<manychatUpdateInput, manychatUncheckedUpdateInput>
  }

  /**
   * manychat delete
   */
  export type manychatDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manychat
     */
    select?: manychatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manychat
     */
    omit?: manychatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manychatInclude<ExtArgs> | null
    /**
     * Filter which manychat to delete.
     */
    where: manychatWhereUniqueInput
  }

  /**
   * manychat deleteMany
   */
  export type manychatDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which manychats to delete
     */
    where?: manychatWhereInput
    /**
     * Limit how many manychats to delete.
     */
    limit?: number
  }

  /**
   * manychat without action
   */
  export type manychatDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the manychat
     */
    select?: manychatSelect<ExtArgs> | null
    /**
     * Omit specific fields from the manychat
     */
    omit?: manychatOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: manychatInclude<ExtArgs> | null
  }


  /**
   * Model minimumamount
   */

  export type AggregateMinimumamount = {
    _count: MinimumamountCountAggregateOutputType | null
    _avg: MinimumamountAvgAggregateOutputType | null
    _sum: MinimumamountSumAggregateOutputType | null
    _min: MinimumamountMinAggregateOutputType | null
    _max: MinimumamountMaxAggregateOutputType | null
  }

  export type MinimumamountAvgAggregateOutputType = {
    MinimumAmountId: number | null
    CurrencyId: number | null
    Amount: Decimal | null
  }

  export type MinimumamountSumAggregateOutputType = {
    MinimumAmountId: number | null
    CurrencyId: number | null
    Amount: Decimal | null
  }

  export type MinimumamountMinAggregateOutputType = {
    MinimumAmountId: number | null
    CurrencyId: number | null
    Amount: Decimal | null
    CreateAt: Date | null
    UpdatedAt: Date | null
  }

  export type MinimumamountMaxAggregateOutputType = {
    MinimumAmountId: number | null
    CurrencyId: number | null
    Amount: Decimal | null
    CreateAt: Date | null
    UpdatedAt: Date | null
  }

  export type MinimumamountCountAggregateOutputType = {
    MinimumAmountId: number
    CurrencyId: number
    Amount: number
    CreateAt: number
    UpdatedAt: number
    _all: number
  }


  export type MinimumamountAvgAggregateInputType = {
    MinimumAmountId?: true
    CurrencyId?: true
    Amount?: true
  }

  export type MinimumamountSumAggregateInputType = {
    MinimumAmountId?: true
    CurrencyId?: true
    Amount?: true
  }

  export type MinimumamountMinAggregateInputType = {
    MinimumAmountId?: true
    CurrencyId?: true
    Amount?: true
    CreateAt?: true
    UpdatedAt?: true
  }

  export type MinimumamountMaxAggregateInputType = {
    MinimumAmountId?: true
    CurrencyId?: true
    Amount?: true
    CreateAt?: true
    UpdatedAt?: true
  }

  export type MinimumamountCountAggregateInputType = {
    MinimumAmountId?: true
    CurrencyId?: true
    Amount?: true
    CreateAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type MinimumamountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which minimumamount to aggregate.
     */
    where?: minimumamountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of minimumamounts to fetch.
     */
    orderBy?: minimumamountOrderByWithRelationInput | minimumamountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: minimumamountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` minimumamounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` minimumamounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned minimumamounts
    **/
    _count?: true | MinimumamountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MinimumamountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MinimumamountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MinimumamountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MinimumamountMaxAggregateInputType
  }

  export type GetMinimumamountAggregateType<T extends MinimumamountAggregateArgs> = {
        [P in keyof T & keyof AggregateMinimumamount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMinimumamount[P]>
      : GetScalarType<T[P], AggregateMinimumamount[P]>
  }




  export type minimumamountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: minimumamountWhereInput
    orderBy?: minimumamountOrderByWithAggregationInput | minimumamountOrderByWithAggregationInput[]
    by: MinimumamountScalarFieldEnum[] | MinimumamountScalarFieldEnum
    having?: minimumamountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MinimumamountCountAggregateInputType | true
    _avg?: MinimumamountAvgAggregateInputType
    _sum?: MinimumamountSumAggregateInputType
    _min?: MinimumamountMinAggregateInputType
    _max?: MinimumamountMaxAggregateInputType
  }

  export type MinimumamountGroupByOutputType = {
    MinimumAmountId: number
    CurrencyId: number
    Amount: Decimal
    CreateAt: Date
    UpdatedAt: Date
    _count: MinimumamountCountAggregateOutputType | null
    _avg: MinimumamountAvgAggregateOutputType | null
    _sum: MinimumamountSumAggregateOutputType | null
    _min: MinimumamountMinAggregateOutputType | null
    _max: MinimumamountMaxAggregateOutputType | null
  }

  type GetMinimumamountGroupByPayload<T extends minimumamountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MinimumamountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MinimumamountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MinimumamountGroupByOutputType[P]>
            : GetScalarType<T[P], MinimumamountGroupByOutputType[P]>
        }
      >
    >


  export type minimumamountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    MinimumAmountId?: boolean
    CurrencyId?: boolean
    Amount?: boolean
    CreateAt?: boolean
    UpdatedAt?: boolean
    currency?: boolean | currencyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["minimumamount"]>



  export type minimumamountSelectScalar = {
    MinimumAmountId?: boolean
    CurrencyId?: boolean
    Amount?: boolean
    CreateAt?: boolean
    UpdatedAt?: boolean
  }

  export type minimumamountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"MinimumAmountId" | "CurrencyId" | "Amount" | "CreateAt" | "UpdatedAt", ExtArgs["result"]["minimumamount"]>
  export type minimumamountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    currency?: boolean | currencyDefaultArgs<ExtArgs>
  }

  export type $minimumamountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "minimumamount"
    objects: {
      currency: Prisma.$currencyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      MinimumAmountId: number
      CurrencyId: number
      Amount: Prisma.Decimal
      CreateAt: Date
      UpdatedAt: Date
    }, ExtArgs["result"]["minimumamount"]>
    composites: {}
  }

  type minimumamountGetPayload<S extends boolean | null | undefined | minimumamountDefaultArgs> = $Result.GetResult<Prisma.$minimumamountPayload, S>

  type minimumamountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<minimumamountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MinimumamountCountAggregateInputType | true
    }

  export interface minimumamountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['minimumamount'], meta: { name: 'minimumamount' } }
    /**
     * Find zero or one Minimumamount that matches the filter.
     * @param {minimumamountFindUniqueArgs} args - Arguments to find a Minimumamount
     * @example
     * // Get one Minimumamount
     * const minimumamount = await prisma.minimumamount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends minimumamountFindUniqueArgs>(args: SelectSubset<T, minimumamountFindUniqueArgs<ExtArgs>>): Prisma__minimumamountClient<$Result.GetResult<Prisma.$minimumamountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Minimumamount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {minimumamountFindUniqueOrThrowArgs} args - Arguments to find a Minimumamount
     * @example
     * // Get one Minimumamount
     * const minimumamount = await prisma.minimumamount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends minimumamountFindUniqueOrThrowArgs>(args: SelectSubset<T, minimumamountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__minimumamountClient<$Result.GetResult<Prisma.$minimumamountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Minimumamount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {minimumamountFindFirstArgs} args - Arguments to find a Minimumamount
     * @example
     * // Get one Minimumamount
     * const minimumamount = await prisma.minimumamount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends minimumamountFindFirstArgs>(args?: SelectSubset<T, minimumamountFindFirstArgs<ExtArgs>>): Prisma__minimumamountClient<$Result.GetResult<Prisma.$minimumamountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Minimumamount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {minimumamountFindFirstOrThrowArgs} args - Arguments to find a Minimumamount
     * @example
     * // Get one Minimumamount
     * const minimumamount = await prisma.minimumamount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends minimumamountFindFirstOrThrowArgs>(args?: SelectSubset<T, minimumamountFindFirstOrThrowArgs<ExtArgs>>): Prisma__minimumamountClient<$Result.GetResult<Prisma.$minimumamountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Minimumamounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {minimumamountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Minimumamounts
     * const minimumamounts = await prisma.minimumamount.findMany()
     * 
     * // Get first 10 Minimumamounts
     * const minimumamounts = await prisma.minimumamount.findMany({ take: 10 })
     * 
     * // Only select the `MinimumAmountId`
     * const minimumamountWithMinimumAmountIdOnly = await prisma.minimumamount.findMany({ select: { MinimumAmountId: true } })
     * 
     */
    findMany<T extends minimumamountFindManyArgs>(args?: SelectSubset<T, minimumamountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$minimumamountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Minimumamount.
     * @param {minimumamountCreateArgs} args - Arguments to create a Minimumamount.
     * @example
     * // Create one Minimumamount
     * const Minimumamount = await prisma.minimumamount.create({
     *   data: {
     *     // ... data to create a Minimumamount
     *   }
     * })
     * 
     */
    create<T extends minimumamountCreateArgs>(args: SelectSubset<T, minimumamountCreateArgs<ExtArgs>>): Prisma__minimumamountClient<$Result.GetResult<Prisma.$minimumamountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Minimumamounts.
     * @param {minimumamountCreateManyArgs} args - Arguments to create many Minimumamounts.
     * @example
     * // Create many Minimumamounts
     * const minimumamount = await prisma.minimumamount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends minimumamountCreateManyArgs>(args?: SelectSubset<T, minimumamountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Minimumamount.
     * @param {minimumamountDeleteArgs} args - Arguments to delete one Minimumamount.
     * @example
     * // Delete one Minimumamount
     * const Minimumamount = await prisma.minimumamount.delete({
     *   where: {
     *     // ... filter to delete one Minimumamount
     *   }
     * })
     * 
     */
    delete<T extends minimumamountDeleteArgs>(args: SelectSubset<T, minimumamountDeleteArgs<ExtArgs>>): Prisma__minimumamountClient<$Result.GetResult<Prisma.$minimumamountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Minimumamount.
     * @param {minimumamountUpdateArgs} args - Arguments to update one Minimumamount.
     * @example
     * // Update one Minimumamount
     * const minimumamount = await prisma.minimumamount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends minimumamountUpdateArgs>(args: SelectSubset<T, minimumamountUpdateArgs<ExtArgs>>): Prisma__minimumamountClient<$Result.GetResult<Prisma.$minimumamountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Minimumamounts.
     * @param {minimumamountDeleteManyArgs} args - Arguments to filter Minimumamounts to delete.
     * @example
     * // Delete a few Minimumamounts
     * const { count } = await prisma.minimumamount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends minimumamountDeleteManyArgs>(args?: SelectSubset<T, minimumamountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Minimumamounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {minimumamountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Minimumamounts
     * const minimumamount = await prisma.minimumamount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends minimumamountUpdateManyArgs>(args: SelectSubset<T, minimumamountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Minimumamount.
     * @param {minimumamountUpsertArgs} args - Arguments to update or create a Minimumamount.
     * @example
     * // Update or create a Minimumamount
     * const minimumamount = await prisma.minimumamount.upsert({
     *   create: {
     *     // ... data to create a Minimumamount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Minimumamount we want to update
     *   }
     * })
     */
    upsert<T extends minimumamountUpsertArgs>(args: SelectSubset<T, minimumamountUpsertArgs<ExtArgs>>): Prisma__minimumamountClient<$Result.GetResult<Prisma.$minimumamountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Minimumamounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {minimumamountCountArgs} args - Arguments to filter Minimumamounts to count.
     * @example
     * // Count the number of Minimumamounts
     * const count = await prisma.minimumamount.count({
     *   where: {
     *     // ... the filter for the Minimumamounts we want to count
     *   }
     * })
    **/
    count<T extends minimumamountCountArgs>(
      args?: Subset<T, minimumamountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MinimumamountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Minimumamount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MinimumamountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MinimumamountAggregateArgs>(args: Subset<T, MinimumamountAggregateArgs>): Prisma.PrismaPromise<GetMinimumamountAggregateType<T>>

    /**
     * Group by Minimumamount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {minimumamountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends minimumamountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: minimumamountGroupByArgs['orderBy'] }
        : { orderBy?: minimumamountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, minimumamountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMinimumamountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the minimumamount model
   */
  readonly fields: minimumamountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for minimumamount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__minimumamountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    currency<T extends currencyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, currencyDefaultArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the minimumamount model
   */
  interface minimumamountFieldRefs {
    readonly MinimumAmountId: FieldRef<"minimumamount", 'Int'>
    readonly CurrencyId: FieldRef<"minimumamount", 'Int'>
    readonly Amount: FieldRef<"minimumamount", 'Decimal'>
    readonly CreateAt: FieldRef<"minimumamount", 'DateTime'>
    readonly UpdatedAt: FieldRef<"minimumamount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * minimumamount findUnique
   */
  export type minimumamountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the minimumamount
     */
    select?: minimumamountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the minimumamount
     */
    omit?: minimumamountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: minimumamountInclude<ExtArgs> | null
    /**
     * Filter, which minimumamount to fetch.
     */
    where: minimumamountWhereUniqueInput
  }

  /**
   * minimumamount findUniqueOrThrow
   */
  export type minimumamountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the minimumamount
     */
    select?: minimumamountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the minimumamount
     */
    omit?: minimumamountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: minimumamountInclude<ExtArgs> | null
    /**
     * Filter, which minimumamount to fetch.
     */
    where: minimumamountWhereUniqueInput
  }

  /**
   * minimumamount findFirst
   */
  export type minimumamountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the minimumamount
     */
    select?: minimumamountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the minimumamount
     */
    omit?: minimumamountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: minimumamountInclude<ExtArgs> | null
    /**
     * Filter, which minimumamount to fetch.
     */
    where?: minimumamountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of minimumamounts to fetch.
     */
    orderBy?: minimumamountOrderByWithRelationInput | minimumamountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for minimumamounts.
     */
    cursor?: minimumamountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` minimumamounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` minimumamounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of minimumamounts.
     */
    distinct?: MinimumamountScalarFieldEnum | MinimumamountScalarFieldEnum[]
  }

  /**
   * minimumamount findFirstOrThrow
   */
  export type minimumamountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the minimumamount
     */
    select?: minimumamountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the minimumamount
     */
    omit?: minimumamountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: minimumamountInclude<ExtArgs> | null
    /**
     * Filter, which minimumamount to fetch.
     */
    where?: minimumamountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of minimumamounts to fetch.
     */
    orderBy?: minimumamountOrderByWithRelationInput | minimumamountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for minimumamounts.
     */
    cursor?: minimumamountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` minimumamounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` minimumamounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of minimumamounts.
     */
    distinct?: MinimumamountScalarFieldEnum | MinimumamountScalarFieldEnum[]
  }

  /**
   * minimumamount findMany
   */
  export type minimumamountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the minimumamount
     */
    select?: minimumamountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the minimumamount
     */
    omit?: minimumamountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: minimumamountInclude<ExtArgs> | null
    /**
     * Filter, which minimumamounts to fetch.
     */
    where?: minimumamountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of minimumamounts to fetch.
     */
    orderBy?: minimumamountOrderByWithRelationInput | minimumamountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing minimumamounts.
     */
    cursor?: minimumamountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` minimumamounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` minimumamounts.
     */
    skip?: number
    distinct?: MinimumamountScalarFieldEnum | MinimumamountScalarFieldEnum[]
  }

  /**
   * minimumamount create
   */
  export type minimumamountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the minimumamount
     */
    select?: minimumamountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the minimumamount
     */
    omit?: minimumamountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: minimumamountInclude<ExtArgs> | null
    /**
     * The data needed to create a minimumamount.
     */
    data: XOR<minimumamountCreateInput, minimumamountUncheckedCreateInput>
  }

  /**
   * minimumamount createMany
   */
  export type minimumamountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many minimumamounts.
     */
    data: minimumamountCreateManyInput | minimumamountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * minimumamount update
   */
  export type minimumamountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the minimumamount
     */
    select?: minimumamountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the minimumamount
     */
    omit?: minimumamountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: minimumamountInclude<ExtArgs> | null
    /**
     * The data needed to update a minimumamount.
     */
    data: XOR<minimumamountUpdateInput, minimumamountUncheckedUpdateInput>
    /**
     * Choose, which minimumamount to update.
     */
    where: minimumamountWhereUniqueInput
  }

  /**
   * minimumamount updateMany
   */
  export type minimumamountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update minimumamounts.
     */
    data: XOR<minimumamountUpdateManyMutationInput, minimumamountUncheckedUpdateManyInput>
    /**
     * Filter which minimumamounts to update
     */
    where?: minimumamountWhereInput
    /**
     * Limit how many minimumamounts to update.
     */
    limit?: number
  }

  /**
   * minimumamount upsert
   */
  export type minimumamountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the minimumamount
     */
    select?: minimumamountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the minimumamount
     */
    omit?: minimumamountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: minimumamountInclude<ExtArgs> | null
    /**
     * The filter to search for the minimumamount to update in case it exists.
     */
    where: minimumamountWhereUniqueInput
    /**
     * In case the minimumamount found by the `where` argument doesn't exist, create a new minimumamount with this data.
     */
    create: XOR<minimumamountCreateInput, minimumamountUncheckedCreateInput>
    /**
     * In case the minimumamount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<minimumamountUpdateInput, minimumamountUncheckedUpdateInput>
  }

  /**
   * minimumamount delete
   */
  export type minimumamountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the minimumamount
     */
    select?: minimumamountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the minimumamount
     */
    omit?: minimumamountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: minimumamountInclude<ExtArgs> | null
    /**
     * Filter which minimumamount to delete.
     */
    where: minimumamountWhereUniqueInput
  }

  /**
   * minimumamount deleteMany
   */
  export type minimumamountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which minimumamounts to delete
     */
    where?: minimumamountWhereInput
    /**
     * Limit how many minimumamounts to delete.
     */
    limit?: number
  }

  /**
   * minimumamount without action
   */
  export type minimumamountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the minimumamount
     */
    select?: minimumamountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the minimumamount
     */
    omit?: minimumamountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: minimumamountInclude<ExtArgs> | null
  }


  /**
   * Model note
   */

  export type AggregateNote = {
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  export type NoteAvgAggregateOutputType = {
    NoteID: number | null
    AgentID: number | null
  }

  export type NoteSumAggregateOutputType = {
    NoteID: number | null
    AgentID: number | null
  }

  export type NoteMinAggregateOutputType = {
    NoteID: number | null
    Note: string | null
    Date: Date | null
    AgentID: number | null
  }

  export type NoteMaxAggregateOutputType = {
    NoteID: number | null
    Note: string | null
    Date: Date | null
    AgentID: number | null
  }

  export type NoteCountAggregateOutputType = {
    NoteID: number
    Note: number
    Date: number
    AgentID: number
    _all: number
  }


  export type NoteAvgAggregateInputType = {
    NoteID?: true
    AgentID?: true
  }

  export type NoteSumAggregateInputType = {
    NoteID?: true
    AgentID?: true
  }

  export type NoteMinAggregateInputType = {
    NoteID?: true
    Note?: true
    Date?: true
    AgentID?: true
  }

  export type NoteMaxAggregateInputType = {
    NoteID?: true
    Note?: true
    Date?: true
    AgentID?: true
  }

  export type NoteCountAggregateInputType = {
    NoteID?: true
    Note?: true
    Date?: true
    AgentID?: true
    _all?: true
  }

  export type NoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which note to aggregate.
     */
    where?: noteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: noteOrderByWithRelationInput | noteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: noteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notes
    **/
    _count?: true | NoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NoteMaxAggregateInputType
  }

  export type GetNoteAggregateType<T extends NoteAggregateArgs> = {
        [P in keyof T & keyof AggregateNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNote[P]>
      : GetScalarType<T[P], AggregateNote[P]>
  }




  export type noteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: noteWhereInput
    orderBy?: noteOrderByWithAggregationInput | noteOrderByWithAggregationInput[]
    by: NoteScalarFieldEnum[] | NoteScalarFieldEnum
    having?: noteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NoteCountAggregateInputType | true
    _avg?: NoteAvgAggregateInputType
    _sum?: NoteSumAggregateInputType
    _min?: NoteMinAggregateInputType
    _max?: NoteMaxAggregateInputType
  }

  export type NoteGroupByOutputType = {
    NoteID: number
    Note: string | null
    Date: Date | null
    AgentID: number | null
    _count: NoteCountAggregateOutputType | null
    _avg: NoteAvgAggregateOutputType | null
    _sum: NoteSumAggregateOutputType | null
    _min: NoteMinAggregateOutputType | null
    _max: NoteMaxAggregateOutputType | null
  }

  type GetNoteGroupByPayload<T extends noteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NoteGroupByOutputType[P]>
            : GetScalarType<T[P], NoteGroupByOutputType[P]>
        }
      >
    >


  export type noteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    NoteID?: boolean
    Note?: boolean
    Date?: boolean
    AgentID?: boolean
    agent?: boolean | note$agentArgs<ExtArgs>
    transactions?: boolean | note$transactionsArgs<ExtArgs>
    _count?: boolean | NoteCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["note"]>



  export type noteSelectScalar = {
    NoteID?: boolean
    Note?: boolean
    Date?: boolean
    AgentID?: boolean
  }

  export type noteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"NoteID" | "Note" | "Date" | "AgentID", ExtArgs["result"]["note"]>
  export type noteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | note$agentArgs<ExtArgs>
    transactions?: boolean | note$transactionsArgs<ExtArgs>
    _count?: boolean | NoteCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $notePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "note"
    objects: {
      agent: Prisma.$agentPayload<ExtArgs> | null
      transactions: Prisma.$transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      NoteID: number
      Note: string | null
      Date: Date | null
      AgentID: number | null
    }, ExtArgs["result"]["note"]>
    composites: {}
  }

  type noteGetPayload<S extends boolean | null | undefined | noteDefaultArgs> = $Result.GetResult<Prisma.$notePayload, S>

  type noteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<noteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NoteCountAggregateInputType | true
    }

  export interface noteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['note'], meta: { name: 'note' } }
    /**
     * Find zero or one Note that matches the filter.
     * @param {noteFindUniqueArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends noteFindUniqueArgs>(args: SelectSubset<T, noteFindUniqueArgs<ExtArgs>>): Prisma__noteClient<$Result.GetResult<Prisma.$notePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Note that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {noteFindUniqueOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends noteFindUniqueOrThrowArgs>(args: SelectSubset<T, noteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__noteClient<$Result.GetResult<Prisma.$notePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Note that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteFindFirstArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends noteFindFirstArgs>(args?: SelectSubset<T, noteFindFirstArgs<ExtArgs>>): Prisma__noteClient<$Result.GetResult<Prisma.$notePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Note that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteFindFirstOrThrowArgs} args - Arguments to find a Note
     * @example
     * // Get one Note
     * const note = await prisma.note.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends noteFindFirstOrThrowArgs>(args?: SelectSubset<T, noteFindFirstOrThrowArgs<ExtArgs>>): Prisma__noteClient<$Result.GetResult<Prisma.$notePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notes
     * const notes = await prisma.note.findMany()
     * 
     * // Get first 10 Notes
     * const notes = await prisma.note.findMany({ take: 10 })
     * 
     * // Only select the `NoteID`
     * const noteWithNoteIDOnly = await prisma.note.findMany({ select: { NoteID: true } })
     * 
     */
    findMany<T extends noteFindManyArgs>(args?: SelectSubset<T, noteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$notePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Note.
     * @param {noteCreateArgs} args - Arguments to create a Note.
     * @example
     * // Create one Note
     * const Note = await prisma.note.create({
     *   data: {
     *     // ... data to create a Note
     *   }
     * })
     * 
     */
    create<T extends noteCreateArgs>(args: SelectSubset<T, noteCreateArgs<ExtArgs>>): Prisma__noteClient<$Result.GetResult<Prisma.$notePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notes.
     * @param {noteCreateManyArgs} args - Arguments to create many Notes.
     * @example
     * // Create many Notes
     * const note = await prisma.note.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends noteCreateManyArgs>(args?: SelectSubset<T, noteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Note.
     * @param {noteDeleteArgs} args - Arguments to delete one Note.
     * @example
     * // Delete one Note
     * const Note = await prisma.note.delete({
     *   where: {
     *     // ... filter to delete one Note
     *   }
     * })
     * 
     */
    delete<T extends noteDeleteArgs>(args: SelectSubset<T, noteDeleteArgs<ExtArgs>>): Prisma__noteClient<$Result.GetResult<Prisma.$notePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Note.
     * @param {noteUpdateArgs} args - Arguments to update one Note.
     * @example
     * // Update one Note
     * const note = await prisma.note.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends noteUpdateArgs>(args: SelectSubset<T, noteUpdateArgs<ExtArgs>>): Prisma__noteClient<$Result.GetResult<Prisma.$notePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notes.
     * @param {noteDeleteManyArgs} args - Arguments to filter Notes to delete.
     * @example
     * // Delete a few Notes
     * const { count } = await prisma.note.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends noteDeleteManyArgs>(args?: SelectSubset<T, noteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notes
     * const note = await prisma.note.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends noteUpdateManyArgs>(args: SelectSubset<T, noteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Note.
     * @param {noteUpsertArgs} args - Arguments to update or create a Note.
     * @example
     * // Update or create a Note
     * const note = await prisma.note.upsert({
     *   create: {
     *     // ... data to create a Note
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Note we want to update
     *   }
     * })
     */
    upsert<T extends noteUpsertArgs>(args: SelectSubset<T, noteUpsertArgs<ExtArgs>>): Prisma__noteClient<$Result.GetResult<Prisma.$notePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteCountArgs} args - Arguments to filter Notes to count.
     * @example
     * // Count the number of Notes
     * const count = await prisma.note.count({
     *   where: {
     *     // ... the filter for the Notes we want to count
     *   }
     * })
    **/
    count<T extends noteCountArgs>(
      args?: Subset<T, noteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NoteAggregateArgs>(args: Subset<T, NoteAggregateArgs>): Prisma.PrismaPromise<GetNoteAggregateType<T>>

    /**
     * Group by Note.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {noteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends noteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: noteGroupByArgs['orderBy'] }
        : { orderBy?: noteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, noteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the note model
   */
  readonly fields: noteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for note.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__noteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends note$agentArgs<ExtArgs> = {}>(args?: Subset<T, note$agentArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    transactions<T extends note$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, note$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the note model
   */
  interface noteFieldRefs {
    readonly NoteID: FieldRef<"note", 'Int'>
    readonly Note: FieldRef<"note", 'String'>
    readonly Date: FieldRef<"note", 'DateTime'>
    readonly AgentID: FieldRef<"note", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * note findUnique
   */
  export type noteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
    /**
     * Filter, which note to fetch.
     */
    where: noteWhereUniqueInput
  }

  /**
   * note findUniqueOrThrow
   */
  export type noteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
    /**
     * Filter, which note to fetch.
     */
    where: noteWhereUniqueInput
  }

  /**
   * note findFirst
   */
  export type noteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
    /**
     * Filter, which note to fetch.
     */
    where?: noteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: noteOrderByWithRelationInput | noteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notes.
     */
    cursor?: noteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * note findFirstOrThrow
   */
  export type noteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
    /**
     * Filter, which note to fetch.
     */
    where?: noteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: noteOrderByWithRelationInput | noteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notes.
     */
    cursor?: noteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notes.
     */
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * note findMany
   */
  export type noteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
    /**
     * Filter, which notes to fetch.
     */
    where?: noteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notes to fetch.
     */
    orderBy?: noteOrderByWithRelationInput | noteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notes.
     */
    cursor?: noteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notes.
     */
    skip?: number
    distinct?: NoteScalarFieldEnum | NoteScalarFieldEnum[]
  }

  /**
   * note create
   */
  export type noteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
    /**
     * The data needed to create a note.
     */
    data?: XOR<noteCreateInput, noteUncheckedCreateInput>
  }

  /**
   * note createMany
   */
  export type noteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many notes.
     */
    data: noteCreateManyInput | noteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * note update
   */
  export type noteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
    /**
     * The data needed to update a note.
     */
    data: XOR<noteUpdateInput, noteUncheckedUpdateInput>
    /**
     * Choose, which note to update.
     */
    where: noteWhereUniqueInput
  }

  /**
   * note updateMany
   */
  export type noteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update notes.
     */
    data: XOR<noteUpdateManyMutationInput, noteUncheckedUpdateManyInput>
    /**
     * Filter which notes to update
     */
    where?: noteWhereInput
    /**
     * Limit how many notes to update.
     */
    limit?: number
  }

  /**
   * note upsert
   */
  export type noteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
    /**
     * The filter to search for the note to update in case it exists.
     */
    where: noteWhereUniqueInput
    /**
     * In case the note found by the `where` argument doesn't exist, create a new note with this data.
     */
    create: XOR<noteCreateInput, noteUncheckedCreateInput>
    /**
     * In case the note was found with the provided `where` argument, update it with this data.
     */
    update: XOR<noteUpdateInput, noteUncheckedUpdateInput>
  }

  /**
   * note delete
   */
  export type noteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
    /**
     * Filter which note to delete.
     */
    where: noteWhereUniqueInput
  }

  /**
   * note deleteMany
   */
  export type noteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which notes to delete
     */
    where?: noteWhereInput
    /**
     * Limit how many notes to delete.
     */
    limit?: number
  }

  /**
   * note.agent
   */
  export type note$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    where?: agentWhereInput
  }

  /**
   * note.transactions
   */
  export type note$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * note without action
   */
  export type noteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
  }


  /**
   * Model platform
   */

  export type AggregatePlatform = {
    _count: PlatformCountAggregateOutputType | null
    _avg: PlatformAvgAggregateOutputType | null
    _sum: PlatformSumAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  export type PlatformAvgAggregateOutputType = {
    PlatformID: number | null
  }

  export type PlatformSumAggregateOutputType = {
    PlatformID: number | null
  }

  export type PlatformMinAggregateOutputType = {
    PlatformID: number | null
    PlatformName: string | null
  }

  export type PlatformMaxAggregateOutputType = {
    PlatformID: number | null
    PlatformName: string | null
  }

  export type PlatformCountAggregateOutputType = {
    PlatformID: number
    PlatformName: number
    _all: number
  }


  export type PlatformAvgAggregateInputType = {
    PlatformID?: true
  }

  export type PlatformSumAggregateInputType = {
    PlatformID?: true
  }

  export type PlatformMinAggregateInputType = {
    PlatformID?: true
    PlatformName?: true
  }

  export type PlatformMaxAggregateInputType = {
    PlatformID?: true
    PlatformName?: true
  }

  export type PlatformCountAggregateInputType = {
    PlatformID?: true
    PlatformName?: true
    _all?: true
  }

  export type PlatformAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which platform to aggregate.
     */
    where?: platformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platforms to fetch.
     */
    orderBy?: platformOrderByWithRelationInput | platformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: platformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned platforms
    **/
    _count?: true | PlatformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformMaxAggregateInputType
  }

  export type GetPlatformAggregateType<T extends PlatformAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatform[P]>
      : GetScalarType<T[P], AggregatePlatform[P]>
  }




  export type platformGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: platformWhereInput
    orderBy?: platformOrderByWithAggregationInput | platformOrderByWithAggregationInput[]
    by: PlatformScalarFieldEnum[] | PlatformScalarFieldEnum
    having?: platformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformCountAggregateInputType | true
    _avg?: PlatformAvgAggregateInputType
    _sum?: PlatformSumAggregateInputType
    _min?: PlatformMinAggregateInputType
    _max?: PlatformMaxAggregateInputType
  }

  export type PlatformGroupByOutputType = {
    PlatformID: number
    PlatformName: string
    _count: PlatformCountAggregateOutputType | null
    _avg: PlatformAvgAggregateOutputType | null
    _sum: PlatformSumAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  type GetPlatformGroupByPayload<T extends platformGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformGroupByOutputType[P]>
        }
      >
    >


  export type platformSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    PlatformID?: boolean
    PlatformName?: boolean
  }, ExtArgs["result"]["platform"]>



  export type platformSelectScalar = {
    PlatformID?: boolean
    PlatformName?: boolean
  }

  export type platformOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"PlatformID" | "PlatformName", ExtArgs["result"]["platform"]>

  export type $platformPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "platform"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      PlatformID: number
      PlatformName: string
    }, ExtArgs["result"]["platform"]>
    composites: {}
  }

  type platformGetPayload<S extends boolean | null | undefined | platformDefaultArgs> = $Result.GetResult<Prisma.$platformPayload, S>

  type platformCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<platformFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformCountAggregateInputType | true
    }

  export interface platformDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['platform'], meta: { name: 'platform' } }
    /**
     * Find zero or one Platform that matches the filter.
     * @param {platformFindUniqueArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends platformFindUniqueArgs>(args: SelectSubset<T, platformFindUniqueArgs<ExtArgs>>): Prisma__platformClient<$Result.GetResult<Prisma.$platformPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Platform that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {platformFindUniqueOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends platformFindUniqueOrThrowArgs>(args: SelectSubset<T, platformFindUniqueOrThrowArgs<ExtArgs>>): Prisma__platformClient<$Result.GetResult<Prisma.$platformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platformFindFirstArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends platformFindFirstArgs>(args?: SelectSubset<T, platformFindFirstArgs<ExtArgs>>): Prisma__platformClient<$Result.GetResult<Prisma.$platformPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platformFindFirstOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends platformFindFirstOrThrowArgs>(args?: SelectSubset<T, platformFindFirstOrThrowArgs<ExtArgs>>): Prisma__platformClient<$Result.GetResult<Prisma.$platformPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Platforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platformFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Platforms
     * const platforms = await prisma.platform.findMany()
     * 
     * // Get first 10 Platforms
     * const platforms = await prisma.platform.findMany({ take: 10 })
     * 
     * // Only select the `PlatformID`
     * const platformWithPlatformIDOnly = await prisma.platform.findMany({ select: { PlatformID: true } })
     * 
     */
    findMany<T extends platformFindManyArgs>(args?: SelectSubset<T, platformFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$platformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Platform.
     * @param {platformCreateArgs} args - Arguments to create a Platform.
     * @example
     * // Create one Platform
     * const Platform = await prisma.platform.create({
     *   data: {
     *     // ... data to create a Platform
     *   }
     * })
     * 
     */
    create<T extends platformCreateArgs>(args: SelectSubset<T, platformCreateArgs<ExtArgs>>): Prisma__platformClient<$Result.GetResult<Prisma.$platformPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Platforms.
     * @param {platformCreateManyArgs} args - Arguments to create many Platforms.
     * @example
     * // Create many Platforms
     * const platform = await prisma.platform.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends platformCreateManyArgs>(args?: SelectSubset<T, platformCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Platform.
     * @param {platformDeleteArgs} args - Arguments to delete one Platform.
     * @example
     * // Delete one Platform
     * const Platform = await prisma.platform.delete({
     *   where: {
     *     // ... filter to delete one Platform
     *   }
     * })
     * 
     */
    delete<T extends platformDeleteArgs>(args: SelectSubset<T, platformDeleteArgs<ExtArgs>>): Prisma__platformClient<$Result.GetResult<Prisma.$platformPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Platform.
     * @param {platformUpdateArgs} args - Arguments to update one Platform.
     * @example
     * // Update one Platform
     * const platform = await prisma.platform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends platformUpdateArgs>(args: SelectSubset<T, platformUpdateArgs<ExtArgs>>): Prisma__platformClient<$Result.GetResult<Prisma.$platformPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Platforms.
     * @param {platformDeleteManyArgs} args - Arguments to filter Platforms to delete.
     * @example
     * // Delete a few Platforms
     * const { count } = await prisma.platform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends platformDeleteManyArgs>(args?: SelectSubset<T, platformDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends platformUpdateManyArgs>(args: SelectSubset<T, platformUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Platform.
     * @param {platformUpsertArgs} args - Arguments to update or create a Platform.
     * @example
     * // Update or create a Platform
     * const platform = await prisma.platform.upsert({
     *   create: {
     *     // ... data to create a Platform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Platform we want to update
     *   }
     * })
     */
    upsert<T extends platformUpsertArgs>(args: SelectSubset<T, platformUpsertArgs<ExtArgs>>): Prisma__platformClient<$Result.GetResult<Prisma.$platformPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platformCountArgs} args - Arguments to filter Platforms to count.
     * @example
     * // Count the number of Platforms
     * const count = await prisma.platform.count({
     *   where: {
     *     // ... the filter for the Platforms we want to count
     *   }
     * })
    **/
    count<T extends platformCountArgs>(
      args?: Subset<T, platformCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformAggregateArgs>(args: Subset<T, PlatformAggregateArgs>): Prisma.PrismaPromise<GetPlatformAggregateType<T>>

    /**
     * Group by Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {platformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends platformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: platformGroupByArgs['orderBy'] }
        : { orderBy?: platformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, platformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the platform model
   */
  readonly fields: platformFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for platform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__platformClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the platform model
   */
  interface platformFieldRefs {
    readonly PlatformID: FieldRef<"platform", 'Int'>
    readonly PlatformName: FieldRef<"platform", 'String'>
  }
    

  // Custom InputTypes
  /**
   * platform findUnique
   */
  export type platformFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform
     */
    select?: platformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the platform
     */
    omit?: platformOmit<ExtArgs> | null
    /**
     * Filter, which platform to fetch.
     */
    where: platformWhereUniqueInput
  }

  /**
   * platform findUniqueOrThrow
   */
  export type platformFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform
     */
    select?: platformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the platform
     */
    omit?: platformOmit<ExtArgs> | null
    /**
     * Filter, which platform to fetch.
     */
    where: platformWhereUniqueInput
  }

  /**
   * platform findFirst
   */
  export type platformFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform
     */
    select?: platformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the platform
     */
    omit?: platformOmit<ExtArgs> | null
    /**
     * Filter, which platform to fetch.
     */
    where?: platformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platforms to fetch.
     */
    orderBy?: platformOrderByWithRelationInput | platformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for platforms.
     */
    cursor?: platformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * platform findFirstOrThrow
   */
  export type platformFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform
     */
    select?: platformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the platform
     */
    omit?: platformOmit<ExtArgs> | null
    /**
     * Filter, which platform to fetch.
     */
    where?: platformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platforms to fetch.
     */
    orderBy?: platformOrderByWithRelationInput | platformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for platforms.
     */
    cursor?: platformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * platform findMany
   */
  export type platformFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform
     */
    select?: platformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the platform
     */
    omit?: platformOmit<ExtArgs> | null
    /**
     * Filter, which platforms to fetch.
     */
    where?: platformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of platforms to fetch.
     */
    orderBy?: platformOrderByWithRelationInput | platformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing platforms.
     */
    cursor?: platformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` platforms.
     */
    skip?: number
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * platform create
   */
  export type platformCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform
     */
    select?: platformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the platform
     */
    omit?: platformOmit<ExtArgs> | null
    /**
     * The data needed to create a platform.
     */
    data: XOR<platformCreateInput, platformUncheckedCreateInput>
  }

  /**
   * platform createMany
   */
  export type platformCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many platforms.
     */
    data: platformCreateManyInput | platformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * platform update
   */
  export type platformUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform
     */
    select?: platformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the platform
     */
    omit?: platformOmit<ExtArgs> | null
    /**
     * The data needed to update a platform.
     */
    data: XOR<platformUpdateInput, platformUncheckedUpdateInput>
    /**
     * Choose, which platform to update.
     */
    where: platformWhereUniqueInput
  }

  /**
   * platform updateMany
   */
  export type platformUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update platforms.
     */
    data: XOR<platformUpdateManyMutationInput, platformUncheckedUpdateManyInput>
    /**
     * Filter which platforms to update
     */
    where?: platformWhereInput
    /**
     * Limit how many platforms to update.
     */
    limit?: number
  }

  /**
   * platform upsert
   */
  export type platformUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform
     */
    select?: platformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the platform
     */
    omit?: platformOmit<ExtArgs> | null
    /**
     * The filter to search for the platform to update in case it exists.
     */
    where: platformWhereUniqueInput
    /**
     * In case the platform found by the `where` argument doesn't exist, create a new platform with this data.
     */
    create: XOR<platformCreateInput, platformUncheckedCreateInput>
    /**
     * In case the platform was found with the provided `where` argument, update it with this data.
     */
    update: XOR<platformUpdateInput, platformUncheckedUpdateInput>
  }

  /**
   * platform delete
   */
  export type platformDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform
     */
    select?: platformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the platform
     */
    omit?: platformOmit<ExtArgs> | null
    /**
     * Filter which platform to delete.
     */
    where: platformWhereUniqueInput
  }

  /**
   * platform deleteMany
   */
  export type platformDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which platforms to delete
     */
    where?: platformWhereInput
    /**
     * Limit how many platforms to delete.
     */
    limit?: number
  }

  /**
   * platform without action
   */
  export type platformDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the platform
     */
    select?: platformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the platform
     */
    omit?: platformOmit<ExtArgs> | null
  }


  /**
   * Model screenshot
   */

  export type AggregateScreenshot = {
    _count: ScreenshotCountAggregateOutputType | null
    _avg: ScreenshotAvgAggregateOutputType | null
    _sum: ScreenshotSumAggregateOutputType | null
    _min: ScreenshotMinAggregateOutputType | null
    _max: ScreenshotMaxAggregateOutputType | null
  }

  export type ScreenshotAvgAggregateOutputType = {
    ScreenShotID: number | null
    TransactionID: number | null
  }

  export type ScreenshotSumAggregateOutputType = {
    ScreenShotID: number | null
    TransactionID: number | null
  }

  export type ScreenshotMinAggregateOutputType = {
    ScreenShotID: number | null
    TransactionID: number | null
    ScreenShotLink: string | null
  }

  export type ScreenshotMaxAggregateOutputType = {
    ScreenShotID: number | null
    TransactionID: number | null
    ScreenShotLink: string | null
  }

  export type ScreenshotCountAggregateOutputType = {
    ScreenShotID: number
    TransactionID: number
    ScreenShotLink: number
    _all: number
  }


  export type ScreenshotAvgAggregateInputType = {
    ScreenShotID?: true
    TransactionID?: true
  }

  export type ScreenshotSumAggregateInputType = {
    ScreenShotID?: true
    TransactionID?: true
  }

  export type ScreenshotMinAggregateInputType = {
    ScreenShotID?: true
    TransactionID?: true
    ScreenShotLink?: true
  }

  export type ScreenshotMaxAggregateInputType = {
    ScreenShotID?: true
    TransactionID?: true
    ScreenShotLink?: true
  }

  export type ScreenshotCountAggregateInputType = {
    ScreenShotID?: true
    TransactionID?: true
    ScreenShotLink?: true
    _all?: true
  }

  export type ScreenshotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which screenshot to aggregate.
     */
    where?: screenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of screenshots to fetch.
     */
    orderBy?: screenshotOrderByWithRelationInput | screenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: screenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned screenshots
    **/
    _count?: true | ScreenshotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScreenshotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScreenshotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScreenshotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScreenshotMaxAggregateInputType
  }

  export type GetScreenshotAggregateType<T extends ScreenshotAggregateArgs> = {
        [P in keyof T & keyof AggregateScreenshot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScreenshot[P]>
      : GetScalarType<T[P], AggregateScreenshot[P]>
  }




  export type screenshotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: screenshotWhereInput
    orderBy?: screenshotOrderByWithAggregationInput | screenshotOrderByWithAggregationInput[]
    by: ScreenshotScalarFieldEnum[] | ScreenshotScalarFieldEnum
    having?: screenshotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScreenshotCountAggregateInputType | true
    _avg?: ScreenshotAvgAggregateInputType
    _sum?: ScreenshotSumAggregateInputType
    _min?: ScreenshotMinAggregateInputType
    _max?: ScreenshotMaxAggregateInputType
  }

  export type ScreenshotGroupByOutputType = {
    ScreenShotID: number
    TransactionID: number | null
    ScreenShotLink: string | null
    _count: ScreenshotCountAggregateOutputType | null
    _avg: ScreenshotAvgAggregateOutputType | null
    _sum: ScreenshotSumAggregateOutputType | null
    _min: ScreenshotMinAggregateOutputType | null
    _max: ScreenshotMaxAggregateOutputType | null
  }

  type GetScreenshotGroupByPayload<T extends screenshotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScreenshotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScreenshotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScreenshotGroupByOutputType[P]>
            : GetScalarType<T[P], ScreenshotGroupByOutputType[P]>
        }
      >
    >


  export type screenshotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ScreenShotID?: boolean
    TransactionID?: boolean
    ScreenShotLink?: boolean
    transactions?: boolean | screenshot$transactionsArgs<ExtArgs>
  }, ExtArgs["result"]["screenshot"]>



  export type screenshotSelectScalar = {
    ScreenShotID?: boolean
    TransactionID?: boolean
    ScreenShotLink?: boolean
  }

  export type screenshotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"ScreenShotID" | "TransactionID" | "ScreenShotLink", ExtArgs["result"]["screenshot"]>
  export type screenshotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | screenshot$transactionsArgs<ExtArgs>
  }

  export type $screenshotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "screenshot"
    objects: {
      transactions: Prisma.$transactionsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      ScreenShotID: number
      TransactionID: number | null
      ScreenShotLink: string | null
    }, ExtArgs["result"]["screenshot"]>
    composites: {}
  }

  type screenshotGetPayload<S extends boolean | null | undefined | screenshotDefaultArgs> = $Result.GetResult<Prisma.$screenshotPayload, S>

  type screenshotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<screenshotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScreenshotCountAggregateInputType | true
    }

  export interface screenshotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['screenshot'], meta: { name: 'screenshot' } }
    /**
     * Find zero or one Screenshot that matches the filter.
     * @param {screenshotFindUniqueArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends screenshotFindUniqueArgs>(args: SelectSubset<T, screenshotFindUniqueArgs<ExtArgs>>): Prisma__screenshotClient<$Result.GetResult<Prisma.$screenshotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Screenshot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {screenshotFindUniqueOrThrowArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends screenshotFindUniqueOrThrowArgs>(args: SelectSubset<T, screenshotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__screenshotClient<$Result.GetResult<Prisma.$screenshotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Screenshot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {screenshotFindFirstArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends screenshotFindFirstArgs>(args?: SelectSubset<T, screenshotFindFirstArgs<ExtArgs>>): Prisma__screenshotClient<$Result.GetResult<Prisma.$screenshotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Screenshot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {screenshotFindFirstOrThrowArgs} args - Arguments to find a Screenshot
     * @example
     * // Get one Screenshot
     * const screenshot = await prisma.screenshot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends screenshotFindFirstOrThrowArgs>(args?: SelectSubset<T, screenshotFindFirstOrThrowArgs<ExtArgs>>): Prisma__screenshotClient<$Result.GetResult<Prisma.$screenshotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Screenshots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {screenshotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Screenshots
     * const screenshots = await prisma.screenshot.findMany()
     * 
     * // Get first 10 Screenshots
     * const screenshots = await prisma.screenshot.findMany({ take: 10 })
     * 
     * // Only select the `ScreenShotID`
     * const screenshotWithScreenShotIDOnly = await prisma.screenshot.findMany({ select: { ScreenShotID: true } })
     * 
     */
    findMany<T extends screenshotFindManyArgs>(args?: SelectSubset<T, screenshotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$screenshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Screenshot.
     * @param {screenshotCreateArgs} args - Arguments to create a Screenshot.
     * @example
     * // Create one Screenshot
     * const Screenshot = await prisma.screenshot.create({
     *   data: {
     *     // ... data to create a Screenshot
     *   }
     * })
     * 
     */
    create<T extends screenshotCreateArgs>(args: SelectSubset<T, screenshotCreateArgs<ExtArgs>>): Prisma__screenshotClient<$Result.GetResult<Prisma.$screenshotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Screenshots.
     * @param {screenshotCreateManyArgs} args - Arguments to create many Screenshots.
     * @example
     * // Create many Screenshots
     * const screenshot = await prisma.screenshot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends screenshotCreateManyArgs>(args?: SelectSubset<T, screenshotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Screenshot.
     * @param {screenshotDeleteArgs} args - Arguments to delete one Screenshot.
     * @example
     * // Delete one Screenshot
     * const Screenshot = await prisma.screenshot.delete({
     *   where: {
     *     // ... filter to delete one Screenshot
     *   }
     * })
     * 
     */
    delete<T extends screenshotDeleteArgs>(args: SelectSubset<T, screenshotDeleteArgs<ExtArgs>>): Prisma__screenshotClient<$Result.GetResult<Prisma.$screenshotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Screenshot.
     * @param {screenshotUpdateArgs} args - Arguments to update one Screenshot.
     * @example
     * // Update one Screenshot
     * const screenshot = await prisma.screenshot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends screenshotUpdateArgs>(args: SelectSubset<T, screenshotUpdateArgs<ExtArgs>>): Prisma__screenshotClient<$Result.GetResult<Prisma.$screenshotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Screenshots.
     * @param {screenshotDeleteManyArgs} args - Arguments to filter Screenshots to delete.
     * @example
     * // Delete a few Screenshots
     * const { count } = await prisma.screenshot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends screenshotDeleteManyArgs>(args?: SelectSubset<T, screenshotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {screenshotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Screenshots
     * const screenshot = await prisma.screenshot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends screenshotUpdateManyArgs>(args: SelectSubset<T, screenshotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Screenshot.
     * @param {screenshotUpsertArgs} args - Arguments to update or create a Screenshot.
     * @example
     * // Update or create a Screenshot
     * const screenshot = await prisma.screenshot.upsert({
     *   create: {
     *     // ... data to create a Screenshot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Screenshot we want to update
     *   }
     * })
     */
    upsert<T extends screenshotUpsertArgs>(args: SelectSubset<T, screenshotUpsertArgs<ExtArgs>>): Prisma__screenshotClient<$Result.GetResult<Prisma.$screenshotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Screenshots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {screenshotCountArgs} args - Arguments to filter Screenshots to count.
     * @example
     * // Count the number of Screenshots
     * const count = await prisma.screenshot.count({
     *   where: {
     *     // ... the filter for the Screenshots we want to count
     *   }
     * })
    **/
    count<T extends screenshotCountArgs>(
      args?: Subset<T, screenshotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScreenshotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Screenshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScreenshotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScreenshotAggregateArgs>(args: Subset<T, ScreenshotAggregateArgs>): Prisma.PrismaPromise<GetScreenshotAggregateType<T>>

    /**
     * Group by Screenshot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {screenshotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends screenshotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: screenshotGroupByArgs['orderBy'] }
        : { orderBy?: screenshotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, screenshotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScreenshotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the screenshot model
   */
  readonly fields: screenshotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for screenshot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__screenshotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends screenshot$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, screenshot$transactionsArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the screenshot model
   */
  interface screenshotFieldRefs {
    readonly ScreenShotID: FieldRef<"screenshot", 'Int'>
    readonly TransactionID: FieldRef<"screenshot", 'Int'>
    readonly ScreenShotLink: FieldRef<"screenshot", 'String'>
  }
    

  // Custom InputTypes
  /**
   * screenshot findUnique
   */
  export type screenshotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the screenshot
     */
    select?: screenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the screenshot
     */
    omit?: screenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: screenshotInclude<ExtArgs> | null
    /**
     * Filter, which screenshot to fetch.
     */
    where: screenshotWhereUniqueInput
  }

  /**
   * screenshot findUniqueOrThrow
   */
  export type screenshotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the screenshot
     */
    select?: screenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the screenshot
     */
    omit?: screenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: screenshotInclude<ExtArgs> | null
    /**
     * Filter, which screenshot to fetch.
     */
    where: screenshotWhereUniqueInput
  }

  /**
   * screenshot findFirst
   */
  export type screenshotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the screenshot
     */
    select?: screenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the screenshot
     */
    omit?: screenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: screenshotInclude<ExtArgs> | null
    /**
     * Filter, which screenshot to fetch.
     */
    where?: screenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of screenshots to fetch.
     */
    orderBy?: screenshotOrderByWithRelationInput | screenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for screenshots.
     */
    cursor?: screenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of screenshots.
     */
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * screenshot findFirstOrThrow
   */
  export type screenshotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the screenshot
     */
    select?: screenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the screenshot
     */
    omit?: screenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: screenshotInclude<ExtArgs> | null
    /**
     * Filter, which screenshot to fetch.
     */
    where?: screenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of screenshots to fetch.
     */
    orderBy?: screenshotOrderByWithRelationInput | screenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for screenshots.
     */
    cursor?: screenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` screenshots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of screenshots.
     */
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * screenshot findMany
   */
  export type screenshotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the screenshot
     */
    select?: screenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the screenshot
     */
    omit?: screenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: screenshotInclude<ExtArgs> | null
    /**
     * Filter, which screenshots to fetch.
     */
    where?: screenshotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of screenshots to fetch.
     */
    orderBy?: screenshotOrderByWithRelationInput | screenshotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing screenshots.
     */
    cursor?: screenshotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` screenshots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` screenshots.
     */
    skip?: number
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * screenshot create
   */
  export type screenshotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the screenshot
     */
    select?: screenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the screenshot
     */
    omit?: screenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: screenshotInclude<ExtArgs> | null
    /**
     * The data needed to create a screenshot.
     */
    data?: XOR<screenshotCreateInput, screenshotUncheckedCreateInput>
  }

  /**
   * screenshot createMany
   */
  export type screenshotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many screenshots.
     */
    data: screenshotCreateManyInput | screenshotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * screenshot update
   */
  export type screenshotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the screenshot
     */
    select?: screenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the screenshot
     */
    omit?: screenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: screenshotInclude<ExtArgs> | null
    /**
     * The data needed to update a screenshot.
     */
    data: XOR<screenshotUpdateInput, screenshotUncheckedUpdateInput>
    /**
     * Choose, which screenshot to update.
     */
    where: screenshotWhereUniqueInput
  }

  /**
   * screenshot updateMany
   */
  export type screenshotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update screenshots.
     */
    data: XOR<screenshotUpdateManyMutationInput, screenshotUncheckedUpdateManyInput>
    /**
     * Filter which screenshots to update
     */
    where?: screenshotWhereInput
    /**
     * Limit how many screenshots to update.
     */
    limit?: number
  }

  /**
   * screenshot upsert
   */
  export type screenshotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the screenshot
     */
    select?: screenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the screenshot
     */
    omit?: screenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: screenshotInclude<ExtArgs> | null
    /**
     * The filter to search for the screenshot to update in case it exists.
     */
    where: screenshotWhereUniqueInput
    /**
     * In case the screenshot found by the `where` argument doesn't exist, create a new screenshot with this data.
     */
    create: XOR<screenshotCreateInput, screenshotUncheckedCreateInput>
    /**
     * In case the screenshot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<screenshotUpdateInput, screenshotUncheckedUpdateInput>
  }

  /**
   * screenshot delete
   */
  export type screenshotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the screenshot
     */
    select?: screenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the screenshot
     */
    omit?: screenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: screenshotInclude<ExtArgs> | null
    /**
     * Filter which screenshot to delete.
     */
    where: screenshotWhereUniqueInput
  }

  /**
   * screenshot deleteMany
   */
  export type screenshotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which screenshots to delete
     */
    where?: screenshotWhereInput
    /**
     * Limit how many screenshots to delete.
     */
    limit?: number
  }

  /**
   * screenshot.transactions
   */
  export type screenshot$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
  }

  /**
   * screenshot without action
   */
  export type screenshotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the screenshot
     */
    select?: screenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the screenshot
     */
    omit?: screenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: screenshotInclude<ExtArgs> | null
  }


  /**
   * Model supportregion
   */

  export type AggregateSupportregion = {
    _count: SupportregionCountAggregateOutputType | null
    _avg: SupportregionAvgAggregateOutputType | null
    _sum: SupportregionSumAggregateOutputType | null
    _min: SupportregionMinAggregateOutputType | null
    _max: SupportregionMaxAggregateOutputType | null
  }

  export type SupportregionAvgAggregateOutputType = {
    SupportRegionID: number | null
  }

  export type SupportregionSumAggregateOutputType = {
    SupportRegionID: number | null
  }

  export type SupportregionMinAggregateOutputType = {
    SupportRegionID: number | null
    Region: string | null
  }

  export type SupportregionMaxAggregateOutputType = {
    SupportRegionID: number | null
    Region: string | null
  }

  export type SupportregionCountAggregateOutputType = {
    SupportRegionID: number
    Region: number
    _all: number
  }


  export type SupportregionAvgAggregateInputType = {
    SupportRegionID?: true
  }

  export type SupportregionSumAggregateInputType = {
    SupportRegionID?: true
  }

  export type SupportregionMinAggregateInputType = {
    SupportRegionID?: true
    Region?: true
  }

  export type SupportregionMaxAggregateInputType = {
    SupportRegionID?: true
    Region?: true
  }

  export type SupportregionCountAggregateInputType = {
    SupportRegionID?: true
    Region?: true
    _all?: true
  }

  export type SupportregionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supportregion to aggregate.
     */
    where?: supportregionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supportregions to fetch.
     */
    orderBy?: supportregionOrderByWithRelationInput | supportregionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: supportregionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supportregions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supportregions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned supportregions
    **/
    _count?: true | SupportregionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SupportregionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SupportregionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportregionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportregionMaxAggregateInputType
  }

  export type GetSupportregionAggregateType<T extends SupportregionAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportregion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportregion[P]>
      : GetScalarType<T[P], AggregateSupportregion[P]>
  }




  export type supportregionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: supportregionWhereInput
    orderBy?: supportregionOrderByWithAggregationInput | supportregionOrderByWithAggregationInput[]
    by: SupportregionScalarFieldEnum[] | SupportregionScalarFieldEnum
    having?: supportregionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportregionCountAggregateInputType | true
    _avg?: SupportregionAvgAggregateInputType
    _sum?: SupportregionSumAggregateInputType
    _min?: SupportregionMinAggregateInputType
    _max?: SupportregionMaxAggregateInputType
  }

  export type SupportregionGroupByOutputType = {
    SupportRegionID: number
    Region: string | null
    _count: SupportregionCountAggregateOutputType | null
    _avg: SupportregionAvgAggregateOutputType | null
    _sum: SupportregionSumAggregateOutputType | null
    _min: SupportregionMinAggregateOutputType | null
    _max: SupportregionMaxAggregateOutputType | null
  }

  type GetSupportregionGroupByPayload<T extends supportregionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportregionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportregionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportregionGroupByOutputType[P]>
            : GetScalarType<T[P], SupportregionGroupByOutputType[P]>
        }
      >
    >


  export type supportregionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    SupportRegionID?: boolean
    Region?: boolean
    transactions?: boolean | supportregion$transactionsArgs<ExtArgs>
    _count?: boolean | SupportregionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportregion"]>



  export type supportregionSelectScalar = {
    SupportRegionID?: boolean
    Region?: boolean
  }

  export type supportregionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"SupportRegionID" | "Region", ExtArgs["result"]["supportregion"]>
  export type supportregionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | supportregion$transactionsArgs<ExtArgs>
    _count?: boolean | SupportregionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $supportregionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "supportregion"
    objects: {
      transactions: Prisma.$transactionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      SupportRegionID: number
      Region: string | null
    }, ExtArgs["result"]["supportregion"]>
    composites: {}
  }

  type supportregionGetPayload<S extends boolean | null | undefined | supportregionDefaultArgs> = $Result.GetResult<Prisma.$supportregionPayload, S>

  type supportregionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<supportregionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportregionCountAggregateInputType | true
    }

  export interface supportregionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['supportregion'], meta: { name: 'supportregion' } }
    /**
     * Find zero or one Supportregion that matches the filter.
     * @param {supportregionFindUniqueArgs} args - Arguments to find a Supportregion
     * @example
     * // Get one Supportregion
     * const supportregion = await prisma.supportregion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends supportregionFindUniqueArgs>(args: SelectSubset<T, supportregionFindUniqueArgs<ExtArgs>>): Prisma__supportregionClient<$Result.GetResult<Prisma.$supportregionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Supportregion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {supportregionFindUniqueOrThrowArgs} args - Arguments to find a Supportregion
     * @example
     * // Get one Supportregion
     * const supportregion = await prisma.supportregion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends supportregionFindUniqueOrThrowArgs>(args: SelectSubset<T, supportregionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__supportregionClient<$Result.GetResult<Prisma.$supportregionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supportregion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportregionFindFirstArgs} args - Arguments to find a Supportregion
     * @example
     * // Get one Supportregion
     * const supportregion = await prisma.supportregion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends supportregionFindFirstArgs>(args?: SelectSubset<T, supportregionFindFirstArgs<ExtArgs>>): Prisma__supportregionClient<$Result.GetResult<Prisma.$supportregionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Supportregion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportregionFindFirstOrThrowArgs} args - Arguments to find a Supportregion
     * @example
     * // Get one Supportregion
     * const supportregion = await prisma.supportregion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends supportregionFindFirstOrThrowArgs>(args?: SelectSubset<T, supportregionFindFirstOrThrowArgs<ExtArgs>>): Prisma__supportregionClient<$Result.GetResult<Prisma.$supportregionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Supportregions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportregionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Supportregions
     * const supportregions = await prisma.supportregion.findMany()
     * 
     * // Get first 10 Supportregions
     * const supportregions = await prisma.supportregion.findMany({ take: 10 })
     * 
     * // Only select the `SupportRegionID`
     * const supportregionWithSupportRegionIDOnly = await prisma.supportregion.findMany({ select: { SupportRegionID: true } })
     * 
     */
    findMany<T extends supportregionFindManyArgs>(args?: SelectSubset<T, supportregionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$supportregionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Supportregion.
     * @param {supportregionCreateArgs} args - Arguments to create a Supportregion.
     * @example
     * // Create one Supportregion
     * const Supportregion = await prisma.supportregion.create({
     *   data: {
     *     // ... data to create a Supportregion
     *   }
     * })
     * 
     */
    create<T extends supportregionCreateArgs>(args: SelectSubset<T, supportregionCreateArgs<ExtArgs>>): Prisma__supportregionClient<$Result.GetResult<Prisma.$supportregionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Supportregions.
     * @param {supportregionCreateManyArgs} args - Arguments to create many Supportregions.
     * @example
     * // Create many Supportregions
     * const supportregion = await prisma.supportregion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends supportregionCreateManyArgs>(args?: SelectSubset<T, supportregionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supportregion.
     * @param {supportregionDeleteArgs} args - Arguments to delete one Supportregion.
     * @example
     * // Delete one Supportregion
     * const Supportregion = await prisma.supportregion.delete({
     *   where: {
     *     // ... filter to delete one Supportregion
     *   }
     * })
     * 
     */
    delete<T extends supportregionDeleteArgs>(args: SelectSubset<T, supportregionDeleteArgs<ExtArgs>>): Prisma__supportregionClient<$Result.GetResult<Prisma.$supportregionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Supportregion.
     * @param {supportregionUpdateArgs} args - Arguments to update one Supportregion.
     * @example
     * // Update one Supportregion
     * const supportregion = await prisma.supportregion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends supportregionUpdateArgs>(args: SelectSubset<T, supportregionUpdateArgs<ExtArgs>>): Prisma__supportregionClient<$Result.GetResult<Prisma.$supportregionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Supportregions.
     * @param {supportregionDeleteManyArgs} args - Arguments to filter Supportregions to delete.
     * @example
     * // Delete a few Supportregions
     * const { count } = await prisma.supportregion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends supportregionDeleteManyArgs>(args?: SelectSubset<T, supportregionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Supportregions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportregionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Supportregions
     * const supportregion = await prisma.supportregion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends supportregionUpdateManyArgs>(args: SelectSubset<T, supportregionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supportregion.
     * @param {supportregionUpsertArgs} args - Arguments to update or create a Supportregion.
     * @example
     * // Update or create a Supportregion
     * const supportregion = await prisma.supportregion.upsert({
     *   create: {
     *     // ... data to create a Supportregion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supportregion we want to update
     *   }
     * })
     */
    upsert<T extends supportregionUpsertArgs>(args: SelectSubset<T, supportregionUpsertArgs<ExtArgs>>): Prisma__supportregionClient<$Result.GetResult<Prisma.$supportregionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Supportregions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportregionCountArgs} args - Arguments to filter Supportregions to count.
     * @example
     * // Count the number of Supportregions
     * const count = await prisma.supportregion.count({
     *   where: {
     *     // ... the filter for the Supportregions we want to count
     *   }
     * })
    **/
    count<T extends supportregionCountArgs>(
      args?: Subset<T, supportregionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportregionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supportregion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportregionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportregionAggregateArgs>(args: Subset<T, SupportregionAggregateArgs>): Prisma.PrismaPromise<GetSupportregionAggregateType<T>>

    /**
     * Group by Supportregion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {supportregionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends supportregionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: supportregionGroupByArgs['orderBy'] }
        : { orderBy?: supportregionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, supportregionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportregionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the supportregion model
   */
  readonly fields: supportregionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for supportregion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__supportregionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends supportregion$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, supportregion$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the supportregion model
   */
  interface supportregionFieldRefs {
    readonly SupportRegionID: FieldRef<"supportregion", 'Int'>
    readonly Region: FieldRef<"supportregion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * supportregion findUnique
   */
  export type supportregionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supportregion
     */
    select?: supportregionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supportregion
     */
    omit?: supportregionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supportregionInclude<ExtArgs> | null
    /**
     * Filter, which supportregion to fetch.
     */
    where: supportregionWhereUniqueInput
  }

  /**
   * supportregion findUniqueOrThrow
   */
  export type supportregionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supportregion
     */
    select?: supportregionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supportregion
     */
    omit?: supportregionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supportregionInclude<ExtArgs> | null
    /**
     * Filter, which supportregion to fetch.
     */
    where: supportregionWhereUniqueInput
  }

  /**
   * supportregion findFirst
   */
  export type supportregionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supportregion
     */
    select?: supportregionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supportregion
     */
    omit?: supportregionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supportregionInclude<ExtArgs> | null
    /**
     * Filter, which supportregion to fetch.
     */
    where?: supportregionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supportregions to fetch.
     */
    orderBy?: supportregionOrderByWithRelationInput | supportregionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supportregions.
     */
    cursor?: supportregionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supportregions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supportregions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supportregions.
     */
    distinct?: SupportregionScalarFieldEnum | SupportregionScalarFieldEnum[]
  }

  /**
   * supportregion findFirstOrThrow
   */
  export type supportregionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supportregion
     */
    select?: supportregionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supportregion
     */
    omit?: supportregionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supportregionInclude<ExtArgs> | null
    /**
     * Filter, which supportregion to fetch.
     */
    where?: supportregionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supportregions to fetch.
     */
    orderBy?: supportregionOrderByWithRelationInput | supportregionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for supportregions.
     */
    cursor?: supportregionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supportregions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supportregions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of supportregions.
     */
    distinct?: SupportregionScalarFieldEnum | SupportregionScalarFieldEnum[]
  }

  /**
   * supportregion findMany
   */
  export type supportregionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supportregion
     */
    select?: supportregionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supportregion
     */
    omit?: supportregionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supportregionInclude<ExtArgs> | null
    /**
     * Filter, which supportregions to fetch.
     */
    where?: supportregionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of supportregions to fetch.
     */
    orderBy?: supportregionOrderByWithRelationInput | supportregionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing supportregions.
     */
    cursor?: supportregionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` supportregions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` supportregions.
     */
    skip?: number
    distinct?: SupportregionScalarFieldEnum | SupportregionScalarFieldEnum[]
  }

  /**
   * supportregion create
   */
  export type supportregionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supportregion
     */
    select?: supportregionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supportregion
     */
    omit?: supportregionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supportregionInclude<ExtArgs> | null
    /**
     * The data needed to create a supportregion.
     */
    data?: XOR<supportregionCreateInput, supportregionUncheckedCreateInput>
  }

  /**
   * supportregion createMany
   */
  export type supportregionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many supportregions.
     */
    data: supportregionCreateManyInput | supportregionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * supportregion update
   */
  export type supportregionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supportregion
     */
    select?: supportregionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supportregion
     */
    omit?: supportregionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supportregionInclude<ExtArgs> | null
    /**
     * The data needed to update a supportregion.
     */
    data: XOR<supportregionUpdateInput, supportregionUncheckedUpdateInput>
    /**
     * Choose, which supportregion to update.
     */
    where: supportregionWhereUniqueInput
  }

  /**
   * supportregion updateMany
   */
  export type supportregionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update supportregions.
     */
    data: XOR<supportregionUpdateManyMutationInput, supportregionUncheckedUpdateManyInput>
    /**
     * Filter which supportregions to update
     */
    where?: supportregionWhereInput
    /**
     * Limit how many supportregions to update.
     */
    limit?: number
  }

  /**
   * supportregion upsert
   */
  export type supportregionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supportregion
     */
    select?: supportregionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supportregion
     */
    omit?: supportregionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supportregionInclude<ExtArgs> | null
    /**
     * The filter to search for the supportregion to update in case it exists.
     */
    where: supportregionWhereUniqueInput
    /**
     * In case the supportregion found by the `where` argument doesn't exist, create a new supportregion with this data.
     */
    create: XOR<supportregionCreateInput, supportregionUncheckedCreateInput>
    /**
     * In case the supportregion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<supportregionUpdateInput, supportregionUncheckedUpdateInput>
  }

  /**
   * supportregion delete
   */
  export type supportregionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supportregion
     */
    select?: supportregionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supportregion
     */
    omit?: supportregionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supportregionInclude<ExtArgs> | null
    /**
     * Filter which supportregion to delete.
     */
    where: supportregionWhereUniqueInput
  }

  /**
   * supportregion deleteMany
   */
  export type supportregionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which supportregions to delete
     */
    where?: supportregionWhereInput
    /**
     * Limit how many supportregions to delete.
     */
    limit?: number
  }

  /**
   * supportregion.transactions
   */
  export type supportregion$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * supportregion without action
   */
  export type supportregionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supportregion
     */
    select?: supportregionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supportregion
     */
    omit?: supportregionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supportregionInclude<ExtArgs> | null
  }


  /**
   * Model transactionagent
   */

  export type AggregateTransactionagent = {
    _count: TransactionagentCountAggregateOutputType | null
    _avg: TransactionagentAvgAggregateOutputType | null
    _sum: TransactionagentSumAggregateOutputType | null
    _min: TransactionagentMinAggregateOutputType | null
    _max: TransactionagentMaxAggregateOutputType | null
  }

  export type TransactionagentAvgAggregateOutputType = {
    TransactionAgentID: number | null
    TransactionID: number | null
    AgentID: number | null
  }

  export type TransactionagentSumAggregateOutputType = {
    TransactionAgentID: number | null
    TransactionID: number | null
    AgentID: number | null
  }

  export type TransactionagentMinAggregateOutputType = {
    TransactionAgentID: number | null
    TransactionID: number | null
    AgentID: number | null
    LogDate: Date | null
  }

  export type TransactionagentMaxAggregateOutputType = {
    TransactionAgentID: number | null
    TransactionID: number | null
    AgentID: number | null
    LogDate: Date | null
  }

  export type TransactionagentCountAggregateOutputType = {
    TransactionAgentID: number
    TransactionID: number
    AgentID: number
    LogDate: number
    _all: number
  }


  export type TransactionagentAvgAggregateInputType = {
    TransactionAgentID?: true
    TransactionID?: true
    AgentID?: true
  }

  export type TransactionagentSumAggregateInputType = {
    TransactionAgentID?: true
    TransactionID?: true
    AgentID?: true
  }

  export type TransactionagentMinAggregateInputType = {
    TransactionAgentID?: true
    TransactionID?: true
    AgentID?: true
    LogDate?: true
  }

  export type TransactionagentMaxAggregateInputType = {
    TransactionAgentID?: true
    TransactionID?: true
    AgentID?: true
    LogDate?: true
  }

  export type TransactionagentCountAggregateInputType = {
    TransactionAgentID?: true
    TransactionID?: true
    AgentID?: true
    LogDate?: true
    _all?: true
  }

  export type TransactionagentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactionagent to aggregate.
     */
    where?: transactionagentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionagents to fetch.
     */
    orderBy?: transactionagentOrderByWithRelationInput | transactionagentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionagentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionagents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionagents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactionagents
    **/
    _count?: true | TransactionagentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionagentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionagentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionagentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionagentMaxAggregateInputType
  }

  export type GetTransactionagentAggregateType<T extends TransactionagentAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionagent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionagent[P]>
      : GetScalarType<T[P], AggregateTransactionagent[P]>
  }




  export type transactionagentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionagentWhereInput
    orderBy?: transactionagentOrderByWithAggregationInput | transactionagentOrderByWithAggregationInput[]
    by: TransactionagentScalarFieldEnum[] | TransactionagentScalarFieldEnum
    having?: transactionagentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionagentCountAggregateInputType | true
    _avg?: TransactionagentAvgAggregateInputType
    _sum?: TransactionagentSumAggregateInputType
    _min?: TransactionagentMinAggregateInputType
    _max?: TransactionagentMaxAggregateInputType
  }

  export type TransactionagentGroupByOutputType = {
    TransactionAgentID: number
    TransactionID: number | null
    AgentID: number | null
    LogDate: Date
    _count: TransactionagentCountAggregateOutputType | null
    _avg: TransactionagentAvgAggregateOutputType | null
    _sum: TransactionagentSumAggregateOutputType | null
    _min: TransactionagentMinAggregateOutputType | null
    _max: TransactionagentMaxAggregateOutputType | null
  }

  type GetTransactionagentGroupByPayload<T extends transactionagentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionagentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionagentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionagentGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionagentGroupByOutputType[P]>
        }
      >
    >


  export type transactionagentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TransactionAgentID?: boolean
    TransactionID?: boolean
    AgentID?: boolean
    LogDate?: boolean
    transactions?: boolean | transactionagent$transactionsArgs<ExtArgs>
    agent?: boolean | transactionagent$agentArgs<ExtArgs>
  }, ExtArgs["result"]["transactionagent"]>



  export type transactionagentSelectScalar = {
    TransactionAgentID?: boolean
    TransactionID?: boolean
    AgentID?: boolean
    LogDate?: boolean
  }

  export type transactionagentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"TransactionAgentID" | "TransactionID" | "AgentID" | "LogDate", ExtArgs["result"]["transactionagent"]>
  export type transactionagentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | transactionagent$transactionsArgs<ExtArgs>
    agent?: boolean | transactionagent$agentArgs<ExtArgs>
  }

  export type $transactionagentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transactionagent"
    objects: {
      transactions: Prisma.$transactionsPayload<ExtArgs> | null
      agent: Prisma.$agentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      TransactionAgentID: number
      TransactionID: number | null
      AgentID: number | null
      LogDate: Date
    }, ExtArgs["result"]["transactionagent"]>
    composites: {}
  }

  type transactionagentGetPayload<S extends boolean | null | undefined | transactionagentDefaultArgs> = $Result.GetResult<Prisma.$transactionagentPayload, S>

  type transactionagentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionagentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionagentCountAggregateInputType | true
    }

  export interface transactionagentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transactionagent'], meta: { name: 'transactionagent' } }
    /**
     * Find zero or one Transactionagent that matches the filter.
     * @param {transactionagentFindUniqueArgs} args - Arguments to find a Transactionagent
     * @example
     * // Get one Transactionagent
     * const transactionagent = await prisma.transactionagent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionagentFindUniqueArgs>(args: SelectSubset<T, transactionagentFindUniqueArgs<ExtArgs>>): Prisma__transactionagentClient<$Result.GetResult<Prisma.$transactionagentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactionagent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionagentFindUniqueOrThrowArgs} args - Arguments to find a Transactionagent
     * @example
     * // Get one Transactionagent
     * const transactionagent = await prisma.transactionagent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionagentFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionagentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionagentClient<$Result.GetResult<Prisma.$transactionagentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactionagent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionagentFindFirstArgs} args - Arguments to find a Transactionagent
     * @example
     * // Get one Transactionagent
     * const transactionagent = await prisma.transactionagent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionagentFindFirstArgs>(args?: SelectSubset<T, transactionagentFindFirstArgs<ExtArgs>>): Prisma__transactionagentClient<$Result.GetResult<Prisma.$transactionagentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactionagent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionagentFindFirstOrThrowArgs} args - Arguments to find a Transactionagent
     * @example
     * // Get one Transactionagent
     * const transactionagent = await prisma.transactionagent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionagentFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionagentFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionagentClient<$Result.GetResult<Prisma.$transactionagentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactionagents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionagentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactionagents
     * const transactionagents = await prisma.transactionagent.findMany()
     * 
     * // Get first 10 Transactionagents
     * const transactionagents = await prisma.transactionagent.findMany({ take: 10 })
     * 
     * // Only select the `TransactionAgentID`
     * const transactionagentWithTransactionAgentIDOnly = await prisma.transactionagent.findMany({ select: { TransactionAgentID: true } })
     * 
     */
    findMany<T extends transactionagentFindManyArgs>(args?: SelectSubset<T, transactionagentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionagentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactionagent.
     * @param {transactionagentCreateArgs} args - Arguments to create a Transactionagent.
     * @example
     * // Create one Transactionagent
     * const Transactionagent = await prisma.transactionagent.create({
     *   data: {
     *     // ... data to create a Transactionagent
     *   }
     * })
     * 
     */
    create<T extends transactionagentCreateArgs>(args: SelectSubset<T, transactionagentCreateArgs<ExtArgs>>): Prisma__transactionagentClient<$Result.GetResult<Prisma.$transactionagentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactionagents.
     * @param {transactionagentCreateManyArgs} args - Arguments to create many Transactionagents.
     * @example
     * // Create many Transactionagents
     * const transactionagent = await prisma.transactionagent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionagentCreateManyArgs>(args?: SelectSubset<T, transactionagentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transactionagent.
     * @param {transactionagentDeleteArgs} args - Arguments to delete one Transactionagent.
     * @example
     * // Delete one Transactionagent
     * const Transactionagent = await prisma.transactionagent.delete({
     *   where: {
     *     // ... filter to delete one Transactionagent
     *   }
     * })
     * 
     */
    delete<T extends transactionagentDeleteArgs>(args: SelectSubset<T, transactionagentDeleteArgs<ExtArgs>>): Prisma__transactionagentClient<$Result.GetResult<Prisma.$transactionagentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactionagent.
     * @param {transactionagentUpdateArgs} args - Arguments to update one Transactionagent.
     * @example
     * // Update one Transactionagent
     * const transactionagent = await prisma.transactionagent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionagentUpdateArgs>(args: SelectSubset<T, transactionagentUpdateArgs<ExtArgs>>): Prisma__transactionagentClient<$Result.GetResult<Prisma.$transactionagentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactionagents.
     * @param {transactionagentDeleteManyArgs} args - Arguments to filter Transactionagents to delete.
     * @example
     * // Delete a few Transactionagents
     * const { count } = await prisma.transactionagent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionagentDeleteManyArgs>(args?: SelectSubset<T, transactionagentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactionagents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionagentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactionagents
     * const transactionagent = await prisma.transactionagent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionagentUpdateManyArgs>(args: SelectSubset<T, transactionagentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transactionagent.
     * @param {transactionagentUpsertArgs} args - Arguments to update or create a Transactionagent.
     * @example
     * // Update or create a Transactionagent
     * const transactionagent = await prisma.transactionagent.upsert({
     *   create: {
     *     // ... data to create a Transactionagent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactionagent we want to update
     *   }
     * })
     */
    upsert<T extends transactionagentUpsertArgs>(args: SelectSubset<T, transactionagentUpsertArgs<ExtArgs>>): Prisma__transactionagentClient<$Result.GetResult<Prisma.$transactionagentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactionagents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionagentCountArgs} args - Arguments to filter Transactionagents to count.
     * @example
     * // Count the number of Transactionagents
     * const count = await prisma.transactionagent.count({
     *   where: {
     *     // ... the filter for the Transactionagents we want to count
     *   }
     * })
    **/
    count<T extends transactionagentCountArgs>(
      args?: Subset<T, transactionagentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionagentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactionagent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionagentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionagentAggregateArgs>(args: Subset<T, TransactionagentAggregateArgs>): Prisma.PrismaPromise<GetTransactionagentAggregateType<T>>

    /**
     * Group by Transactionagent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionagentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionagentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionagentGroupByArgs['orderBy'] }
        : { orderBy?: transactionagentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionagentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionagentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transactionagent model
   */
  readonly fields: transactionagentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transactionagent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionagentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends transactionagent$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, transactionagent$transactionsArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    agent<T extends transactionagent$agentArgs<ExtArgs> = {}>(args?: Subset<T, transactionagent$agentArgs<ExtArgs>>): Prisma__agentClient<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transactionagent model
   */
  interface transactionagentFieldRefs {
    readonly TransactionAgentID: FieldRef<"transactionagent", 'Int'>
    readonly TransactionID: FieldRef<"transactionagent", 'Int'>
    readonly AgentID: FieldRef<"transactionagent", 'Int'>
    readonly LogDate: FieldRef<"transactionagent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * transactionagent findUnique
   */
  export type transactionagentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
    /**
     * Filter, which transactionagent to fetch.
     */
    where: transactionagentWhereUniqueInput
  }

  /**
   * transactionagent findUniqueOrThrow
   */
  export type transactionagentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
    /**
     * Filter, which transactionagent to fetch.
     */
    where: transactionagentWhereUniqueInput
  }

  /**
   * transactionagent findFirst
   */
  export type transactionagentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
    /**
     * Filter, which transactionagent to fetch.
     */
    where?: transactionagentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionagents to fetch.
     */
    orderBy?: transactionagentOrderByWithRelationInput | transactionagentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionagents.
     */
    cursor?: transactionagentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionagents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionagents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionagents.
     */
    distinct?: TransactionagentScalarFieldEnum | TransactionagentScalarFieldEnum[]
  }

  /**
   * transactionagent findFirstOrThrow
   */
  export type transactionagentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
    /**
     * Filter, which transactionagent to fetch.
     */
    where?: transactionagentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionagents to fetch.
     */
    orderBy?: transactionagentOrderByWithRelationInput | transactionagentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionagents.
     */
    cursor?: transactionagentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionagents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionagents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionagents.
     */
    distinct?: TransactionagentScalarFieldEnum | TransactionagentScalarFieldEnum[]
  }

  /**
   * transactionagent findMany
   */
  export type transactionagentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
    /**
     * Filter, which transactionagents to fetch.
     */
    where?: transactionagentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionagents to fetch.
     */
    orderBy?: transactionagentOrderByWithRelationInput | transactionagentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactionagents.
     */
    cursor?: transactionagentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionagents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionagents.
     */
    skip?: number
    distinct?: TransactionagentScalarFieldEnum | TransactionagentScalarFieldEnum[]
  }

  /**
   * transactionagent create
   */
  export type transactionagentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
    /**
     * The data needed to create a transactionagent.
     */
    data?: XOR<transactionagentCreateInput, transactionagentUncheckedCreateInput>
  }

  /**
   * transactionagent createMany
   */
  export type transactionagentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactionagents.
     */
    data: transactionagentCreateManyInput | transactionagentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transactionagent update
   */
  export type transactionagentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
    /**
     * The data needed to update a transactionagent.
     */
    data: XOR<transactionagentUpdateInput, transactionagentUncheckedUpdateInput>
    /**
     * Choose, which transactionagent to update.
     */
    where: transactionagentWhereUniqueInput
  }

  /**
   * transactionagent updateMany
   */
  export type transactionagentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactionagents.
     */
    data: XOR<transactionagentUpdateManyMutationInput, transactionagentUncheckedUpdateManyInput>
    /**
     * Filter which transactionagents to update
     */
    where?: transactionagentWhereInput
    /**
     * Limit how many transactionagents to update.
     */
    limit?: number
  }

  /**
   * transactionagent upsert
   */
  export type transactionagentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
    /**
     * The filter to search for the transactionagent to update in case it exists.
     */
    where: transactionagentWhereUniqueInput
    /**
     * In case the transactionagent found by the `where` argument doesn't exist, create a new transactionagent with this data.
     */
    create: XOR<transactionagentCreateInput, transactionagentUncheckedCreateInput>
    /**
     * In case the transactionagent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionagentUpdateInput, transactionagentUncheckedUpdateInput>
  }

  /**
   * transactionagent delete
   */
  export type transactionagentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
    /**
     * Filter which transactionagent to delete.
     */
    where: transactionagentWhereUniqueInput
  }

  /**
   * transactionagent deleteMany
   */
  export type transactionagentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactionagents to delete
     */
    where?: transactionagentWhereInput
    /**
     * Limit how many transactionagents to delete.
     */
    limit?: number
  }

  /**
   * transactionagent.transactions
   */
  export type transactionagent$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
  }

  /**
   * transactionagent.agent
   */
  export type transactionagent$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    where?: agentWhereInput
  }

  /**
   * transactionagent without action
   */
  export type transactionagentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
  }


  /**
   * Model transactions
   */

  export type AggregateTransactions = {
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  export type TransactionsAvgAggregateOutputType = {
    TransactionID: number | null
    CustomerID: number | null
    SupportRegionID: number | null
    WalletID: number | null
    Amount: number | null
    NoteID: number | null
    Month: number | null
    HopeFuelID: number | null
  }

  export type TransactionsSumAggregateOutputType = {
    TransactionID: number | null
    CustomerID: number | null
    SupportRegionID: number | null
    WalletID: number | null
    Amount: number | null
    NoteID: number | null
    Month: number | null
    HopeFuelID: number | null
  }

  export type TransactionsMinAggregateOutputType = {
    TransactionID: number | null
    CustomerID: number | null
    SupportRegionID: number | null
    WalletID: number | null
    Amount: number | null
    PaymentCheck: boolean | null
    PaymentCheckTime: Date | null
    NoteID: number | null
    TransactionDate: Date | null
    PaymentDenied: boolean | null
    Month: number | null
    HopeFuelID: number | null
  }

  export type TransactionsMaxAggregateOutputType = {
    TransactionID: number | null
    CustomerID: number | null
    SupportRegionID: number | null
    WalletID: number | null
    Amount: number | null
    PaymentCheck: boolean | null
    PaymentCheckTime: Date | null
    NoteID: number | null
    TransactionDate: Date | null
    PaymentDenied: boolean | null
    Month: number | null
    HopeFuelID: number | null
  }

  export type TransactionsCountAggregateOutputType = {
    TransactionID: number
    CustomerID: number
    SupportRegionID: number
    WalletID: number
    Amount: number
    PaymentCheck: number
    PaymentCheckTime: number
    NoteID: number
    TransactionDate: number
    PaymentDenied: number
    Month: number
    HopeFuelID: number
    _all: number
  }


  export type TransactionsAvgAggregateInputType = {
    TransactionID?: true
    CustomerID?: true
    SupportRegionID?: true
    WalletID?: true
    Amount?: true
    NoteID?: true
    Month?: true
    HopeFuelID?: true
  }

  export type TransactionsSumAggregateInputType = {
    TransactionID?: true
    CustomerID?: true
    SupportRegionID?: true
    WalletID?: true
    Amount?: true
    NoteID?: true
    Month?: true
    HopeFuelID?: true
  }

  export type TransactionsMinAggregateInputType = {
    TransactionID?: true
    CustomerID?: true
    SupportRegionID?: true
    WalletID?: true
    Amount?: true
    PaymentCheck?: true
    PaymentCheckTime?: true
    NoteID?: true
    TransactionDate?: true
    PaymentDenied?: true
    Month?: true
    HopeFuelID?: true
  }

  export type TransactionsMaxAggregateInputType = {
    TransactionID?: true
    CustomerID?: true
    SupportRegionID?: true
    WalletID?: true
    Amount?: true
    PaymentCheck?: true
    PaymentCheckTime?: true
    NoteID?: true
    TransactionDate?: true
    PaymentDenied?: true
    Month?: true
    HopeFuelID?: true
  }

  export type TransactionsCountAggregateInputType = {
    TransactionID?: true
    CustomerID?: true
    SupportRegionID?: true
    WalletID?: true
    Amount?: true
    PaymentCheck?: true
    PaymentCheckTime?: true
    NoteID?: true
    TransactionDate?: true
    PaymentDenied?: true
    Month?: true
    HopeFuelID?: true
    _all?: true
  }

  export type TransactionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to aggregate.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactions
    **/
    _count?: true | TransactionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionsMaxAggregateInputType
  }

  export type GetTransactionsAggregateType<T extends TransactionsAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactions[P]>
      : GetScalarType<T[P], AggregateTransactions[P]>
  }




  export type transactionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithAggregationInput | transactionsOrderByWithAggregationInput[]
    by: TransactionsScalarFieldEnum[] | TransactionsScalarFieldEnum
    having?: transactionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionsCountAggregateInputType | true
    _avg?: TransactionsAvgAggregateInputType
    _sum?: TransactionsSumAggregateInputType
    _min?: TransactionsMinAggregateInputType
    _max?: TransactionsMaxAggregateInputType
  }

  export type TransactionsGroupByOutputType = {
    TransactionID: number
    CustomerID: number | null
    SupportRegionID: number | null
    WalletID: number | null
    Amount: number | null
    PaymentCheck: boolean | null
    PaymentCheckTime: Date
    NoteID: number | null
    TransactionDate: Date
    PaymentDenied: boolean | null
    Month: number | null
    HopeFuelID: number | null
    _count: TransactionsCountAggregateOutputType | null
    _avg: TransactionsAvgAggregateOutputType | null
    _sum: TransactionsSumAggregateOutputType | null
    _min: TransactionsMinAggregateOutputType | null
    _max: TransactionsMaxAggregateOutputType | null
  }

  type GetTransactionsGroupByPayload<T extends transactionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionsGroupByOutputType[P]>
        }
      >
    >


  export type transactionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TransactionID?: boolean
    CustomerID?: boolean
    SupportRegionID?: boolean
    WalletID?: boolean
    Amount?: boolean
    PaymentCheck?: boolean
    PaymentCheckTime?: boolean
    NoteID?: boolean
    TransactionDate?: boolean
    PaymentDenied?: boolean
    Month?: boolean
    HopeFuelID?: boolean
    formstatus?: boolean | transactions$formstatusArgs<ExtArgs>
    screenshot?: boolean | transactions$screenshotArgs<ExtArgs>
    transactionagent?: boolean | transactions$transactionagentArgs<ExtArgs>
    customer?: boolean | transactions$customerArgs<ExtArgs>
    supportregion?: boolean | transactions$supportregionArgs<ExtArgs>
    wallet?: boolean | transactions$walletArgs<ExtArgs>
    note?: boolean | transactions$noteArgs<ExtArgs>
    _count?: boolean | TransactionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactions"]>



  export type transactionsSelectScalar = {
    TransactionID?: boolean
    CustomerID?: boolean
    SupportRegionID?: boolean
    WalletID?: boolean
    Amount?: boolean
    PaymentCheck?: boolean
    PaymentCheckTime?: boolean
    NoteID?: boolean
    TransactionDate?: boolean
    PaymentDenied?: boolean
    Month?: boolean
    HopeFuelID?: boolean
  }

  export type transactionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"TransactionID" | "CustomerID" | "SupportRegionID" | "WalletID" | "Amount" | "PaymentCheck" | "PaymentCheckTime" | "NoteID" | "TransactionDate" | "PaymentDenied" | "Month" | "HopeFuelID", ExtArgs["result"]["transactions"]>
  export type transactionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formstatus?: boolean | transactions$formstatusArgs<ExtArgs>
    screenshot?: boolean | transactions$screenshotArgs<ExtArgs>
    transactionagent?: boolean | transactions$transactionagentArgs<ExtArgs>
    customer?: boolean | transactions$customerArgs<ExtArgs>
    supportregion?: boolean | transactions$supportregionArgs<ExtArgs>
    wallet?: boolean | transactions$walletArgs<ExtArgs>
    note?: boolean | transactions$noteArgs<ExtArgs>
    _count?: boolean | TransactionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $transactionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transactions"
    objects: {
      formstatus: Prisma.$formstatusPayload<ExtArgs>[]
      screenshot: Prisma.$screenshotPayload<ExtArgs>[]
      transactionagent: Prisma.$transactionagentPayload<ExtArgs>[]
      customer: Prisma.$customerPayload<ExtArgs> | null
      supportregion: Prisma.$supportregionPayload<ExtArgs> | null
      wallet: Prisma.$walletPayload<ExtArgs> | null
      note: Prisma.$notePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      TransactionID: number
      CustomerID: number | null
      SupportRegionID: number | null
      WalletID: number | null
      Amount: number | null
      PaymentCheck: boolean | null
      PaymentCheckTime: Date
      NoteID: number | null
      TransactionDate: Date
      PaymentDenied: boolean | null
      Month: number | null
      HopeFuelID: number | null
    }, ExtArgs["result"]["transactions"]>
    composites: {}
  }

  type transactionsGetPayload<S extends boolean | null | undefined | transactionsDefaultArgs> = $Result.GetResult<Prisma.$transactionsPayload, S>

  type transactionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionsCountAggregateInputType | true
    }

  export interface transactionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transactions'], meta: { name: 'transactions' } }
    /**
     * Find zero or one Transactions that matches the filter.
     * @param {transactionsFindUniqueArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionsFindUniqueArgs>(args: SelectSubset<T, transactionsFindUniqueArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionsFindUniqueOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionsFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionsFindFirstArgs>(args?: SelectSubset<T, transactionsFindFirstArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindFirstOrThrowArgs} args - Arguments to find a Transactions
     * @example
     * // Get one Transactions
     * const transactions = await prisma.transactions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionsFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transactions.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transactions.findMany({ take: 10 })
     * 
     * // Only select the `TransactionID`
     * const transactionsWithTransactionIDOnly = await prisma.transactions.findMany({ select: { TransactionID: true } })
     * 
     */
    findMany<T extends transactionsFindManyArgs>(args?: SelectSubset<T, transactionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactions.
     * @param {transactionsCreateArgs} args - Arguments to create a Transactions.
     * @example
     * // Create one Transactions
     * const Transactions = await prisma.transactions.create({
     *   data: {
     *     // ... data to create a Transactions
     *   }
     * })
     * 
     */
    create<T extends transactionsCreateArgs>(args: SelectSubset<T, transactionsCreateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {transactionsCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transactions = await prisma.transactions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionsCreateManyArgs>(args?: SelectSubset<T, transactionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transactions.
     * @param {transactionsDeleteArgs} args - Arguments to delete one Transactions.
     * @example
     * // Delete one Transactions
     * const Transactions = await prisma.transactions.delete({
     *   where: {
     *     // ... filter to delete one Transactions
     *   }
     * })
     * 
     */
    delete<T extends transactionsDeleteArgs>(args: SelectSubset<T, transactionsDeleteArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactions.
     * @param {transactionsUpdateArgs} args - Arguments to update one Transactions.
     * @example
     * // Update one Transactions
     * const transactions = await prisma.transactions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionsUpdateArgs>(args: SelectSubset<T, transactionsUpdateArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {transactionsDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transactions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionsDeleteManyArgs>(args?: SelectSubset<T, transactionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transactions = await prisma.transactions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionsUpdateManyArgs>(args: SelectSubset<T, transactionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transactions.
     * @param {transactionsUpsertArgs} args - Arguments to update or create a Transactions.
     * @example
     * // Update or create a Transactions
     * const transactions = await prisma.transactions.upsert({
     *   create: {
     *     // ... data to create a Transactions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactions we want to update
     *   }
     * })
     */
    upsert<T extends transactionsUpsertArgs>(args: SelectSubset<T, transactionsUpsertArgs<ExtArgs>>): Prisma__transactionsClient<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transactions.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends transactionsCountArgs>(
      args?: Subset<T, transactionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionsAggregateArgs>(args: Subset<T, TransactionsAggregateArgs>): Prisma.PrismaPromise<GetTransactionsAggregateType<T>>

    /**
     * Group by Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionsGroupByArgs['orderBy'] }
        : { orderBy?: transactionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transactions model
   */
  readonly fields: transactionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transactions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    formstatus<T extends transactions$formstatusArgs<ExtArgs> = {}>(args?: Subset<T, transactions$formstatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formstatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    screenshot<T extends transactions$screenshotArgs<ExtArgs> = {}>(args?: Subset<T, transactions$screenshotArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$screenshotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactionagent<T extends transactions$transactionagentArgs<ExtArgs> = {}>(args?: Subset<T, transactions$transactionagentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionagentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customer<T extends transactions$customerArgs<ExtArgs> = {}>(args?: Subset<T, transactions$customerArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    supportregion<T extends transactions$supportregionArgs<ExtArgs> = {}>(args?: Subset<T, transactions$supportregionArgs<ExtArgs>>): Prisma__supportregionClient<$Result.GetResult<Prisma.$supportregionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wallet<T extends transactions$walletArgs<ExtArgs> = {}>(args?: Subset<T, transactions$walletArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    note<T extends transactions$noteArgs<ExtArgs> = {}>(args?: Subset<T, transactions$noteArgs<ExtArgs>>): Prisma__noteClient<$Result.GetResult<Prisma.$notePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transactions model
   */
  interface transactionsFieldRefs {
    readonly TransactionID: FieldRef<"transactions", 'Int'>
    readonly CustomerID: FieldRef<"transactions", 'Int'>
    readonly SupportRegionID: FieldRef<"transactions", 'Int'>
    readonly WalletID: FieldRef<"transactions", 'Int'>
    readonly Amount: FieldRef<"transactions", 'Float'>
    readonly PaymentCheck: FieldRef<"transactions", 'Boolean'>
    readonly PaymentCheckTime: FieldRef<"transactions", 'DateTime'>
    readonly NoteID: FieldRef<"transactions", 'Int'>
    readonly TransactionDate: FieldRef<"transactions", 'DateTime'>
    readonly PaymentDenied: FieldRef<"transactions", 'Boolean'>
    readonly Month: FieldRef<"transactions", 'Int'>
    readonly HopeFuelID: FieldRef<"transactions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * transactions findUnique
   */
  export type transactionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findUniqueOrThrow
   */
  export type transactionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions findFirst
   */
  export type transactionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findFirstOrThrow
   */
  export type transactionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactions.
     */
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions findMany
   */
  export type transactionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter, which transactions to fetch.
     */
    where?: transactionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactions to fetch.
     */
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactions.
     */
    cursor?: transactionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactions.
     */
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * transactions create
   */
  export type transactionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The data needed to create a transactions.
     */
    data?: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
  }

  /**
   * transactions createMany
   */
  export type transactionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactions.
     */
    data: transactionsCreateManyInput | transactionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transactions update
   */
  export type transactionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The data needed to update a transactions.
     */
    data: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
    /**
     * Choose, which transactions to update.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions updateMany
   */
  export type transactionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactions.
     */
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyInput>
    /**
     * Filter which transactions to update
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to update.
     */
    limit?: number
  }

  /**
   * transactions upsert
   */
  export type transactionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * The filter to search for the transactions to update in case it exists.
     */
    where: transactionsWhereUniqueInput
    /**
     * In case the transactions found by the `where` argument doesn't exist, create a new transactions with this data.
     */
    create: XOR<transactionsCreateInput, transactionsUncheckedCreateInput>
    /**
     * In case the transactions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionsUpdateInput, transactionsUncheckedUpdateInput>
  }

  /**
   * transactions delete
   */
  export type transactionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    /**
     * Filter which transactions to delete.
     */
    where: transactionsWhereUniqueInput
  }

  /**
   * transactions deleteMany
   */
  export type transactionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactions to delete
     */
    where?: transactionsWhereInput
    /**
     * Limit how many transactions to delete.
     */
    limit?: number
  }

  /**
   * transactions.formstatus
   */
  export type transactions$formstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
    where?: formstatusWhereInput
    orderBy?: formstatusOrderByWithRelationInput | formstatusOrderByWithRelationInput[]
    cursor?: formstatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormstatusScalarFieldEnum | FormstatusScalarFieldEnum[]
  }

  /**
   * transactions.screenshot
   */
  export type transactions$screenshotArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the screenshot
     */
    select?: screenshotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the screenshot
     */
    omit?: screenshotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: screenshotInclude<ExtArgs> | null
    where?: screenshotWhereInput
    orderBy?: screenshotOrderByWithRelationInput | screenshotOrderByWithRelationInput[]
    cursor?: screenshotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScreenshotScalarFieldEnum | ScreenshotScalarFieldEnum[]
  }

  /**
   * transactions.transactionagent
   */
  export type transactions$transactionagentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionagent
     */
    select?: transactionagentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionagent
     */
    omit?: transactionagentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionagentInclude<ExtArgs> | null
    where?: transactionagentWhereInput
    orderBy?: transactionagentOrderByWithRelationInput | transactionagentOrderByWithRelationInput[]
    cursor?: transactionagentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionagentScalarFieldEnum | TransactionagentScalarFieldEnum[]
  }

  /**
   * transactions.customer
   */
  export type transactions$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
  }

  /**
   * transactions.supportregion
   */
  export type transactions$supportregionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the supportregion
     */
    select?: supportregionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the supportregion
     */
    omit?: supportregionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: supportregionInclude<ExtArgs> | null
    where?: supportregionWhereInput
  }

  /**
   * transactions.wallet
   */
  export type transactions$walletArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    where?: walletWhereInput
  }

  /**
   * transactions.note
   */
  export type transactions$noteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the note
     */
    select?: noteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the note
     */
    omit?: noteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: noteInclude<ExtArgs> | null
    where?: noteWhereInput
  }

  /**
   * transactions without action
   */
  export type transactionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
  }


  /**
   * Model transactionstatus
   */

  export type AggregateTransactionstatus = {
    _count: TransactionstatusCountAggregateOutputType | null
    _avg: TransactionstatusAvgAggregateOutputType | null
    _sum: TransactionstatusSumAggregateOutputType | null
    _min: TransactionstatusMinAggregateOutputType | null
    _max: TransactionstatusMaxAggregateOutputType | null
  }

  export type TransactionstatusAvgAggregateOutputType = {
    TransactionStatusID: number | null
  }

  export type TransactionstatusSumAggregateOutputType = {
    TransactionStatusID: number | null
  }

  export type TransactionstatusMinAggregateOutputType = {
    TransactionStatusID: number | null
    TransactionStatus: string | null
  }

  export type TransactionstatusMaxAggregateOutputType = {
    TransactionStatusID: number | null
    TransactionStatus: string | null
  }

  export type TransactionstatusCountAggregateOutputType = {
    TransactionStatusID: number
    TransactionStatus: number
    _all: number
  }


  export type TransactionstatusAvgAggregateInputType = {
    TransactionStatusID?: true
  }

  export type TransactionstatusSumAggregateInputType = {
    TransactionStatusID?: true
  }

  export type TransactionstatusMinAggregateInputType = {
    TransactionStatusID?: true
    TransactionStatus?: true
  }

  export type TransactionstatusMaxAggregateInputType = {
    TransactionStatusID?: true
    TransactionStatus?: true
  }

  export type TransactionstatusCountAggregateInputType = {
    TransactionStatusID?: true
    TransactionStatus?: true
    _all?: true
  }

  export type TransactionstatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactionstatus to aggregate.
     */
    where?: transactionstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionstatuses to fetch.
     */
    orderBy?: transactionstatusOrderByWithRelationInput | transactionstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: transactionstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned transactionstatuses
    **/
    _count?: true | TransactionstatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionstatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionstatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionstatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionstatusMaxAggregateInputType
  }

  export type GetTransactionstatusAggregateType<T extends TransactionstatusAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionstatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionstatus[P]>
      : GetScalarType<T[P], AggregateTransactionstatus[P]>
  }




  export type transactionstatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: transactionstatusWhereInput
    orderBy?: transactionstatusOrderByWithAggregationInput | transactionstatusOrderByWithAggregationInput[]
    by: TransactionstatusScalarFieldEnum[] | TransactionstatusScalarFieldEnum
    having?: transactionstatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionstatusCountAggregateInputType | true
    _avg?: TransactionstatusAvgAggregateInputType
    _sum?: TransactionstatusSumAggregateInputType
    _min?: TransactionstatusMinAggregateInputType
    _max?: TransactionstatusMaxAggregateInputType
  }

  export type TransactionstatusGroupByOutputType = {
    TransactionStatusID: number
    TransactionStatus: string
    _count: TransactionstatusCountAggregateOutputType | null
    _avg: TransactionstatusAvgAggregateOutputType | null
    _sum: TransactionstatusSumAggregateOutputType | null
    _min: TransactionstatusMinAggregateOutputType | null
    _max: TransactionstatusMaxAggregateOutputType | null
  }

  type GetTransactionstatusGroupByPayload<T extends transactionstatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionstatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionstatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionstatusGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionstatusGroupByOutputType[P]>
        }
      >
    >


  export type transactionstatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    TransactionStatusID?: boolean
    TransactionStatus?: boolean
    formstatus?: boolean | transactionstatus$formstatusArgs<ExtArgs>
    _count?: boolean | TransactionstatusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionstatus"]>



  export type transactionstatusSelectScalar = {
    TransactionStatusID?: boolean
    TransactionStatus?: boolean
  }

  export type transactionstatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"TransactionStatusID" | "TransactionStatus", ExtArgs["result"]["transactionstatus"]>
  export type transactionstatusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    formstatus?: boolean | transactionstatus$formstatusArgs<ExtArgs>
    _count?: boolean | TransactionstatusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $transactionstatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "transactionstatus"
    objects: {
      formstatus: Prisma.$formstatusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      TransactionStatusID: number
      TransactionStatus: string
    }, ExtArgs["result"]["transactionstatus"]>
    composites: {}
  }

  type transactionstatusGetPayload<S extends boolean | null | undefined | transactionstatusDefaultArgs> = $Result.GetResult<Prisma.$transactionstatusPayload, S>

  type transactionstatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<transactionstatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionstatusCountAggregateInputType | true
    }

  export interface transactionstatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['transactionstatus'], meta: { name: 'transactionstatus' } }
    /**
     * Find zero or one Transactionstatus that matches the filter.
     * @param {transactionstatusFindUniqueArgs} args - Arguments to find a Transactionstatus
     * @example
     * // Get one Transactionstatus
     * const transactionstatus = await prisma.transactionstatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends transactionstatusFindUniqueArgs>(args: SelectSubset<T, transactionstatusFindUniqueArgs<ExtArgs>>): Prisma__transactionstatusClient<$Result.GetResult<Prisma.$transactionstatusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transactionstatus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {transactionstatusFindUniqueOrThrowArgs} args - Arguments to find a Transactionstatus
     * @example
     * // Get one Transactionstatus
     * const transactionstatus = await prisma.transactionstatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends transactionstatusFindUniqueOrThrowArgs>(args: SelectSubset<T, transactionstatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__transactionstatusClient<$Result.GetResult<Prisma.$transactionstatusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactionstatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionstatusFindFirstArgs} args - Arguments to find a Transactionstatus
     * @example
     * // Get one Transactionstatus
     * const transactionstatus = await prisma.transactionstatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends transactionstatusFindFirstArgs>(args?: SelectSubset<T, transactionstatusFindFirstArgs<ExtArgs>>): Prisma__transactionstatusClient<$Result.GetResult<Prisma.$transactionstatusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transactionstatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionstatusFindFirstOrThrowArgs} args - Arguments to find a Transactionstatus
     * @example
     * // Get one Transactionstatus
     * const transactionstatus = await prisma.transactionstatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends transactionstatusFindFirstOrThrowArgs>(args?: SelectSubset<T, transactionstatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__transactionstatusClient<$Result.GetResult<Prisma.$transactionstatusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactionstatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionstatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactionstatuses
     * const transactionstatuses = await prisma.transactionstatus.findMany()
     * 
     * // Get first 10 Transactionstatuses
     * const transactionstatuses = await prisma.transactionstatus.findMany({ take: 10 })
     * 
     * // Only select the `TransactionStatusID`
     * const transactionstatusWithTransactionStatusIDOnly = await prisma.transactionstatus.findMany({ select: { TransactionStatusID: true } })
     * 
     */
    findMany<T extends transactionstatusFindManyArgs>(args?: SelectSubset<T, transactionstatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionstatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transactionstatus.
     * @param {transactionstatusCreateArgs} args - Arguments to create a Transactionstatus.
     * @example
     * // Create one Transactionstatus
     * const Transactionstatus = await prisma.transactionstatus.create({
     *   data: {
     *     // ... data to create a Transactionstatus
     *   }
     * })
     * 
     */
    create<T extends transactionstatusCreateArgs>(args: SelectSubset<T, transactionstatusCreateArgs<ExtArgs>>): Prisma__transactionstatusClient<$Result.GetResult<Prisma.$transactionstatusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactionstatuses.
     * @param {transactionstatusCreateManyArgs} args - Arguments to create many Transactionstatuses.
     * @example
     * // Create many Transactionstatuses
     * const transactionstatus = await prisma.transactionstatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends transactionstatusCreateManyArgs>(args?: SelectSubset<T, transactionstatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Transactionstatus.
     * @param {transactionstatusDeleteArgs} args - Arguments to delete one Transactionstatus.
     * @example
     * // Delete one Transactionstatus
     * const Transactionstatus = await prisma.transactionstatus.delete({
     *   where: {
     *     // ... filter to delete one Transactionstatus
     *   }
     * })
     * 
     */
    delete<T extends transactionstatusDeleteArgs>(args: SelectSubset<T, transactionstatusDeleteArgs<ExtArgs>>): Prisma__transactionstatusClient<$Result.GetResult<Prisma.$transactionstatusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transactionstatus.
     * @param {transactionstatusUpdateArgs} args - Arguments to update one Transactionstatus.
     * @example
     * // Update one Transactionstatus
     * const transactionstatus = await prisma.transactionstatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends transactionstatusUpdateArgs>(args: SelectSubset<T, transactionstatusUpdateArgs<ExtArgs>>): Prisma__transactionstatusClient<$Result.GetResult<Prisma.$transactionstatusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactionstatuses.
     * @param {transactionstatusDeleteManyArgs} args - Arguments to filter Transactionstatuses to delete.
     * @example
     * // Delete a few Transactionstatuses
     * const { count } = await prisma.transactionstatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends transactionstatusDeleteManyArgs>(args?: SelectSubset<T, transactionstatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactionstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionstatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactionstatuses
     * const transactionstatus = await prisma.transactionstatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends transactionstatusUpdateManyArgs>(args: SelectSubset<T, transactionstatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Transactionstatus.
     * @param {transactionstatusUpsertArgs} args - Arguments to update or create a Transactionstatus.
     * @example
     * // Update or create a Transactionstatus
     * const transactionstatus = await prisma.transactionstatus.upsert({
     *   create: {
     *     // ... data to create a Transactionstatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transactionstatus we want to update
     *   }
     * })
     */
    upsert<T extends transactionstatusUpsertArgs>(args: SelectSubset<T, transactionstatusUpsertArgs<ExtArgs>>): Prisma__transactionstatusClient<$Result.GetResult<Prisma.$transactionstatusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactionstatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionstatusCountArgs} args - Arguments to filter Transactionstatuses to count.
     * @example
     * // Count the number of Transactionstatuses
     * const count = await prisma.transactionstatus.count({
     *   where: {
     *     // ... the filter for the Transactionstatuses we want to count
     *   }
     * })
    **/
    count<T extends transactionstatusCountArgs>(
      args?: Subset<T, transactionstatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionstatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transactionstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionstatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionstatusAggregateArgs>(args: Subset<T, TransactionstatusAggregateArgs>): Prisma.PrismaPromise<GetTransactionstatusAggregateType<T>>

    /**
     * Group by Transactionstatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {transactionstatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends transactionstatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: transactionstatusGroupByArgs['orderBy'] }
        : { orderBy?: transactionstatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, transactionstatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionstatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the transactionstatus model
   */
  readonly fields: transactionstatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for transactionstatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__transactionstatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    formstatus<T extends transactionstatus$formstatusArgs<ExtArgs> = {}>(args?: Subset<T, transactionstatus$formstatusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$formstatusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the transactionstatus model
   */
  interface transactionstatusFieldRefs {
    readonly TransactionStatusID: FieldRef<"transactionstatus", 'Int'>
    readonly TransactionStatus: FieldRef<"transactionstatus", 'String'>
  }
    

  // Custom InputTypes
  /**
   * transactionstatus findUnique
   */
  export type transactionstatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionstatus
     */
    select?: transactionstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionstatus
     */
    omit?: transactionstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionstatusInclude<ExtArgs> | null
    /**
     * Filter, which transactionstatus to fetch.
     */
    where: transactionstatusWhereUniqueInput
  }

  /**
   * transactionstatus findUniqueOrThrow
   */
  export type transactionstatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionstatus
     */
    select?: transactionstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionstatus
     */
    omit?: transactionstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionstatusInclude<ExtArgs> | null
    /**
     * Filter, which transactionstatus to fetch.
     */
    where: transactionstatusWhereUniqueInput
  }

  /**
   * transactionstatus findFirst
   */
  export type transactionstatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionstatus
     */
    select?: transactionstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionstatus
     */
    omit?: transactionstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionstatusInclude<ExtArgs> | null
    /**
     * Filter, which transactionstatus to fetch.
     */
    where?: transactionstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionstatuses to fetch.
     */
    orderBy?: transactionstatusOrderByWithRelationInput | transactionstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionstatuses.
     */
    cursor?: transactionstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionstatuses.
     */
    distinct?: TransactionstatusScalarFieldEnum | TransactionstatusScalarFieldEnum[]
  }

  /**
   * transactionstatus findFirstOrThrow
   */
  export type transactionstatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionstatus
     */
    select?: transactionstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionstatus
     */
    omit?: transactionstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionstatusInclude<ExtArgs> | null
    /**
     * Filter, which transactionstatus to fetch.
     */
    where?: transactionstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionstatuses to fetch.
     */
    orderBy?: transactionstatusOrderByWithRelationInput | transactionstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for transactionstatuses.
     */
    cursor?: transactionstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionstatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of transactionstatuses.
     */
    distinct?: TransactionstatusScalarFieldEnum | TransactionstatusScalarFieldEnum[]
  }

  /**
   * transactionstatus findMany
   */
  export type transactionstatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionstatus
     */
    select?: transactionstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionstatus
     */
    omit?: transactionstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionstatusInclude<ExtArgs> | null
    /**
     * Filter, which transactionstatuses to fetch.
     */
    where?: transactionstatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of transactionstatuses to fetch.
     */
    orderBy?: transactionstatusOrderByWithRelationInput | transactionstatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing transactionstatuses.
     */
    cursor?: transactionstatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` transactionstatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` transactionstatuses.
     */
    skip?: number
    distinct?: TransactionstatusScalarFieldEnum | TransactionstatusScalarFieldEnum[]
  }

  /**
   * transactionstatus create
   */
  export type transactionstatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionstatus
     */
    select?: transactionstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionstatus
     */
    omit?: transactionstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionstatusInclude<ExtArgs> | null
    /**
     * The data needed to create a transactionstatus.
     */
    data: XOR<transactionstatusCreateInput, transactionstatusUncheckedCreateInput>
  }

  /**
   * transactionstatus createMany
   */
  export type transactionstatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many transactionstatuses.
     */
    data: transactionstatusCreateManyInput | transactionstatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * transactionstatus update
   */
  export type transactionstatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionstatus
     */
    select?: transactionstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionstatus
     */
    omit?: transactionstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionstatusInclude<ExtArgs> | null
    /**
     * The data needed to update a transactionstatus.
     */
    data: XOR<transactionstatusUpdateInput, transactionstatusUncheckedUpdateInput>
    /**
     * Choose, which transactionstatus to update.
     */
    where: transactionstatusWhereUniqueInput
  }

  /**
   * transactionstatus updateMany
   */
  export type transactionstatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update transactionstatuses.
     */
    data: XOR<transactionstatusUpdateManyMutationInput, transactionstatusUncheckedUpdateManyInput>
    /**
     * Filter which transactionstatuses to update
     */
    where?: transactionstatusWhereInput
    /**
     * Limit how many transactionstatuses to update.
     */
    limit?: number
  }

  /**
   * transactionstatus upsert
   */
  export type transactionstatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionstatus
     */
    select?: transactionstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionstatus
     */
    omit?: transactionstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionstatusInclude<ExtArgs> | null
    /**
     * The filter to search for the transactionstatus to update in case it exists.
     */
    where: transactionstatusWhereUniqueInput
    /**
     * In case the transactionstatus found by the `where` argument doesn't exist, create a new transactionstatus with this data.
     */
    create: XOR<transactionstatusCreateInput, transactionstatusUncheckedCreateInput>
    /**
     * In case the transactionstatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<transactionstatusUpdateInput, transactionstatusUncheckedUpdateInput>
  }

  /**
   * transactionstatus delete
   */
  export type transactionstatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionstatus
     */
    select?: transactionstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionstatus
     */
    omit?: transactionstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionstatusInclude<ExtArgs> | null
    /**
     * Filter which transactionstatus to delete.
     */
    where: transactionstatusWhereUniqueInput
  }

  /**
   * transactionstatus deleteMany
   */
  export type transactionstatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which transactionstatuses to delete
     */
    where?: transactionstatusWhereInput
    /**
     * Limit how many transactionstatuses to delete.
     */
    limit?: number
  }

  /**
   * transactionstatus.formstatus
   */
  export type transactionstatus$formstatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the formstatus
     */
    select?: formstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the formstatus
     */
    omit?: formstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: formstatusInclude<ExtArgs> | null
    where?: formstatusWhereInput
    orderBy?: formstatusOrderByWithRelationInput | formstatusOrderByWithRelationInput[]
    cursor?: formstatusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FormstatusScalarFieldEnum | FormstatusScalarFieldEnum[]
  }

  /**
   * transactionstatus without action
   */
  export type transactionstatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactionstatus
     */
    select?: transactionstatusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactionstatus
     */
    omit?: transactionstatusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionstatusInclude<ExtArgs> | null
  }


  /**
   * Model userrole
   */

  export type AggregateUserrole = {
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  export type UserroleAvgAggregateOutputType = {
    UserRoleID: number | null
  }

  export type UserroleSumAggregateOutputType = {
    UserRoleID: number | null
  }

  export type UserroleMinAggregateOutputType = {
    UserRoleID: number | null
    UserRole: string | null
  }

  export type UserroleMaxAggregateOutputType = {
    UserRoleID: number | null
    UserRole: string | null
  }

  export type UserroleCountAggregateOutputType = {
    UserRoleID: number
    UserRole: number
    _all: number
  }


  export type UserroleAvgAggregateInputType = {
    UserRoleID?: true
  }

  export type UserroleSumAggregateInputType = {
    UserRoleID?: true
  }

  export type UserroleMinAggregateInputType = {
    UserRoleID?: true
    UserRole?: true
  }

  export type UserroleMaxAggregateInputType = {
    UserRoleID?: true
    UserRole?: true
  }

  export type UserroleCountAggregateInputType = {
    UserRoleID?: true
    UserRole?: true
    _all?: true
  }

  export type UserroleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userrole to aggregate.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned userroles
    **/
    _count?: true | UserroleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserroleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserroleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserroleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserroleMaxAggregateInputType
  }

  export type GetUserroleAggregateType<T extends UserroleAggregateArgs> = {
        [P in keyof T & keyof AggregateUserrole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserrole[P]>
      : GetScalarType<T[P], AggregateUserrole[P]>
  }




  export type userroleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: userroleWhereInput
    orderBy?: userroleOrderByWithAggregationInput | userroleOrderByWithAggregationInput[]
    by: UserroleScalarFieldEnum[] | UserroleScalarFieldEnum
    having?: userroleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserroleCountAggregateInputType | true
    _avg?: UserroleAvgAggregateInputType
    _sum?: UserroleSumAggregateInputType
    _min?: UserroleMinAggregateInputType
    _max?: UserroleMaxAggregateInputType
  }

  export type UserroleGroupByOutputType = {
    UserRoleID: number
    UserRole: string | null
    _count: UserroleCountAggregateOutputType | null
    _avg: UserroleAvgAggregateOutputType | null
    _sum: UserroleSumAggregateOutputType | null
    _min: UserroleMinAggregateOutputType | null
    _max: UserroleMaxAggregateOutputType | null
  }

  type GetUserroleGroupByPayload<T extends userroleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserroleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserroleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserroleGroupByOutputType[P]>
            : GetScalarType<T[P], UserroleGroupByOutputType[P]>
        }
      >
    >


  export type userroleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    UserRoleID?: boolean
    UserRole?: boolean
    agent?: boolean | userrole$agentArgs<ExtArgs>
    _count?: boolean | UserroleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userrole"]>



  export type userroleSelectScalar = {
    UserRoleID?: boolean
    UserRole?: boolean
  }

  export type userroleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"UserRoleID" | "UserRole", ExtArgs["result"]["userrole"]>
  export type userroleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    agent?: boolean | userrole$agentArgs<ExtArgs>
    _count?: boolean | UserroleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $userrolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "userrole"
    objects: {
      agent: Prisma.$agentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      UserRoleID: number
      UserRole: string | null
    }, ExtArgs["result"]["userrole"]>
    composites: {}
  }

  type userroleGetPayload<S extends boolean | null | undefined | userroleDefaultArgs> = $Result.GetResult<Prisma.$userrolePayload, S>

  type userroleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<userroleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserroleCountAggregateInputType | true
    }

  export interface userroleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['userrole'], meta: { name: 'userrole' } }
    /**
     * Find zero or one Userrole that matches the filter.
     * @param {userroleFindUniqueArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends userroleFindUniqueArgs>(args: SelectSubset<T, userroleFindUniqueArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Userrole that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {userroleFindUniqueOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends userroleFindUniqueOrThrowArgs>(args: SelectSubset<T, userroleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userrole that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends userroleFindFirstArgs>(args?: SelectSubset<T, userroleFindFirstArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Userrole that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindFirstOrThrowArgs} args - Arguments to find a Userrole
     * @example
     * // Get one Userrole
     * const userrole = await prisma.userrole.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends userroleFindFirstOrThrowArgs>(args?: SelectSubset<T, userroleFindFirstOrThrowArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Userroles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Userroles
     * const userroles = await prisma.userrole.findMany()
     * 
     * // Get first 10 Userroles
     * const userroles = await prisma.userrole.findMany({ take: 10 })
     * 
     * // Only select the `UserRoleID`
     * const userroleWithUserRoleIDOnly = await prisma.userrole.findMany({ select: { UserRoleID: true } })
     * 
     */
    findMany<T extends userroleFindManyArgs>(args?: SelectSubset<T, userroleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Userrole.
     * @param {userroleCreateArgs} args - Arguments to create a Userrole.
     * @example
     * // Create one Userrole
     * const Userrole = await prisma.userrole.create({
     *   data: {
     *     // ... data to create a Userrole
     *   }
     * })
     * 
     */
    create<T extends userroleCreateArgs>(args: SelectSubset<T, userroleCreateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Userroles.
     * @param {userroleCreateManyArgs} args - Arguments to create many Userroles.
     * @example
     * // Create many Userroles
     * const userrole = await prisma.userrole.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends userroleCreateManyArgs>(args?: SelectSubset<T, userroleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Userrole.
     * @param {userroleDeleteArgs} args - Arguments to delete one Userrole.
     * @example
     * // Delete one Userrole
     * const Userrole = await prisma.userrole.delete({
     *   where: {
     *     // ... filter to delete one Userrole
     *   }
     * })
     * 
     */
    delete<T extends userroleDeleteArgs>(args: SelectSubset<T, userroleDeleteArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Userrole.
     * @param {userroleUpdateArgs} args - Arguments to update one Userrole.
     * @example
     * // Update one Userrole
     * const userrole = await prisma.userrole.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends userroleUpdateArgs>(args: SelectSubset<T, userroleUpdateArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Userroles.
     * @param {userroleDeleteManyArgs} args - Arguments to filter Userroles to delete.
     * @example
     * // Delete a few Userroles
     * const { count } = await prisma.userrole.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends userroleDeleteManyArgs>(args?: SelectSubset<T, userroleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Userroles
     * const userrole = await prisma.userrole.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends userroleUpdateManyArgs>(args: SelectSubset<T, userroleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Userrole.
     * @param {userroleUpsertArgs} args - Arguments to update or create a Userrole.
     * @example
     * // Update or create a Userrole
     * const userrole = await prisma.userrole.upsert({
     *   create: {
     *     // ... data to create a Userrole
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Userrole we want to update
     *   }
     * })
     */
    upsert<T extends userroleUpsertArgs>(args: SelectSubset<T, userroleUpsertArgs<ExtArgs>>): Prisma__userroleClient<$Result.GetResult<Prisma.$userrolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Userroles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleCountArgs} args - Arguments to filter Userroles to count.
     * @example
     * // Count the number of Userroles
     * const count = await prisma.userrole.count({
     *   where: {
     *     // ... the filter for the Userroles we want to count
     *   }
     * })
    **/
    count<T extends userroleCountArgs>(
      args?: Subset<T, userroleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserroleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserroleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserroleAggregateArgs>(args: Subset<T, UserroleAggregateArgs>): Prisma.PrismaPromise<GetUserroleAggregateType<T>>

    /**
     * Group by Userrole.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userroleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends userroleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: userroleGroupByArgs['orderBy'] }
        : { orderBy?: userroleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, userroleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserroleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the userrole model
   */
  readonly fields: userroleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for userrole.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__userroleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    agent<T extends userrole$agentArgs<ExtArgs> = {}>(args?: Subset<T, userrole$agentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$agentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the userrole model
   */
  interface userroleFieldRefs {
    readonly UserRoleID: FieldRef<"userrole", 'Int'>
    readonly UserRole: FieldRef<"userrole", 'String'>
  }
    

  // Custom InputTypes
  /**
   * userrole findUnique
   */
  export type userroleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findUniqueOrThrow
   */
  export type userroleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole findFirst
   */
  export type userroleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findFirstOrThrow
   */
  export type userroleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userrole to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of userroles.
     */
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole findMany
   */
  export type userroleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter, which userroles to fetch.
     */
    where?: userroleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of userroles to fetch.
     */
    orderBy?: userroleOrderByWithRelationInput | userroleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing userroles.
     */
    cursor?: userroleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` userroles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` userroles.
     */
    skip?: number
    distinct?: UserroleScalarFieldEnum | UserroleScalarFieldEnum[]
  }

  /**
   * userrole create
   */
  export type userroleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to create a userrole.
     */
    data?: XOR<userroleCreateInput, userroleUncheckedCreateInput>
  }

  /**
   * userrole createMany
   */
  export type userroleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many userroles.
     */
    data: userroleCreateManyInput | userroleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * userrole update
   */
  export type userroleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The data needed to update a userrole.
     */
    data: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
    /**
     * Choose, which userrole to update.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole updateMany
   */
  export type userroleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update userroles.
     */
    data: XOR<userroleUpdateManyMutationInput, userroleUncheckedUpdateManyInput>
    /**
     * Filter which userroles to update
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to update.
     */
    limit?: number
  }

  /**
   * userrole upsert
   */
  export type userroleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * The filter to search for the userrole to update in case it exists.
     */
    where: userroleWhereUniqueInput
    /**
     * In case the userrole found by the `where` argument doesn't exist, create a new userrole with this data.
     */
    create: XOR<userroleCreateInput, userroleUncheckedCreateInput>
    /**
     * In case the userrole was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userroleUpdateInput, userroleUncheckedUpdateInput>
  }

  /**
   * userrole delete
   */
  export type userroleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
    /**
     * Filter which userrole to delete.
     */
    where: userroleWhereUniqueInput
  }

  /**
   * userrole deleteMany
   */
  export type userroleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which userroles to delete
     */
    where?: userroleWhereInput
    /**
     * Limit how many userroles to delete.
     */
    limit?: number
  }

  /**
   * userrole.agent
   */
  export type userrole$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the agent
     */
    select?: agentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the agent
     */
    omit?: agentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: agentInclude<ExtArgs> | null
    where?: agentWhereInput
    orderBy?: agentOrderByWithRelationInput | agentOrderByWithRelationInput[]
    cursor?: agentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * userrole without action
   */
  export type userroleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the userrole
     */
    select?: userroleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the userrole
     */
    omit?: userroleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: userroleInclude<ExtArgs> | null
  }


  /**
   * Model wallet
   */

  export type AggregateWallet = {
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  export type WalletAvgAggregateOutputType = {
    WalletId: number | null
    CurrencyId: number | null
  }

  export type WalletSumAggregateOutputType = {
    WalletId: number | null
    CurrencyId: number | null
  }

  export type WalletMinAggregateOutputType = {
    WalletId: number | null
    CurrencyId: number | null
    WalletName: string | null
  }

  export type WalletMaxAggregateOutputType = {
    WalletId: number | null
    CurrencyId: number | null
    WalletName: string | null
  }

  export type WalletCountAggregateOutputType = {
    WalletId: number
    CurrencyId: number
    WalletName: number
    _all: number
  }


  export type WalletAvgAggregateInputType = {
    WalletId?: true
    CurrencyId?: true
  }

  export type WalletSumAggregateInputType = {
    WalletId?: true
    CurrencyId?: true
  }

  export type WalletMinAggregateInputType = {
    WalletId?: true
    CurrencyId?: true
    WalletName?: true
  }

  export type WalletMaxAggregateInputType = {
    WalletId?: true
    CurrencyId?: true
    WalletName?: true
  }

  export type WalletCountAggregateInputType = {
    WalletId?: true
    CurrencyId?: true
    WalletName?: true
    _all?: true
  }

  export type WalletAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallet to aggregate.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned wallets
    **/
    _count?: true | WalletCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WalletAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WalletSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WalletMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WalletMaxAggregateInputType
  }

  export type GetWalletAggregateType<T extends WalletAggregateArgs> = {
        [P in keyof T & keyof AggregateWallet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWallet[P]>
      : GetScalarType<T[P], AggregateWallet[P]>
  }




  export type walletGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: walletWhereInput
    orderBy?: walletOrderByWithAggregationInput | walletOrderByWithAggregationInput[]
    by: WalletScalarFieldEnum[] | WalletScalarFieldEnum
    having?: walletScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WalletCountAggregateInputType | true
    _avg?: WalletAvgAggregateInputType
    _sum?: WalletSumAggregateInputType
    _min?: WalletMinAggregateInputType
    _max?: WalletMaxAggregateInputType
  }

  export type WalletGroupByOutputType = {
    WalletId: number
    CurrencyId: number | null
    WalletName: string | null
    _count: WalletCountAggregateOutputType | null
    _avg: WalletAvgAggregateOutputType | null
    _sum: WalletSumAggregateOutputType | null
    _min: WalletMinAggregateOutputType | null
    _max: WalletMaxAggregateOutputType | null
  }

  type GetWalletGroupByPayload<T extends walletGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WalletGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WalletGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WalletGroupByOutputType[P]>
            : GetScalarType<T[P], WalletGroupByOutputType[P]>
        }
      >
    >


  export type walletSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    WalletId?: boolean
    CurrencyId?: boolean
    WalletName?: boolean
    transactions?: boolean | wallet$transactionsArgs<ExtArgs>
    currency?: boolean | wallet$currencyArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wallet"]>



  export type walletSelectScalar = {
    WalletId?: boolean
    CurrencyId?: boolean
    WalletName?: boolean
  }

  export type walletOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"WalletId" | "CurrencyId" | "WalletName", ExtArgs["result"]["wallet"]>
  export type walletInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | wallet$transactionsArgs<ExtArgs>
    currency?: boolean | wallet$currencyArgs<ExtArgs>
    _count?: boolean | WalletCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $walletPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "wallet"
    objects: {
      transactions: Prisma.$transactionsPayload<ExtArgs>[]
      currency: Prisma.$currencyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      WalletId: number
      CurrencyId: number | null
      WalletName: string | null
    }, ExtArgs["result"]["wallet"]>
    composites: {}
  }

  type walletGetPayload<S extends boolean | null | undefined | walletDefaultArgs> = $Result.GetResult<Prisma.$walletPayload, S>

  type walletCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<walletFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WalletCountAggregateInputType | true
    }

  export interface walletDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['wallet'], meta: { name: 'wallet' } }
    /**
     * Find zero or one Wallet that matches the filter.
     * @param {walletFindUniqueArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends walletFindUniqueArgs>(args: SelectSubset<T, walletFindUniqueArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Wallet that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {walletFindUniqueOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends walletFindUniqueOrThrowArgs>(args: SelectSubset<T, walletFindUniqueOrThrowArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends walletFindFirstArgs>(args?: SelectSubset<T, walletFindFirstArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Wallet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindFirstOrThrowArgs} args - Arguments to find a Wallet
     * @example
     * // Get one Wallet
     * const wallet = await prisma.wallet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends walletFindFirstOrThrowArgs>(args?: SelectSubset<T, walletFindFirstOrThrowArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Wallets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Wallets
     * const wallets = await prisma.wallet.findMany()
     * 
     * // Get first 10 Wallets
     * const wallets = await prisma.wallet.findMany({ take: 10 })
     * 
     * // Only select the `WalletId`
     * const walletWithWalletIdOnly = await prisma.wallet.findMany({ select: { WalletId: true } })
     * 
     */
    findMany<T extends walletFindManyArgs>(args?: SelectSubset<T, walletFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Wallet.
     * @param {walletCreateArgs} args - Arguments to create a Wallet.
     * @example
     * // Create one Wallet
     * const Wallet = await prisma.wallet.create({
     *   data: {
     *     // ... data to create a Wallet
     *   }
     * })
     * 
     */
    create<T extends walletCreateArgs>(args: SelectSubset<T, walletCreateArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Wallets.
     * @param {walletCreateManyArgs} args - Arguments to create many Wallets.
     * @example
     * // Create many Wallets
     * const wallet = await prisma.wallet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends walletCreateManyArgs>(args?: SelectSubset<T, walletCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Wallet.
     * @param {walletDeleteArgs} args - Arguments to delete one Wallet.
     * @example
     * // Delete one Wallet
     * const Wallet = await prisma.wallet.delete({
     *   where: {
     *     // ... filter to delete one Wallet
     *   }
     * })
     * 
     */
    delete<T extends walletDeleteArgs>(args: SelectSubset<T, walletDeleteArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Wallet.
     * @param {walletUpdateArgs} args - Arguments to update one Wallet.
     * @example
     * // Update one Wallet
     * const wallet = await prisma.wallet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends walletUpdateArgs>(args: SelectSubset<T, walletUpdateArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Wallets.
     * @param {walletDeleteManyArgs} args - Arguments to filter Wallets to delete.
     * @example
     * // Delete a few Wallets
     * const { count } = await prisma.wallet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends walletDeleteManyArgs>(args?: SelectSubset<T, walletDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Wallets
     * const wallet = await prisma.wallet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends walletUpdateManyArgs>(args: SelectSubset<T, walletUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Wallet.
     * @param {walletUpsertArgs} args - Arguments to update or create a Wallet.
     * @example
     * // Update or create a Wallet
     * const wallet = await prisma.wallet.upsert({
     *   create: {
     *     // ... data to create a Wallet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Wallet we want to update
     *   }
     * })
     */
    upsert<T extends walletUpsertArgs>(args: SelectSubset<T, walletUpsertArgs<ExtArgs>>): Prisma__walletClient<$Result.GetResult<Prisma.$walletPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Wallets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletCountArgs} args - Arguments to filter Wallets to count.
     * @example
     * // Count the number of Wallets
     * const count = await prisma.wallet.count({
     *   where: {
     *     // ... the filter for the Wallets we want to count
     *   }
     * })
    **/
    count<T extends walletCountArgs>(
      args?: Subset<T, walletCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WalletCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WalletAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WalletAggregateArgs>(args: Subset<T, WalletAggregateArgs>): Prisma.PrismaPromise<GetWalletAggregateType<T>>

    /**
     * Group by Wallet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {walletGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends walletGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: walletGroupByArgs['orderBy'] }
        : { orderBy?: walletGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, walletGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWalletGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the wallet model
   */
  readonly fields: walletFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for wallet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__walletClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends wallet$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, wallet$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$transactionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    currency<T extends wallet$currencyArgs<ExtArgs> = {}>(args?: Subset<T, wallet$currencyArgs<ExtArgs>>): Prisma__currencyClient<$Result.GetResult<Prisma.$currencyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the wallet model
   */
  interface walletFieldRefs {
    readonly WalletId: FieldRef<"wallet", 'Int'>
    readonly CurrencyId: FieldRef<"wallet", 'Int'>
    readonly WalletName: FieldRef<"wallet", 'String'>
  }
    

  // Custom InputTypes
  /**
   * wallet findUnique
   */
  export type walletFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet findUniqueOrThrow
   */
  export type walletFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet findFirst
   */
  export type walletFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet findFirstOrThrow
   */
  export type walletFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallet to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of wallets.
     */
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet findMany
   */
  export type walletFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter, which wallets to fetch.
     */
    where?: walletWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of wallets to fetch.
     */
    orderBy?: walletOrderByWithRelationInput | walletOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing wallets.
     */
    cursor?: walletWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` wallets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` wallets.
     */
    skip?: number
    distinct?: WalletScalarFieldEnum | WalletScalarFieldEnum[]
  }

  /**
   * wallet create
   */
  export type walletCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The data needed to create a wallet.
     */
    data?: XOR<walletCreateInput, walletUncheckedCreateInput>
  }

  /**
   * wallet createMany
   */
  export type walletCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many wallets.
     */
    data: walletCreateManyInput | walletCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * wallet update
   */
  export type walletUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The data needed to update a wallet.
     */
    data: XOR<walletUpdateInput, walletUncheckedUpdateInput>
    /**
     * Choose, which wallet to update.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet updateMany
   */
  export type walletUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update wallets.
     */
    data: XOR<walletUpdateManyMutationInput, walletUncheckedUpdateManyInput>
    /**
     * Filter which wallets to update
     */
    where?: walletWhereInput
    /**
     * Limit how many wallets to update.
     */
    limit?: number
  }

  /**
   * wallet upsert
   */
  export type walletUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * The filter to search for the wallet to update in case it exists.
     */
    where: walletWhereUniqueInput
    /**
     * In case the wallet found by the `where` argument doesn't exist, create a new wallet with this data.
     */
    create: XOR<walletCreateInput, walletUncheckedCreateInput>
    /**
     * In case the wallet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<walletUpdateInput, walletUncheckedUpdateInput>
  }

  /**
   * wallet delete
   */
  export type walletDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
    /**
     * Filter which wallet to delete.
     */
    where: walletWhereUniqueInput
  }

  /**
   * wallet deleteMany
   */
  export type walletDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which wallets to delete
     */
    where?: walletWhereInput
    /**
     * Limit how many wallets to delete.
     */
    limit?: number
  }

  /**
   * wallet.transactions
   */
  export type wallet$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the transactions
     */
    select?: transactionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the transactions
     */
    omit?: transactionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: transactionsInclude<ExtArgs> | null
    where?: transactionsWhereInput
    orderBy?: transactionsOrderByWithRelationInput | transactionsOrderByWithRelationInput[]
    cursor?: transactionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionsScalarFieldEnum | TransactionsScalarFieldEnum[]
  }

  /**
   * wallet.currency
   */
  export type wallet$currencyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the currency
     */
    select?: currencySelect<ExtArgs> | null
    /**
     * Omit specific fields from the currency
     */
    omit?: currencyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: currencyInclude<ExtArgs> | null
    where?: currencyWhereInput
  }

  /**
   * wallet without action
   */
  export type walletDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the wallet
     */
    select?: walletSelect<ExtArgs> | null
    /**
     * Omit specific fields from the wallet
     */
    omit?: walletOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: walletInclude<ExtArgs> | null
  }


  /**
   * Model testing_new_table
   */

  export type AggregateTesting_new_table = {
    _count: Testing_new_tableCountAggregateOutputType | null
    _avg: Testing_new_tableAvgAggregateOutputType | null
    _sum: Testing_new_tableSumAggregateOutputType | null
    _min: Testing_new_tableMinAggregateOutputType | null
    _max: Testing_new_tableMaxAggregateOutputType | null
  }

  export type Testing_new_tableAvgAggregateOutputType = {
    Id: number | null
  }

  export type Testing_new_tableSumAggregateOutputType = {
    Id: number | null
  }

  export type Testing_new_tableMinAggregateOutputType = {
    Id: number | null
    Name: string | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type Testing_new_tableMaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type Testing_new_tableCountAggregateOutputType = {
    Id: number
    Name: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type Testing_new_tableAvgAggregateInputType = {
    Id?: true
  }

  export type Testing_new_tableSumAggregateInputType = {
    Id?: true
  }

  export type Testing_new_tableMinAggregateInputType = {
    Id?: true
    Name?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type Testing_new_tableMaxAggregateInputType = {
    Id?: true
    Name?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type Testing_new_tableCountAggregateInputType = {
    Id?: true
    Name?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type Testing_new_tableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testing_new_table to aggregate.
     */
    where?: testing_new_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testing_new_tables to fetch.
     */
    orderBy?: testing_new_tableOrderByWithRelationInput | testing_new_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testing_new_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testing_new_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testing_new_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned testing_new_tables
    **/
    _count?: true | Testing_new_tableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Testing_new_tableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Testing_new_tableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Testing_new_tableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Testing_new_tableMaxAggregateInputType
  }

  export type GetTesting_new_tableAggregateType<T extends Testing_new_tableAggregateArgs> = {
        [P in keyof T & keyof AggregateTesting_new_table]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTesting_new_table[P]>
      : GetScalarType<T[P], AggregateTesting_new_table[P]>
  }




  export type testing_new_tableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testing_new_tableWhereInput
    orderBy?: testing_new_tableOrderByWithAggregationInput | testing_new_tableOrderByWithAggregationInput[]
    by: Testing_new_tableScalarFieldEnum[] | Testing_new_tableScalarFieldEnum
    having?: testing_new_tableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Testing_new_tableCountAggregateInputType | true
    _avg?: Testing_new_tableAvgAggregateInputType
    _sum?: Testing_new_tableSumAggregateInputType
    _min?: Testing_new_tableMinAggregateInputType
    _max?: Testing_new_tableMaxAggregateInputType
  }

  export type Testing_new_tableGroupByOutputType = {
    Id: number
    Name: string
    CreatedAt: Date
    UpdatedAt: Date
    _count: Testing_new_tableCountAggregateOutputType | null
    _avg: Testing_new_tableAvgAggregateOutputType | null
    _sum: Testing_new_tableSumAggregateOutputType | null
    _min: Testing_new_tableMinAggregateOutputType | null
    _max: Testing_new_tableMaxAggregateOutputType | null
  }

  type GetTesting_new_tableGroupByPayload<T extends testing_new_tableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Testing_new_tableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Testing_new_tableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Testing_new_tableGroupByOutputType[P]>
            : GetScalarType<T[P], Testing_new_tableGroupByOutputType[P]>
        }
      >
    >


  export type testing_new_tableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }, ExtArgs["result"]["testing_new_table"]>



  export type testing_new_tableSelectScalar = {
    Id?: boolean
    Name?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }

  export type testing_new_tableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Name" | "CreatedAt" | "UpdatedAt", ExtArgs["result"]["testing_new_table"]>

  export type $testing_new_tablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "testing_new_table"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Name: string
      CreatedAt: Date
      UpdatedAt: Date
    }, ExtArgs["result"]["testing_new_table"]>
    composites: {}
  }

  type testing_new_tableGetPayload<S extends boolean | null | undefined | testing_new_tableDefaultArgs> = $Result.GetResult<Prisma.$testing_new_tablePayload, S>

  type testing_new_tableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<testing_new_tableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Testing_new_tableCountAggregateInputType | true
    }

  export interface testing_new_tableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['testing_new_table'], meta: { name: 'testing_new_table' } }
    /**
     * Find zero or one Testing_new_table that matches the filter.
     * @param {testing_new_tableFindUniqueArgs} args - Arguments to find a Testing_new_table
     * @example
     * // Get one Testing_new_table
     * const testing_new_table = await prisma.testing_new_table.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends testing_new_tableFindUniqueArgs>(args: SelectSubset<T, testing_new_tableFindUniqueArgs<ExtArgs>>): Prisma__testing_new_tableClient<$Result.GetResult<Prisma.$testing_new_tablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testing_new_table that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {testing_new_tableFindUniqueOrThrowArgs} args - Arguments to find a Testing_new_table
     * @example
     * // Get one Testing_new_table
     * const testing_new_table = await prisma.testing_new_table.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends testing_new_tableFindUniqueOrThrowArgs>(args: SelectSubset<T, testing_new_tableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__testing_new_tableClient<$Result.GetResult<Prisma.$testing_new_tablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testing_new_table that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_tableFindFirstArgs} args - Arguments to find a Testing_new_table
     * @example
     * // Get one Testing_new_table
     * const testing_new_table = await prisma.testing_new_table.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends testing_new_tableFindFirstArgs>(args?: SelectSubset<T, testing_new_tableFindFirstArgs<ExtArgs>>): Prisma__testing_new_tableClient<$Result.GetResult<Prisma.$testing_new_tablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testing_new_table that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_tableFindFirstOrThrowArgs} args - Arguments to find a Testing_new_table
     * @example
     * // Get one Testing_new_table
     * const testing_new_table = await prisma.testing_new_table.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends testing_new_tableFindFirstOrThrowArgs>(args?: SelectSubset<T, testing_new_tableFindFirstOrThrowArgs<ExtArgs>>): Prisma__testing_new_tableClient<$Result.GetResult<Prisma.$testing_new_tablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testing_new_tables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_tableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testing_new_tables
     * const testing_new_tables = await prisma.testing_new_table.findMany()
     * 
     * // Get first 10 Testing_new_tables
     * const testing_new_tables = await prisma.testing_new_table.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const testing_new_tableWithIdOnly = await prisma.testing_new_table.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends testing_new_tableFindManyArgs>(args?: SelectSubset<T, testing_new_tableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testing_new_tablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testing_new_table.
     * @param {testing_new_tableCreateArgs} args - Arguments to create a Testing_new_table.
     * @example
     * // Create one Testing_new_table
     * const Testing_new_table = await prisma.testing_new_table.create({
     *   data: {
     *     // ... data to create a Testing_new_table
     *   }
     * })
     * 
     */
    create<T extends testing_new_tableCreateArgs>(args: SelectSubset<T, testing_new_tableCreateArgs<ExtArgs>>): Prisma__testing_new_tableClient<$Result.GetResult<Prisma.$testing_new_tablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testing_new_tables.
     * @param {testing_new_tableCreateManyArgs} args - Arguments to create many Testing_new_tables.
     * @example
     * // Create many Testing_new_tables
     * const testing_new_table = await prisma.testing_new_table.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends testing_new_tableCreateManyArgs>(args?: SelectSubset<T, testing_new_tableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testing_new_table.
     * @param {testing_new_tableDeleteArgs} args - Arguments to delete one Testing_new_table.
     * @example
     * // Delete one Testing_new_table
     * const Testing_new_table = await prisma.testing_new_table.delete({
     *   where: {
     *     // ... filter to delete one Testing_new_table
     *   }
     * })
     * 
     */
    delete<T extends testing_new_tableDeleteArgs>(args: SelectSubset<T, testing_new_tableDeleteArgs<ExtArgs>>): Prisma__testing_new_tableClient<$Result.GetResult<Prisma.$testing_new_tablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testing_new_table.
     * @param {testing_new_tableUpdateArgs} args - Arguments to update one Testing_new_table.
     * @example
     * // Update one Testing_new_table
     * const testing_new_table = await prisma.testing_new_table.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends testing_new_tableUpdateArgs>(args: SelectSubset<T, testing_new_tableUpdateArgs<ExtArgs>>): Prisma__testing_new_tableClient<$Result.GetResult<Prisma.$testing_new_tablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testing_new_tables.
     * @param {testing_new_tableDeleteManyArgs} args - Arguments to filter Testing_new_tables to delete.
     * @example
     * // Delete a few Testing_new_tables
     * const { count } = await prisma.testing_new_table.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends testing_new_tableDeleteManyArgs>(args?: SelectSubset<T, testing_new_tableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testing_new_tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_tableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testing_new_tables
     * const testing_new_table = await prisma.testing_new_table.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends testing_new_tableUpdateManyArgs>(args: SelectSubset<T, testing_new_tableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testing_new_table.
     * @param {testing_new_tableUpsertArgs} args - Arguments to update or create a Testing_new_table.
     * @example
     * // Update or create a Testing_new_table
     * const testing_new_table = await prisma.testing_new_table.upsert({
     *   create: {
     *     // ... data to create a Testing_new_table
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testing_new_table we want to update
     *   }
     * })
     */
    upsert<T extends testing_new_tableUpsertArgs>(args: SelectSubset<T, testing_new_tableUpsertArgs<ExtArgs>>): Prisma__testing_new_tableClient<$Result.GetResult<Prisma.$testing_new_tablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testing_new_tables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_tableCountArgs} args - Arguments to filter Testing_new_tables to count.
     * @example
     * // Count the number of Testing_new_tables
     * const count = await prisma.testing_new_table.count({
     *   where: {
     *     // ... the filter for the Testing_new_tables we want to count
     *   }
     * })
    **/
    count<T extends testing_new_tableCountArgs>(
      args?: Subset<T, testing_new_tableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Testing_new_tableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testing_new_table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Testing_new_tableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Testing_new_tableAggregateArgs>(args: Subset<T, Testing_new_tableAggregateArgs>): Prisma.PrismaPromise<GetTesting_new_tableAggregateType<T>>

    /**
     * Group by Testing_new_table.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_tableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testing_new_tableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testing_new_tableGroupByArgs['orderBy'] }
        : { orderBy?: testing_new_tableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testing_new_tableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTesting_new_tableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the testing_new_table model
   */
  readonly fields: testing_new_tableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for testing_new_table.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testing_new_tableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the testing_new_table model
   */
  interface testing_new_tableFieldRefs {
    readonly Id: FieldRef<"testing_new_table", 'Int'>
    readonly Name: FieldRef<"testing_new_table", 'String'>
    readonly CreatedAt: FieldRef<"testing_new_table", 'DateTime'>
    readonly UpdatedAt: FieldRef<"testing_new_table", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * testing_new_table findUnique
   */
  export type testing_new_tableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table
     */
    select?: testing_new_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table
     */
    omit?: testing_new_tableOmit<ExtArgs> | null
    /**
     * Filter, which testing_new_table to fetch.
     */
    where: testing_new_tableWhereUniqueInput
  }

  /**
   * testing_new_table findUniqueOrThrow
   */
  export type testing_new_tableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table
     */
    select?: testing_new_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table
     */
    omit?: testing_new_tableOmit<ExtArgs> | null
    /**
     * Filter, which testing_new_table to fetch.
     */
    where: testing_new_tableWhereUniqueInput
  }

  /**
   * testing_new_table findFirst
   */
  export type testing_new_tableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table
     */
    select?: testing_new_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table
     */
    omit?: testing_new_tableOmit<ExtArgs> | null
    /**
     * Filter, which testing_new_table to fetch.
     */
    where?: testing_new_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testing_new_tables to fetch.
     */
    orderBy?: testing_new_tableOrderByWithRelationInput | testing_new_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testing_new_tables.
     */
    cursor?: testing_new_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testing_new_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testing_new_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testing_new_tables.
     */
    distinct?: Testing_new_tableScalarFieldEnum | Testing_new_tableScalarFieldEnum[]
  }

  /**
   * testing_new_table findFirstOrThrow
   */
  export type testing_new_tableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table
     */
    select?: testing_new_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table
     */
    omit?: testing_new_tableOmit<ExtArgs> | null
    /**
     * Filter, which testing_new_table to fetch.
     */
    where?: testing_new_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testing_new_tables to fetch.
     */
    orderBy?: testing_new_tableOrderByWithRelationInput | testing_new_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testing_new_tables.
     */
    cursor?: testing_new_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testing_new_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testing_new_tables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testing_new_tables.
     */
    distinct?: Testing_new_tableScalarFieldEnum | Testing_new_tableScalarFieldEnum[]
  }

  /**
   * testing_new_table findMany
   */
  export type testing_new_tableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table
     */
    select?: testing_new_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table
     */
    omit?: testing_new_tableOmit<ExtArgs> | null
    /**
     * Filter, which testing_new_tables to fetch.
     */
    where?: testing_new_tableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testing_new_tables to fetch.
     */
    orderBy?: testing_new_tableOrderByWithRelationInput | testing_new_tableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing testing_new_tables.
     */
    cursor?: testing_new_tableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testing_new_tables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testing_new_tables.
     */
    skip?: number
    distinct?: Testing_new_tableScalarFieldEnum | Testing_new_tableScalarFieldEnum[]
  }

  /**
   * testing_new_table create
   */
  export type testing_new_tableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table
     */
    select?: testing_new_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table
     */
    omit?: testing_new_tableOmit<ExtArgs> | null
    /**
     * The data needed to create a testing_new_table.
     */
    data: XOR<testing_new_tableCreateInput, testing_new_tableUncheckedCreateInput>
  }

  /**
   * testing_new_table createMany
   */
  export type testing_new_tableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many testing_new_tables.
     */
    data: testing_new_tableCreateManyInput | testing_new_tableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * testing_new_table update
   */
  export type testing_new_tableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table
     */
    select?: testing_new_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table
     */
    omit?: testing_new_tableOmit<ExtArgs> | null
    /**
     * The data needed to update a testing_new_table.
     */
    data: XOR<testing_new_tableUpdateInput, testing_new_tableUncheckedUpdateInput>
    /**
     * Choose, which testing_new_table to update.
     */
    where: testing_new_tableWhereUniqueInput
  }

  /**
   * testing_new_table updateMany
   */
  export type testing_new_tableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update testing_new_tables.
     */
    data: XOR<testing_new_tableUpdateManyMutationInput, testing_new_tableUncheckedUpdateManyInput>
    /**
     * Filter which testing_new_tables to update
     */
    where?: testing_new_tableWhereInput
    /**
     * Limit how many testing_new_tables to update.
     */
    limit?: number
  }

  /**
   * testing_new_table upsert
   */
  export type testing_new_tableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table
     */
    select?: testing_new_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table
     */
    omit?: testing_new_tableOmit<ExtArgs> | null
    /**
     * The filter to search for the testing_new_table to update in case it exists.
     */
    where: testing_new_tableWhereUniqueInput
    /**
     * In case the testing_new_table found by the `where` argument doesn't exist, create a new testing_new_table with this data.
     */
    create: XOR<testing_new_tableCreateInput, testing_new_tableUncheckedCreateInput>
    /**
     * In case the testing_new_table was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testing_new_tableUpdateInput, testing_new_tableUncheckedUpdateInput>
  }

  /**
   * testing_new_table delete
   */
  export type testing_new_tableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table
     */
    select?: testing_new_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table
     */
    omit?: testing_new_tableOmit<ExtArgs> | null
    /**
     * Filter which testing_new_table to delete.
     */
    where: testing_new_tableWhereUniqueInput
  }

  /**
   * testing_new_table deleteMany
   */
  export type testing_new_tableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testing_new_tables to delete
     */
    where?: testing_new_tableWhereInput
    /**
     * Limit how many testing_new_tables to delete.
     */
    limit?: number
  }

  /**
   * testing_new_table without action
   */
  export type testing_new_tableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table
     */
    select?: testing_new_tableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table
     */
    omit?: testing_new_tableOmit<ExtArgs> | null
  }


  /**
   * Model testing_new_table2
   */

  export type AggregateTesting_new_table2 = {
    _count: Testing_new_table2CountAggregateOutputType | null
    _avg: Testing_new_table2AvgAggregateOutputType | null
    _sum: Testing_new_table2SumAggregateOutputType | null
    _min: Testing_new_table2MinAggregateOutputType | null
    _max: Testing_new_table2MaxAggregateOutputType | null
  }

  export type Testing_new_table2AvgAggregateOutputType = {
    Id: number | null
  }

  export type Testing_new_table2SumAggregateOutputType = {
    Id: number | null
  }

  export type Testing_new_table2MinAggregateOutputType = {
    Id: number | null
    Name: string | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type Testing_new_table2MaxAggregateOutputType = {
    Id: number | null
    Name: string | null
    CreatedAt: Date | null
    UpdatedAt: Date | null
  }

  export type Testing_new_table2CountAggregateOutputType = {
    Id: number
    Name: number
    CreatedAt: number
    UpdatedAt: number
    _all: number
  }


  export type Testing_new_table2AvgAggregateInputType = {
    Id?: true
  }

  export type Testing_new_table2SumAggregateInputType = {
    Id?: true
  }

  export type Testing_new_table2MinAggregateInputType = {
    Id?: true
    Name?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type Testing_new_table2MaxAggregateInputType = {
    Id?: true
    Name?: true
    CreatedAt?: true
    UpdatedAt?: true
  }

  export type Testing_new_table2CountAggregateInputType = {
    Id?: true
    Name?: true
    CreatedAt?: true
    UpdatedAt?: true
    _all?: true
  }

  export type Testing_new_table2AggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testing_new_table2 to aggregate.
     */
    where?: testing_new_table2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testing_new_table2s to fetch.
     */
    orderBy?: testing_new_table2OrderByWithRelationInput | testing_new_table2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: testing_new_table2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testing_new_table2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testing_new_table2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned testing_new_table2s
    **/
    _count?: true | Testing_new_table2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Testing_new_table2AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Testing_new_table2SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Testing_new_table2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Testing_new_table2MaxAggregateInputType
  }

  export type GetTesting_new_table2AggregateType<T extends Testing_new_table2AggregateArgs> = {
        [P in keyof T & keyof AggregateTesting_new_table2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTesting_new_table2[P]>
      : GetScalarType<T[P], AggregateTesting_new_table2[P]>
  }




  export type testing_new_table2GroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: testing_new_table2WhereInput
    orderBy?: testing_new_table2OrderByWithAggregationInput | testing_new_table2OrderByWithAggregationInput[]
    by: Testing_new_table2ScalarFieldEnum[] | Testing_new_table2ScalarFieldEnum
    having?: testing_new_table2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Testing_new_table2CountAggregateInputType | true
    _avg?: Testing_new_table2AvgAggregateInputType
    _sum?: Testing_new_table2SumAggregateInputType
    _min?: Testing_new_table2MinAggregateInputType
    _max?: Testing_new_table2MaxAggregateInputType
  }

  export type Testing_new_table2GroupByOutputType = {
    Id: number
    Name: string
    CreatedAt: Date
    UpdatedAt: Date
    _count: Testing_new_table2CountAggregateOutputType | null
    _avg: Testing_new_table2AvgAggregateOutputType | null
    _sum: Testing_new_table2SumAggregateOutputType | null
    _min: Testing_new_table2MinAggregateOutputType | null
    _max: Testing_new_table2MaxAggregateOutputType | null
  }

  type GetTesting_new_table2GroupByPayload<T extends testing_new_table2GroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Testing_new_table2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Testing_new_table2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Testing_new_table2GroupByOutputType[P]>
            : GetScalarType<T[P], Testing_new_table2GroupByOutputType[P]>
        }
      >
    >


  export type testing_new_table2Select<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    Id?: boolean
    Name?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }, ExtArgs["result"]["testing_new_table2"]>



  export type testing_new_table2SelectScalar = {
    Id?: boolean
    Name?: boolean
    CreatedAt?: boolean
    UpdatedAt?: boolean
  }

  export type testing_new_table2Omit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"Id" | "Name" | "CreatedAt" | "UpdatedAt", ExtArgs["result"]["testing_new_table2"]>

  export type $testing_new_table2Payload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "testing_new_table2"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      Id: number
      Name: string
      CreatedAt: Date
      UpdatedAt: Date
    }, ExtArgs["result"]["testing_new_table2"]>
    composites: {}
  }

  type testing_new_table2GetPayload<S extends boolean | null | undefined | testing_new_table2DefaultArgs> = $Result.GetResult<Prisma.$testing_new_table2Payload, S>

  type testing_new_table2CountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<testing_new_table2FindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Testing_new_table2CountAggregateInputType | true
    }

  export interface testing_new_table2Delegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['testing_new_table2'], meta: { name: 'testing_new_table2' } }
    /**
     * Find zero or one Testing_new_table2 that matches the filter.
     * @param {testing_new_table2FindUniqueArgs} args - Arguments to find a Testing_new_table2
     * @example
     * // Get one Testing_new_table2
     * const testing_new_table2 = await prisma.testing_new_table2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends testing_new_table2FindUniqueArgs>(args: SelectSubset<T, testing_new_table2FindUniqueArgs<ExtArgs>>): Prisma__testing_new_table2Client<$Result.GetResult<Prisma.$testing_new_table2Payload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Testing_new_table2 that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {testing_new_table2FindUniqueOrThrowArgs} args - Arguments to find a Testing_new_table2
     * @example
     * // Get one Testing_new_table2
     * const testing_new_table2 = await prisma.testing_new_table2.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends testing_new_table2FindUniqueOrThrowArgs>(args: SelectSubset<T, testing_new_table2FindUniqueOrThrowArgs<ExtArgs>>): Prisma__testing_new_table2Client<$Result.GetResult<Prisma.$testing_new_table2Payload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testing_new_table2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_table2FindFirstArgs} args - Arguments to find a Testing_new_table2
     * @example
     * // Get one Testing_new_table2
     * const testing_new_table2 = await prisma.testing_new_table2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends testing_new_table2FindFirstArgs>(args?: SelectSubset<T, testing_new_table2FindFirstArgs<ExtArgs>>): Prisma__testing_new_table2Client<$Result.GetResult<Prisma.$testing_new_table2Payload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Testing_new_table2 that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_table2FindFirstOrThrowArgs} args - Arguments to find a Testing_new_table2
     * @example
     * // Get one Testing_new_table2
     * const testing_new_table2 = await prisma.testing_new_table2.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends testing_new_table2FindFirstOrThrowArgs>(args?: SelectSubset<T, testing_new_table2FindFirstOrThrowArgs<ExtArgs>>): Prisma__testing_new_table2Client<$Result.GetResult<Prisma.$testing_new_table2Payload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Testing_new_table2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_table2FindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Testing_new_table2s
     * const testing_new_table2s = await prisma.testing_new_table2.findMany()
     * 
     * // Get first 10 Testing_new_table2s
     * const testing_new_table2s = await prisma.testing_new_table2.findMany({ take: 10 })
     * 
     * // Only select the `Id`
     * const testing_new_table2WithIdOnly = await prisma.testing_new_table2.findMany({ select: { Id: true } })
     * 
     */
    findMany<T extends testing_new_table2FindManyArgs>(args?: SelectSubset<T, testing_new_table2FindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$testing_new_table2Payload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Testing_new_table2.
     * @param {testing_new_table2CreateArgs} args - Arguments to create a Testing_new_table2.
     * @example
     * // Create one Testing_new_table2
     * const Testing_new_table2 = await prisma.testing_new_table2.create({
     *   data: {
     *     // ... data to create a Testing_new_table2
     *   }
     * })
     * 
     */
    create<T extends testing_new_table2CreateArgs>(args: SelectSubset<T, testing_new_table2CreateArgs<ExtArgs>>): Prisma__testing_new_table2Client<$Result.GetResult<Prisma.$testing_new_table2Payload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Testing_new_table2s.
     * @param {testing_new_table2CreateManyArgs} args - Arguments to create many Testing_new_table2s.
     * @example
     * // Create many Testing_new_table2s
     * const testing_new_table2 = await prisma.testing_new_table2.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends testing_new_table2CreateManyArgs>(args?: SelectSubset<T, testing_new_table2CreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Testing_new_table2.
     * @param {testing_new_table2DeleteArgs} args - Arguments to delete one Testing_new_table2.
     * @example
     * // Delete one Testing_new_table2
     * const Testing_new_table2 = await prisma.testing_new_table2.delete({
     *   where: {
     *     // ... filter to delete one Testing_new_table2
     *   }
     * })
     * 
     */
    delete<T extends testing_new_table2DeleteArgs>(args: SelectSubset<T, testing_new_table2DeleteArgs<ExtArgs>>): Prisma__testing_new_table2Client<$Result.GetResult<Prisma.$testing_new_table2Payload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Testing_new_table2.
     * @param {testing_new_table2UpdateArgs} args - Arguments to update one Testing_new_table2.
     * @example
     * // Update one Testing_new_table2
     * const testing_new_table2 = await prisma.testing_new_table2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends testing_new_table2UpdateArgs>(args: SelectSubset<T, testing_new_table2UpdateArgs<ExtArgs>>): Prisma__testing_new_table2Client<$Result.GetResult<Prisma.$testing_new_table2Payload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Testing_new_table2s.
     * @param {testing_new_table2DeleteManyArgs} args - Arguments to filter Testing_new_table2s to delete.
     * @example
     * // Delete a few Testing_new_table2s
     * const { count } = await prisma.testing_new_table2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends testing_new_table2DeleteManyArgs>(args?: SelectSubset<T, testing_new_table2DeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Testing_new_table2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_table2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Testing_new_table2s
     * const testing_new_table2 = await prisma.testing_new_table2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends testing_new_table2UpdateManyArgs>(args: SelectSubset<T, testing_new_table2UpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Testing_new_table2.
     * @param {testing_new_table2UpsertArgs} args - Arguments to update or create a Testing_new_table2.
     * @example
     * // Update or create a Testing_new_table2
     * const testing_new_table2 = await prisma.testing_new_table2.upsert({
     *   create: {
     *     // ... data to create a Testing_new_table2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Testing_new_table2 we want to update
     *   }
     * })
     */
    upsert<T extends testing_new_table2UpsertArgs>(args: SelectSubset<T, testing_new_table2UpsertArgs<ExtArgs>>): Prisma__testing_new_table2Client<$Result.GetResult<Prisma.$testing_new_table2Payload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Testing_new_table2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_table2CountArgs} args - Arguments to filter Testing_new_table2s to count.
     * @example
     * // Count the number of Testing_new_table2s
     * const count = await prisma.testing_new_table2.count({
     *   where: {
     *     // ... the filter for the Testing_new_table2s we want to count
     *   }
     * })
    **/
    count<T extends testing_new_table2CountArgs>(
      args?: Subset<T, testing_new_table2CountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Testing_new_table2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Testing_new_table2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Testing_new_table2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Testing_new_table2AggregateArgs>(args: Subset<T, Testing_new_table2AggregateArgs>): Prisma.PrismaPromise<GetTesting_new_table2AggregateType<T>>

    /**
     * Group by Testing_new_table2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {testing_new_table2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends testing_new_table2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: testing_new_table2GroupByArgs['orderBy'] }
        : { orderBy?: testing_new_table2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, testing_new_table2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTesting_new_table2GroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the testing_new_table2 model
   */
  readonly fields: testing_new_table2FieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for testing_new_table2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__testing_new_table2Client<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the testing_new_table2 model
   */
  interface testing_new_table2FieldRefs {
    readonly Id: FieldRef<"testing_new_table2", 'Int'>
    readonly Name: FieldRef<"testing_new_table2", 'String'>
    readonly CreatedAt: FieldRef<"testing_new_table2", 'DateTime'>
    readonly UpdatedAt: FieldRef<"testing_new_table2", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * testing_new_table2 findUnique
   */
  export type testing_new_table2FindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table2
     */
    select?: testing_new_table2Select<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table2
     */
    omit?: testing_new_table2Omit<ExtArgs> | null
    /**
     * Filter, which testing_new_table2 to fetch.
     */
    where: testing_new_table2WhereUniqueInput
  }

  /**
   * testing_new_table2 findUniqueOrThrow
   */
  export type testing_new_table2FindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table2
     */
    select?: testing_new_table2Select<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table2
     */
    omit?: testing_new_table2Omit<ExtArgs> | null
    /**
     * Filter, which testing_new_table2 to fetch.
     */
    where: testing_new_table2WhereUniqueInput
  }

  /**
   * testing_new_table2 findFirst
   */
  export type testing_new_table2FindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table2
     */
    select?: testing_new_table2Select<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table2
     */
    omit?: testing_new_table2Omit<ExtArgs> | null
    /**
     * Filter, which testing_new_table2 to fetch.
     */
    where?: testing_new_table2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testing_new_table2s to fetch.
     */
    orderBy?: testing_new_table2OrderByWithRelationInput | testing_new_table2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testing_new_table2s.
     */
    cursor?: testing_new_table2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testing_new_table2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testing_new_table2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testing_new_table2s.
     */
    distinct?: Testing_new_table2ScalarFieldEnum | Testing_new_table2ScalarFieldEnum[]
  }

  /**
   * testing_new_table2 findFirstOrThrow
   */
  export type testing_new_table2FindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table2
     */
    select?: testing_new_table2Select<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table2
     */
    omit?: testing_new_table2Omit<ExtArgs> | null
    /**
     * Filter, which testing_new_table2 to fetch.
     */
    where?: testing_new_table2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testing_new_table2s to fetch.
     */
    orderBy?: testing_new_table2OrderByWithRelationInput | testing_new_table2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for testing_new_table2s.
     */
    cursor?: testing_new_table2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testing_new_table2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testing_new_table2s.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of testing_new_table2s.
     */
    distinct?: Testing_new_table2ScalarFieldEnum | Testing_new_table2ScalarFieldEnum[]
  }

  /**
   * testing_new_table2 findMany
   */
  export type testing_new_table2FindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table2
     */
    select?: testing_new_table2Select<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table2
     */
    omit?: testing_new_table2Omit<ExtArgs> | null
    /**
     * Filter, which testing_new_table2s to fetch.
     */
    where?: testing_new_table2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of testing_new_table2s to fetch.
     */
    orderBy?: testing_new_table2OrderByWithRelationInput | testing_new_table2OrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing testing_new_table2s.
     */
    cursor?: testing_new_table2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` testing_new_table2s from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` testing_new_table2s.
     */
    skip?: number
    distinct?: Testing_new_table2ScalarFieldEnum | Testing_new_table2ScalarFieldEnum[]
  }

  /**
   * testing_new_table2 create
   */
  export type testing_new_table2CreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table2
     */
    select?: testing_new_table2Select<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table2
     */
    omit?: testing_new_table2Omit<ExtArgs> | null
    /**
     * The data needed to create a testing_new_table2.
     */
    data: XOR<testing_new_table2CreateInput, testing_new_table2UncheckedCreateInput>
  }

  /**
   * testing_new_table2 createMany
   */
  export type testing_new_table2CreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many testing_new_table2s.
     */
    data: testing_new_table2CreateManyInput | testing_new_table2CreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * testing_new_table2 update
   */
  export type testing_new_table2UpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table2
     */
    select?: testing_new_table2Select<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table2
     */
    omit?: testing_new_table2Omit<ExtArgs> | null
    /**
     * The data needed to update a testing_new_table2.
     */
    data: XOR<testing_new_table2UpdateInput, testing_new_table2UncheckedUpdateInput>
    /**
     * Choose, which testing_new_table2 to update.
     */
    where: testing_new_table2WhereUniqueInput
  }

  /**
   * testing_new_table2 updateMany
   */
  export type testing_new_table2UpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update testing_new_table2s.
     */
    data: XOR<testing_new_table2UpdateManyMutationInput, testing_new_table2UncheckedUpdateManyInput>
    /**
     * Filter which testing_new_table2s to update
     */
    where?: testing_new_table2WhereInput
    /**
     * Limit how many testing_new_table2s to update.
     */
    limit?: number
  }

  /**
   * testing_new_table2 upsert
   */
  export type testing_new_table2UpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table2
     */
    select?: testing_new_table2Select<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table2
     */
    omit?: testing_new_table2Omit<ExtArgs> | null
    /**
     * The filter to search for the testing_new_table2 to update in case it exists.
     */
    where: testing_new_table2WhereUniqueInput
    /**
     * In case the testing_new_table2 found by the `where` argument doesn't exist, create a new testing_new_table2 with this data.
     */
    create: XOR<testing_new_table2CreateInput, testing_new_table2UncheckedCreateInput>
    /**
     * In case the testing_new_table2 was found with the provided `where` argument, update it with this data.
     */
    update: XOR<testing_new_table2UpdateInput, testing_new_table2UncheckedUpdateInput>
  }

  /**
   * testing_new_table2 delete
   */
  export type testing_new_table2DeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table2
     */
    select?: testing_new_table2Select<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table2
     */
    omit?: testing_new_table2Omit<ExtArgs> | null
    /**
     * Filter which testing_new_table2 to delete.
     */
    where: testing_new_table2WhereUniqueInput
  }

  /**
   * testing_new_table2 deleteMany
   */
  export type testing_new_table2DeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which testing_new_table2s to delete
     */
    where?: testing_new_table2WhereInput
    /**
     * Limit how many testing_new_table2s to delete.
     */
    limit?: number
  }

  /**
   * testing_new_table2 without action
   */
  export type testing_new_table2DefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the testing_new_table2
     */
    select?: testing_new_table2Select<ExtArgs> | null
    /**
     * Omit specific fields from the testing_new_table2
     */
    omit?: testing_new_table2Omit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AgentScalarFieldEnum: {
    AgentId: 'AgentId',
    AwsId: 'AwsId',
    UserRoleId: 'UserRoleId'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const BasecountryScalarFieldEnum: {
    BaseCountryID: 'BaseCountryID',
    BaseCountryName: 'BaseCountryName'
  };

  export type BasecountryScalarFieldEnum = (typeof BasecountryScalarFieldEnum)[keyof typeof BasecountryScalarFieldEnum]


  export const CurrencyScalarFieldEnum: {
    CurrencyId: 'CurrencyId',
    CurrencyCode: 'CurrencyCode'
  };

  export type CurrencyScalarFieldEnum = (typeof CurrencyScalarFieldEnum)[keyof typeof CurrencyScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    CustomerId: 'CustomerId',
    Name: 'Name',
    Email: 'Email',
    ManyChatId: 'ManyChatId',
    ExpireDate: 'ExpireDate',
    UserCountry: 'UserCountry',
    ContactLink: 'ContactLink',
    AgentId: 'AgentId',
    CardID: 'CardID'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const CustomerauditlogsScalarFieldEnum: {
    LogId: 'LogId',
    AgentId: 'AgentId',
    FieldChanged: 'FieldChanged',
    OldValue: 'OldValue',
    NewValue: 'NewValue',
    CustomerId: 'CustomerId',
    ChangeDate: 'ChangeDate'
  };

  export type CustomerauditlogsScalarFieldEnum = (typeof CustomerauditlogsScalarFieldEnum)[keyof typeof CustomerauditlogsScalarFieldEnum]


  export const ExchangeratesScalarFieldEnum: {
    ExchangeRateId: 'ExchangeRateId',
    BaseCountryId: 'BaseCountryId',
    CurrencyId: 'CurrencyId',
    ExchangeRate: 'ExchangeRate',
    CreateAt: 'CreateAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type ExchangeratesScalarFieldEnum = (typeof ExchangeratesScalarFieldEnum)[keyof typeof ExchangeratesScalarFieldEnum]


  export const FormstatusScalarFieldEnum: {
    FormStatusID: 'FormStatusID',
    TransactionID: 'TransactionID',
    TransactionStatusID: 'TransactionStatusID'
  };

  export type FormstatusScalarFieldEnum = (typeof FormstatusScalarFieldEnum)[keyof typeof FormstatusScalarFieldEnum]


  export const FormvisibilitystatusScalarFieldEnum: {
    VisibilityStatusId: 'VisibilityStatusId',
    AgentId: 'AgentId',
    IsFormOpen: 'IsFormOpen',
    FormTimeStamp: 'FormTimeStamp'
  };

  export type FormvisibilitystatusScalarFieldEnum = (typeof FormvisibilitystatusScalarFieldEnum)[keyof typeof FormvisibilitystatusScalarFieldEnum]


  export const FundraiserScalarFieldEnum: {
    FundraiserID: 'FundraiserID',
    FundraiserName: 'FundraiserName',
    FundraiserEmail: 'FundraiserEmail',
    FundraiserLogo: 'FundraiserLogo',
    BaseCountryID: 'BaseCountryID',
    FundraiserCentralID: 'FundraiserCentralID'
  };

  export type FundraiserScalarFieldEnum = (typeof FundraiserScalarFieldEnum)[keyof typeof FundraiserScalarFieldEnum]


  export const Fundraiser_acceptedcurrenciesScalarFieldEnum: {
    FundraiserAcceptedCurrencyID: 'FundraiserAcceptedCurrencyID',
    FundraiserID: 'FundraiserID',
    CurrencyID: 'CurrencyID'
  };

  export type Fundraiser_acceptedcurrenciesScalarFieldEnum = (typeof Fundraiser_acceptedcurrenciesScalarFieldEnum)[keyof typeof Fundraiser_acceptedcurrenciesScalarFieldEnum]


  export const Fundraiser_contactlinksScalarFieldEnum: {
    ContactID: 'ContactID',
    FundraiserID: 'FundraiserID',
    Platform: 'Platform',
    ContactURL: 'ContactURL'
  };

  export type Fundraiser_contactlinksScalarFieldEnum = (typeof Fundraiser_contactlinksScalarFieldEnum)[keyof typeof Fundraiser_contactlinksScalarFieldEnum]


  export const ManychatScalarFieldEnum: {
    ManyChatId: 'ManyChatId',
    ConversationId: 'ConversationId',
    CustomerId: 'CustomerId',
    CreateAt: 'CreateAt',
    UpdateAt: 'UpdateAt'
  };

  export type ManychatScalarFieldEnum = (typeof ManychatScalarFieldEnum)[keyof typeof ManychatScalarFieldEnum]


  export const MinimumamountScalarFieldEnum: {
    MinimumAmountId: 'MinimumAmountId',
    CurrencyId: 'CurrencyId',
    Amount: 'Amount',
    CreateAt: 'CreateAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type MinimumamountScalarFieldEnum = (typeof MinimumamountScalarFieldEnum)[keyof typeof MinimumamountScalarFieldEnum]


  export const NoteScalarFieldEnum: {
    NoteID: 'NoteID',
    Note: 'Note',
    Date: 'Date',
    AgentID: 'AgentID'
  };

  export type NoteScalarFieldEnum = (typeof NoteScalarFieldEnum)[keyof typeof NoteScalarFieldEnum]


  export const PlatformScalarFieldEnum: {
    PlatformID: 'PlatformID',
    PlatformName: 'PlatformName'
  };

  export type PlatformScalarFieldEnum = (typeof PlatformScalarFieldEnum)[keyof typeof PlatformScalarFieldEnum]


  export const ScreenshotScalarFieldEnum: {
    ScreenShotID: 'ScreenShotID',
    TransactionID: 'TransactionID',
    ScreenShotLink: 'ScreenShotLink'
  };

  export type ScreenshotScalarFieldEnum = (typeof ScreenshotScalarFieldEnum)[keyof typeof ScreenshotScalarFieldEnum]


  export const SupportregionScalarFieldEnum: {
    SupportRegionID: 'SupportRegionID',
    Region: 'Region'
  };

  export type SupportregionScalarFieldEnum = (typeof SupportregionScalarFieldEnum)[keyof typeof SupportregionScalarFieldEnum]


  export const TransactionagentScalarFieldEnum: {
    TransactionAgentID: 'TransactionAgentID',
    TransactionID: 'TransactionID',
    AgentID: 'AgentID',
    LogDate: 'LogDate'
  };

  export type TransactionagentScalarFieldEnum = (typeof TransactionagentScalarFieldEnum)[keyof typeof TransactionagentScalarFieldEnum]


  export const TransactionsScalarFieldEnum: {
    TransactionID: 'TransactionID',
    CustomerID: 'CustomerID',
    SupportRegionID: 'SupportRegionID',
    WalletID: 'WalletID',
    Amount: 'Amount',
    PaymentCheck: 'PaymentCheck',
    PaymentCheckTime: 'PaymentCheckTime',
    NoteID: 'NoteID',
    TransactionDate: 'TransactionDate',
    PaymentDenied: 'PaymentDenied',
    Month: 'Month',
    HopeFuelID: 'HopeFuelID'
  };

  export type TransactionsScalarFieldEnum = (typeof TransactionsScalarFieldEnum)[keyof typeof TransactionsScalarFieldEnum]


  export const TransactionstatusScalarFieldEnum: {
    TransactionStatusID: 'TransactionStatusID',
    TransactionStatus: 'TransactionStatus'
  };

  export type TransactionstatusScalarFieldEnum = (typeof TransactionstatusScalarFieldEnum)[keyof typeof TransactionstatusScalarFieldEnum]


  export const UserroleScalarFieldEnum: {
    UserRoleID: 'UserRoleID',
    UserRole: 'UserRole'
  };

  export type UserroleScalarFieldEnum = (typeof UserroleScalarFieldEnum)[keyof typeof UserroleScalarFieldEnum]


  export const WalletScalarFieldEnum: {
    WalletId: 'WalletId',
    CurrencyId: 'CurrencyId',
    WalletName: 'WalletName'
  };

  export type WalletScalarFieldEnum = (typeof WalletScalarFieldEnum)[keyof typeof WalletScalarFieldEnum]


  export const Testing_new_tableScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type Testing_new_tableScalarFieldEnum = (typeof Testing_new_tableScalarFieldEnum)[keyof typeof Testing_new_tableScalarFieldEnum]


  export const Testing_new_table2ScalarFieldEnum: {
    Id: 'Id',
    Name: 'Name',
    CreatedAt: 'CreatedAt',
    UpdatedAt: 'UpdatedAt'
  };

  export type Testing_new_table2ScalarFieldEnum = (typeof Testing_new_table2ScalarFieldEnum)[keyof typeof Testing_new_table2ScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const agentOrderByRelevanceFieldEnum: {
    AwsId: 'AwsId'
  };

  export type agentOrderByRelevanceFieldEnum = (typeof agentOrderByRelevanceFieldEnum)[keyof typeof agentOrderByRelevanceFieldEnum]


  export const basecountryOrderByRelevanceFieldEnum: {
    BaseCountryName: 'BaseCountryName'
  };

  export type basecountryOrderByRelevanceFieldEnum = (typeof basecountryOrderByRelevanceFieldEnum)[keyof typeof basecountryOrderByRelevanceFieldEnum]


  export const currencyOrderByRelevanceFieldEnum: {
    CurrencyCode: 'CurrencyCode'
  };

  export type currencyOrderByRelevanceFieldEnum = (typeof currencyOrderByRelevanceFieldEnum)[keyof typeof currencyOrderByRelevanceFieldEnum]


  export const customerOrderByRelevanceFieldEnum: {
    Name: 'Name',
    Email: 'Email',
    ManyChatId: 'ManyChatId',
    UserCountry: 'UserCountry',
    ContactLink: 'ContactLink'
  };

  export type customerOrderByRelevanceFieldEnum = (typeof customerOrderByRelevanceFieldEnum)[keyof typeof customerOrderByRelevanceFieldEnum]


  export const customerauditlogsOrderByRelevanceFieldEnum: {
    OldValue: 'OldValue',
    NewValue: 'NewValue'
  };

  export type customerauditlogsOrderByRelevanceFieldEnum = (typeof customerauditlogsOrderByRelevanceFieldEnum)[keyof typeof customerauditlogsOrderByRelevanceFieldEnum]


  export const fundraiserOrderByRelevanceFieldEnum: {
    FundraiserName: 'FundraiserName',
    FundraiserEmail: 'FundraiserEmail',
    FundraiserLogo: 'FundraiserLogo'
  };

  export type fundraiserOrderByRelevanceFieldEnum = (typeof fundraiserOrderByRelevanceFieldEnum)[keyof typeof fundraiserOrderByRelevanceFieldEnum]


  export const fundraiser_contactlinksOrderByRelevanceFieldEnum: {
    ContactURL: 'ContactURL'
  };

  export type fundraiser_contactlinksOrderByRelevanceFieldEnum = (typeof fundraiser_contactlinksOrderByRelevanceFieldEnum)[keyof typeof fundraiser_contactlinksOrderByRelevanceFieldEnum]


  export const manychatOrderByRelevanceFieldEnum: {
    ConversationId: 'ConversationId'
  };

  export type manychatOrderByRelevanceFieldEnum = (typeof manychatOrderByRelevanceFieldEnum)[keyof typeof manychatOrderByRelevanceFieldEnum]


  export const noteOrderByRelevanceFieldEnum: {
    Note: 'Note'
  };

  export type noteOrderByRelevanceFieldEnum = (typeof noteOrderByRelevanceFieldEnum)[keyof typeof noteOrderByRelevanceFieldEnum]


  export const platformOrderByRelevanceFieldEnum: {
    PlatformName: 'PlatformName'
  };

  export type platformOrderByRelevanceFieldEnum = (typeof platformOrderByRelevanceFieldEnum)[keyof typeof platformOrderByRelevanceFieldEnum]


  export const screenshotOrderByRelevanceFieldEnum: {
    ScreenShotLink: 'ScreenShotLink'
  };

  export type screenshotOrderByRelevanceFieldEnum = (typeof screenshotOrderByRelevanceFieldEnum)[keyof typeof screenshotOrderByRelevanceFieldEnum]


  export const supportregionOrderByRelevanceFieldEnum: {
    Region: 'Region'
  };

  export type supportregionOrderByRelevanceFieldEnum = (typeof supportregionOrderByRelevanceFieldEnum)[keyof typeof supportregionOrderByRelevanceFieldEnum]


  export const transactionstatusOrderByRelevanceFieldEnum: {
    TransactionStatus: 'TransactionStatus'
  };

  export type transactionstatusOrderByRelevanceFieldEnum = (typeof transactionstatusOrderByRelevanceFieldEnum)[keyof typeof transactionstatusOrderByRelevanceFieldEnum]


  export const userroleOrderByRelevanceFieldEnum: {
    UserRole: 'UserRole'
  };

  export type userroleOrderByRelevanceFieldEnum = (typeof userroleOrderByRelevanceFieldEnum)[keyof typeof userroleOrderByRelevanceFieldEnum]


  export const walletOrderByRelevanceFieldEnum: {
    WalletName: 'WalletName'
  };

  export type walletOrderByRelevanceFieldEnum = (typeof walletOrderByRelevanceFieldEnum)[keyof typeof walletOrderByRelevanceFieldEnum]


  export const testing_new_tableOrderByRelevanceFieldEnum: {
    Name: 'Name'
  };

  export type testing_new_tableOrderByRelevanceFieldEnum = (typeof testing_new_tableOrderByRelevanceFieldEnum)[keyof typeof testing_new_tableOrderByRelevanceFieldEnum]


  export const testing_new_table2OrderByRelevanceFieldEnum: {
    Name: 'Name'
  };

  export type testing_new_table2OrderByRelevanceFieldEnum = (typeof testing_new_table2OrderByRelevanceFieldEnum)[keyof typeof testing_new_table2OrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'customerauditlogs_FieldChanged'
   */
  export type Enumcustomerauditlogs_FieldChangedFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'customerauditlogs_FieldChanged'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type agentWhereInput = {
    AND?: agentWhereInput | agentWhereInput[]
    OR?: agentWhereInput[]
    NOT?: agentWhereInput | agentWhereInput[]
    AgentId?: IntFilter<"agent"> | number
    AwsId?: StringNullableFilter<"agent"> | string | null
    UserRoleId?: IntNullableFilter<"agent"> | number | null
    userrole?: XOR<UserroleNullableScalarRelationFilter, userroleWhereInput> | null
    customer?: CustomerListRelationFilter
    customerauditlogs?: CustomerauditlogsListRelationFilter
    formvisibilitystatus?: FormvisibilitystatusListRelationFilter
    note?: NoteListRelationFilter
    transactionagent?: TransactionagentListRelationFilter
  }

  export type agentOrderByWithRelationInput = {
    AgentId?: SortOrder
    AwsId?: SortOrderInput | SortOrder
    UserRoleId?: SortOrderInput | SortOrder
    userrole?: userroleOrderByWithRelationInput
    customer?: customerOrderByRelationAggregateInput
    customerauditlogs?: customerauditlogsOrderByRelationAggregateInput
    formvisibilitystatus?: formvisibilitystatusOrderByRelationAggregateInput
    note?: noteOrderByRelationAggregateInput
    transactionagent?: transactionagentOrderByRelationAggregateInput
    _relevance?: agentOrderByRelevanceInput
  }

  export type agentWhereUniqueInput = Prisma.AtLeast<{
    AgentId?: number
    AND?: agentWhereInput | agentWhereInput[]
    OR?: agentWhereInput[]
    NOT?: agentWhereInput | agentWhereInput[]
    AwsId?: StringNullableFilter<"agent"> | string | null
    UserRoleId?: IntNullableFilter<"agent"> | number | null
    userrole?: XOR<UserroleNullableScalarRelationFilter, userroleWhereInput> | null
    customer?: CustomerListRelationFilter
    customerauditlogs?: CustomerauditlogsListRelationFilter
    formvisibilitystatus?: FormvisibilitystatusListRelationFilter
    note?: NoteListRelationFilter
    transactionagent?: TransactionagentListRelationFilter
  }, "AgentId">

  export type agentOrderByWithAggregationInput = {
    AgentId?: SortOrder
    AwsId?: SortOrderInput | SortOrder
    UserRoleId?: SortOrderInput | SortOrder
    _count?: agentCountOrderByAggregateInput
    _avg?: agentAvgOrderByAggregateInput
    _max?: agentMaxOrderByAggregateInput
    _min?: agentMinOrderByAggregateInput
    _sum?: agentSumOrderByAggregateInput
  }

  export type agentScalarWhereWithAggregatesInput = {
    AND?: agentScalarWhereWithAggregatesInput | agentScalarWhereWithAggregatesInput[]
    OR?: agentScalarWhereWithAggregatesInput[]
    NOT?: agentScalarWhereWithAggregatesInput | agentScalarWhereWithAggregatesInput[]
    AgentId?: IntWithAggregatesFilter<"agent"> | number
    AwsId?: StringNullableWithAggregatesFilter<"agent"> | string | null
    UserRoleId?: IntNullableWithAggregatesFilter<"agent"> | number | null
  }

  export type basecountryWhereInput = {
    AND?: basecountryWhereInput | basecountryWhereInput[]
    OR?: basecountryWhereInput[]
    NOT?: basecountryWhereInput | basecountryWhereInput[]
    BaseCountryID?: IntFilter<"basecountry"> | number
    BaseCountryName?: StringFilter<"basecountry"> | string
    exchangerates?: ExchangeratesListRelationFilter
    fundraiser?: FundraiserListRelationFilter
  }

  export type basecountryOrderByWithRelationInput = {
    BaseCountryID?: SortOrder
    BaseCountryName?: SortOrder
    exchangerates?: exchangeratesOrderByRelationAggregateInput
    fundraiser?: fundraiserOrderByRelationAggregateInput
    _relevance?: basecountryOrderByRelevanceInput
  }

  export type basecountryWhereUniqueInput = Prisma.AtLeast<{
    BaseCountryID?: number
    BaseCountryName?: string
    AND?: basecountryWhereInput | basecountryWhereInput[]
    OR?: basecountryWhereInput[]
    NOT?: basecountryWhereInput | basecountryWhereInput[]
    exchangerates?: ExchangeratesListRelationFilter
    fundraiser?: FundraiserListRelationFilter
  }, "BaseCountryID" | "BaseCountryName">

  export type basecountryOrderByWithAggregationInput = {
    BaseCountryID?: SortOrder
    BaseCountryName?: SortOrder
    _count?: basecountryCountOrderByAggregateInput
    _avg?: basecountryAvgOrderByAggregateInput
    _max?: basecountryMaxOrderByAggregateInput
    _min?: basecountryMinOrderByAggregateInput
    _sum?: basecountrySumOrderByAggregateInput
  }

  export type basecountryScalarWhereWithAggregatesInput = {
    AND?: basecountryScalarWhereWithAggregatesInput | basecountryScalarWhereWithAggregatesInput[]
    OR?: basecountryScalarWhereWithAggregatesInput[]
    NOT?: basecountryScalarWhereWithAggregatesInput | basecountryScalarWhereWithAggregatesInput[]
    BaseCountryID?: IntWithAggregatesFilter<"basecountry"> | number
    BaseCountryName?: StringWithAggregatesFilter<"basecountry"> | string
  }

  export type currencyWhereInput = {
    AND?: currencyWhereInput | currencyWhereInput[]
    OR?: currencyWhereInput[]
    NOT?: currencyWhereInput | currencyWhereInput[]
    CurrencyId?: IntFilter<"currency"> | number
    CurrencyCode?: StringNullableFilter<"currency"> | string | null
    exchangerates?: ExchangeratesListRelationFilter
    fundraiser_acceptedcurrencies?: Fundraiser_acceptedcurrenciesListRelationFilter
    minimumamount?: MinimumamountListRelationFilter
    wallet?: WalletListRelationFilter
  }

  export type currencyOrderByWithRelationInput = {
    CurrencyId?: SortOrder
    CurrencyCode?: SortOrderInput | SortOrder
    exchangerates?: exchangeratesOrderByRelationAggregateInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesOrderByRelationAggregateInput
    minimumamount?: minimumamountOrderByRelationAggregateInput
    wallet?: walletOrderByRelationAggregateInput
    _relevance?: currencyOrderByRelevanceInput
  }

  export type currencyWhereUniqueInput = Prisma.AtLeast<{
    CurrencyId?: number
    AND?: currencyWhereInput | currencyWhereInput[]
    OR?: currencyWhereInput[]
    NOT?: currencyWhereInput | currencyWhereInput[]
    CurrencyCode?: StringNullableFilter<"currency"> | string | null
    exchangerates?: ExchangeratesListRelationFilter
    fundraiser_acceptedcurrencies?: Fundraiser_acceptedcurrenciesListRelationFilter
    minimumamount?: MinimumamountListRelationFilter
    wallet?: WalletListRelationFilter
  }, "CurrencyId">

  export type currencyOrderByWithAggregationInput = {
    CurrencyId?: SortOrder
    CurrencyCode?: SortOrderInput | SortOrder
    _count?: currencyCountOrderByAggregateInput
    _avg?: currencyAvgOrderByAggregateInput
    _max?: currencyMaxOrderByAggregateInput
    _min?: currencyMinOrderByAggregateInput
    _sum?: currencySumOrderByAggregateInput
  }

  export type currencyScalarWhereWithAggregatesInput = {
    AND?: currencyScalarWhereWithAggregatesInput | currencyScalarWhereWithAggregatesInput[]
    OR?: currencyScalarWhereWithAggregatesInput[]
    NOT?: currencyScalarWhereWithAggregatesInput | currencyScalarWhereWithAggregatesInput[]
    CurrencyId?: IntWithAggregatesFilter<"currency"> | number
    CurrencyCode?: StringNullableWithAggregatesFilter<"currency"> | string | null
  }

  export type customerWhereInput = {
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    CustomerId?: IntFilter<"customer"> | number
    Name?: StringNullableFilter<"customer"> | string | null
    Email?: StringNullableFilter<"customer"> | string | null
    ManyChatId?: StringNullableFilter<"customer"> | string | null
    ExpireDate?: DateTimeNullableFilter<"customer"> | Date | string | null
    UserCountry?: StringNullableFilter<"customer"> | string | null
    ContactLink?: StringNullableFilter<"customer"> | string | null
    AgentId?: IntNullableFilter<"customer"> | number | null
    CardID?: IntNullableFilter<"customer"> | number | null
    agent?: XOR<AgentNullableScalarRelationFilter, agentWhereInput> | null
    customerauditlogs?: CustomerauditlogsListRelationFilter
    manychat?: ManychatListRelationFilter
    transactions?: TransactionsListRelationFilter
  }

  export type customerOrderByWithRelationInput = {
    CustomerId?: SortOrder
    Name?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    ManyChatId?: SortOrderInput | SortOrder
    ExpireDate?: SortOrderInput | SortOrder
    UserCountry?: SortOrderInput | SortOrder
    ContactLink?: SortOrderInput | SortOrder
    AgentId?: SortOrderInput | SortOrder
    CardID?: SortOrderInput | SortOrder
    agent?: agentOrderByWithRelationInput
    customerauditlogs?: customerauditlogsOrderByRelationAggregateInput
    manychat?: manychatOrderByRelationAggregateInput
    transactions?: transactionsOrderByRelationAggregateInput
    _relevance?: customerOrderByRelevanceInput
  }

  export type customerWhereUniqueInput = Prisma.AtLeast<{
    CustomerId?: number
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    Name?: StringNullableFilter<"customer"> | string | null
    Email?: StringNullableFilter<"customer"> | string | null
    ManyChatId?: StringNullableFilter<"customer"> | string | null
    ExpireDate?: DateTimeNullableFilter<"customer"> | Date | string | null
    UserCountry?: StringNullableFilter<"customer"> | string | null
    ContactLink?: StringNullableFilter<"customer"> | string | null
    AgentId?: IntNullableFilter<"customer"> | number | null
    CardID?: IntNullableFilter<"customer"> | number | null
    agent?: XOR<AgentNullableScalarRelationFilter, agentWhereInput> | null
    customerauditlogs?: CustomerauditlogsListRelationFilter
    manychat?: ManychatListRelationFilter
    transactions?: TransactionsListRelationFilter
  }, "CustomerId">

  export type customerOrderByWithAggregationInput = {
    CustomerId?: SortOrder
    Name?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    ManyChatId?: SortOrderInput | SortOrder
    ExpireDate?: SortOrderInput | SortOrder
    UserCountry?: SortOrderInput | SortOrder
    ContactLink?: SortOrderInput | SortOrder
    AgentId?: SortOrderInput | SortOrder
    CardID?: SortOrderInput | SortOrder
    _count?: customerCountOrderByAggregateInput
    _avg?: customerAvgOrderByAggregateInput
    _max?: customerMaxOrderByAggregateInput
    _min?: customerMinOrderByAggregateInput
    _sum?: customerSumOrderByAggregateInput
  }

  export type customerScalarWhereWithAggregatesInput = {
    AND?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    OR?: customerScalarWhereWithAggregatesInput[]
    NOT?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    CustomerId?: IntWithAggregatesFilter<"customer"> | number
    Name?: StringNullableWithAggregatesFilter<"customer"> | string | null
    Email?: StringNullableWithAggregatesFilter<"customer"> | string | null
    ManyChatId?: StringNullableWithAggregatesFilter<"customer"> | string | null
    ExpireDate?: DateTimeNullableWithAggregatesFilter<"customer"> | Date | string | null
    UserCountry?: StringNullableWithAggregatesFilter<"customer"> | string | null
    ContactLink?: StringNullableWithAggregatesFilter<"customer"> | string | null
    AgentId?: IntNullableWithAggregatesFilter<"customer"> | number | null
    CardID?: IntNullableWithAggregatesFilter<"customer"> | number | null
  }

  export type customerauditlogsWhereInput = {
    AND?: customerauditlogsWhereInput | customerauditlogsWhereInput[]
    OR?: customerauditlogsWhereInput[]
    NOT?: customerauditlogsWhereInput | customerauditlogsWhereInput[]
    LogId?: IntFilter<"customerauditlogs"> | number
    AgentId?: IntFilter<"customerauditlogs"> | number
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFilter<"customerauditlogs"> | $Enums.customerauditlogs_FieldChanged
    OldValue?: StringNullableFilter<"customerauditlogs"> | string | null
    NewValue?: StringNullableFilter<"customerauditlogs"> | string | null
    CustomerId?: IntFilter<"customerauditlogs"> | number
    ChangeDate?: DateTimeFilter<"customerauditlogs"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, agentWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
  }

  export type customerauditlogsOrderByWithRelationInput = {
    LogId?: SortOrder
    AgentId?: SortOrder
    FieldChanged?: SortOrder
    OldValue?: SortOrderInput | SortOrder
    NewValue?: SortOrderInput | SortOrder
    CustomerId?: SortOrder
    ChangeDate?: SortOrder
    agent?: agentOrderByWithRelationInput
    customer?: customerOrderByWithRelationInput
    _relevance?: customerauditlogsOrderByRelevanceInput
  }

  export type customerauditlogsWhereUniqueInput = Prisma.AtLeast<{
    LogId?: number
    AND?: customerauditlogsWhereInput | customerauditlogsWhereInput[]
    OR?: customerauditlogsWhereInput[]
    NOT?: customerauditlogsWhereInput | customerauditlogsWhereInput[]
    AgentId?: IntFilter<"customerauditlogs"> | number
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFilter<"customerauditlogs"> | $Enums.customerauditlogs_FieldChanged
    OldValue?: StringNullableFilter<"customerauditlogs"> | string | null
    NewValue?: StringNullableFilter<"customerauditlogs"> | string | null
    CustomerId?: IntFilter<"customerauditlogs"> | number
    ChangeDate?: DateTimeFilter<"customerauditlogs"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, agentWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
  }, "LogId">

  export type customerauditlogsOrderByWithAggregationInput = {
    LogId?: SortOrder
    AgentId?: SortOrder
    FieldChanged?: SortOrder
    OldValue?: SortOrderInput | SortOrder
    NewValue?: SortOrderInput | SortOrder
    CustomerId?: SortOrder
    ChangeDate?: SortOrder
    _count?: customerauditlogsCountOrderByAggregateInput
    _avg?: customerauditlogsAvgOrderByAggregateInput
    _max?: customerauditlogsMaxOrderByAggregateInput
    _min?: customerauditlogsMinOrderByAggregateInput
    _sum?: customerauditlogsSumOrderByAggregateInput
  }

  export type customerauditlogsScalarWhereWithAggregatesInput = {
    AND?: customerauditlogsScalarWhereWithAggregatesInput | customerauditlogsScalarWhereWithAggregatesInput[]
    OR?: customerauditlogsScalarWhereWithAggregatesInput[]
    NOT?: customerauditlogsScalarWhereWithAggregatesInput | customerauditlogsScalarWhereWithAggregatesInput[]
    LogId?: IntWithAggregatesFilter<"customerauditlogs"> | number
    AgentId?: IntWithAggregatesFilter<"customerauditlogs"> | number
    FieldChanged?: Enumcustomerauditlogs_FieldChangedWithAggregatesFilter<"customerauditlogs"> | $Enums.customerauditlogs_FieldChanged
    OldValue?: StringNullableWithAggregatesFilter<"customerauditlogs"> | string | null
    NewValue?: StringNullableWithAggregatesFilter<"customerauditlogs"> | string | null
    CustomerId?: IntWithAggregatesFilter<"customerauditlogs"> | number
    ChangeDate?: DateTimeWithAggregatesFilter<"customerauditlogs"> | Date | string
  }

  export type exchangeratesWhereInput = {
    AND?: exchangeratesWhereInput | exchangeratesWhereInput[]
    OR?: exchangeratesWhereInput[]
    NOT?: exchangeratesWhereInput | exchangeratesWhereInput[]
    ExchangeRateId?: IntFilter<"exchangerates"> | number
    BaseCountryId?: IntFilter<"exchangerates"> | number
    CurrencyId?: IntFilter<"exchangerates"> | number
    ExchangeRate?: DecimalFilter<"exchangerates"> | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFilter<"exchangerates"> | Date | string
    UpdatedAt?: DateTimeFilter<"exchangerates"> | Date | string
    basecountry?: XOR<BasecountryScalarRelationFilter, basecountryWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, currencyWhereInput>
  }

  export type exchangeratesOrderByWithRelationInput = {
    ExchangeRateId?: SortOrder
    BaseCountryId?: SortOrder
    CurrencyId?: SortOrder
    ExchangeRate?: SortOrder
    CreateAt?: SortOrder
    UpdatedAt?: SortOrder
    basecountry?: basecountryOrderByWithRelationInput
    currency?: currencyOrderByWithRelationInput
  }

  export type exchangeratesWhereUniqueInput = Prisma.AtLeast<{
    ExchangeRateId?: number
    AND?: exchangeratesWhereInput | exchangeratesWhereInput[]
    OR?: exchangeratesWhereInput[]
    NOT?: exchangeratesWhereInput | exchangeratesWhereInput[]
    BaseCountryId?: IntFilter<"exchangerates"> | number
    CurrencyId?: IntFilter<"exchangerates"> | number
    ExchangeRate?: DecimalFilter<"exchangerates"> | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFilter<"exchangerates"> | Date | string
    UpdatedAt?: DateTimeFilter<"exchangerates"> | Date | string
    basecountry?: XOR<BasecountryScalarRelationFilter, basecountryWhereInput>
    currency?: XOR<CurrencyScalarRelationFilter, currencyWhereInput>
  }, "ExchangeRateId">

  export type exchangeratesOrderByWithAggregationInput = {
    ExchangeRateId?: SortOrder
    BaseCountryId?: SortOrder
    CurrencyId?: SortOrder
    ExchangeRate?: SortOrder
    CreateAt?: SortOrder
    UpdatedAt?: SortOrder
    _count?: exchangeratesCountOrderByAggregateInput
    _avg?: exchangeratesAvgOrderByAggregateInput
    _max?: exchangeratesMaxOrderByAggregateInput
    _min?: exchangeratesMinOrderByAggregateInput
    _sum?: exchangeratesSumOrderByAggregateInput
  }

  export type exchangeratesScalarWhereWithAggregatesInput = {
    AND?: exchangeratesScalarWhereWithAggregatesInput | exchangeratesScalarWhereWithAggregatesInput[]
    OR?: exchangeratesScalarWhereWithAggregatesInput[]
    NOT?: exchangeratesScalarWhereWithAggregatesInput | exchangeratesScalarWhereWithAggregatesInput[]
    ExchangeRateId?: IntWithAggregatesFilter<"exchangerates"> | number
    BaseCountryId?: IntWithAggregatesFilter<"exchangerates"> | number
    CurrencyId?: IntWithAggregatesFilter<"exchangerates"> | number
    ExchangeRate?: DecimalWithAggregatesFilter<"exchangerates"> | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeWithAggregatesFilter<"exchangerates"> | Date | string
    UpdatedAt?: DateTimeWithAggregatesFilter<"exchangerates"> | Date | string
  }

  export type formstatusWhereInput = {
    AND?: formstatusWhereInput | formstatusWhereInput[]
    OR?: formstatusWhereInput[]
    NOT?: formstatusWhereInput | formstatusWhereInput[]
    FormStatusID?: IntFilter<"formstatus"> | number
    TransactionID?: IntNullableFilter<"formstatus"> | number | null
    TransactionStatusID?: IntNullableFilter<"formstatus"> | number | null
    transactions?: XOR<TransactionsNullableScalarRelationFilter, transactionsWhereInput> | null
    transactionstatus?: XOR<TransactionstatusNullableScalarRelationFilter, transactionstatusWhereInput> | null
  }

  export type formstatusOrderByWithRelationInput = {
    FormStatusID?: SortOrder
    TransactionID?: SortOrderInput | SortOrder
    TransactionStatusID?: SortOrderInput | SortOrder
    transactions?: transactionsOrderByWithRelationInput
    transactionstatus?: transactionstatusOrderByWithRelationInput
  }

  export type formstatusWhereUniqueInput = Prisma.AtLeast<{
    FormStatusID?: number
    AND?: formstatusWhereInput | formstatusWhereInput[]
    OR?: formstatusWhereInput[]
    NOT?: formstatusWhereInput | formstatusWhereInput[]
    TransactionID?: IntNullableFilter<"formstatus"> | number | null
    TransactionStatusID?: IntNullableFilter<"formstatus"> | number | null
    transactions?: XOR<TransactionsNullableScalarRelationFilter, transactionsWhereInput> | null
    transactionstatus?: XOR<TransactionstatusNullableScalarRelationFilter, transactionstatusWhereInput> | null
  }, "FormStatusID">

  export type formstatusOrderByWithAggregationInput = {
    FormStatusID?: SortOrder
    TransactionID?: SortOrderInput | SortOrder
    TransactionStatusID?: SortOrderInput | SortOrder
    _count?: formstatusCountOrderByAggregateInput
    _avg?: formstatusAvgOrderByAggregateInput
    _max?: formstatusMaxOrderByAggregateInput
    _min?: formstatusMinOrderByAggregateInput
    _sum?: formstatusSumOrderByAggregateInput
  }

  export type formstatusScalarWhereWithAggregatesInput = {
    AND?: formstatusScalarWhereWithAggregatesInput | formstatusScalarWhereWithAggregatesInput[]
    OR?: formstatusScalarWhereWithAggregatesInput[]
    NOT?: formstatusScalarWhereWithAggregatesInput | formstatusScalarWhereWithAggregatesInput[]
    FormStatusID?: IntWithAggregatesFilter<"formstatus"> | number
    TransactionID?: IntNullableWithAggregatesFilter<"formstatus"> | number | null
    TransactionStatusID?: IntNullableWithAggregatesFilter<"formstatus"> | number | null
  }

  export type formvisibilitystatusWhereInput = {
    AND?: formvisibilitystatusWhereInput | formvisibilitystatusWhereInput[]
    OR?: formvisibilitystatusWhereInput[]
    NOT?: formvisibilitystatusWhereInput | formvisibilitystatusWhereInput[]
    VisibilityStatusId?: IntFilter<"formvisibilitystatus"> | number
    AgentId?: IntFilter<"formvisibilitystatus"> | number
    IsFormOpen?: BoolFilter<"formvisibilitystatus"> | boolean
    FormTimeStamp?: DateTimeFilter<"formvisibilitystatus"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, agentWhereInput>
  }

  export type formvisibilitystatusOrderByWithRelationInput = {
    VisibilityStatusId?: SortOrder
    AgentId?: SortOrder
    IsFormOpen?: SortOrder
    FormTimeStamp?: SortOrder
    agent?: agentOrderByWithRelationInput
  }

  export type formvisibilitystatusWhereUniqueInput = Prisma.AtLeast<{
    VisibilityStatusId?: number
    AND?: formvisibilitystatusWhereInput | formvisibilitystatusWhereInput[]
    OR?: formvisibilitystatusWhereInput[]
    NOT?: formvisibilitystatusWhereInput | formvisibilitystatusWhereInput[]
    AgentId?: IntFilter<"formvisibilitystatus"> | number
    IsFormOpen?: BoolFilter<"formvisibilitystatus"> | boolean
    FormTimeStamp?: DateTimeFilter<"formvisibilitystatus"> | Date | string
    agent?: XOR<AgentScalarRelationFilter, agentWhereInput>
  }, "VisibilityStatusId">

  export type formvisibilitystatusOrderByWithAggregationInput = {
    VisibilityStatusId?: SortOrder
    AgentId?: SortOrder
    IsFormOpen?: SortOrder
    FormTimeStamp?: SortOrder
    _count?: formvisibilitystatusCountOrderByAggregateInput
    _avg?: formvisibilitystatusAvgOrderByAggregateInput
    _max?: formvisibilitystatusMaxOrderByAggregateInput
    _min?: formvisibilitystatusMinOrderByAggregateInput
    _sum?: formvisibilitystatusSumOrderByAggregateInput
  }

  export type formvisibilitystatusScalarWhereWithAggregatesInput = {
    AND?: formvisibilitystatusScalarWhereWithAggregatesInput | formvisibilitystatusScalarWhereWithAggregatesInput[]
    OR?: formvisibilitystatusScalarWhereWithAggregatesInput[]
    NOT?: formvisibilitystatusScalarWhereWithAggregatesInput | formvisibilitystatusScalarWhereWithAggregatesInput[]
    VisibilityStatusId?: IntWithAggregatesFilter<"formvisibilitystatus"> | number
    AgentId?: IntWithAggregatesFilter<"formvisibilitystatus"> | number
    IsFormOpen?: BoolWithAggregatesFilter<"formvisibilitystatus"> | boolean
    FormTimeStamp?: DateTimeWithAggregatesFilter<"formvisibilitystatus"> | Date | string
  }

  export type fundraiserWhereInput = {
    AND?: fundraiserWhereInput | fundraiserWhereInput[]
    OR?: fundraiserWhereInput[]
    NOT?: fundraiserWhereInput | fundraiserWhereInput[]
    FundraiserID?: IntFilter<"fundraiser"> | number
    FundraiserName?: StringFilter<"fundraiser"> | string
    FundraiserEmail?: StringFilter<"fundraiser"> | string
    FundraiserLogo?: StringNullableFilter<"fundraiser"> | string | null
    BaseCountryID?: IntNullableFilter<"fundraiser"> | number | null
    FundraiserCentralID?: IntNullableFilter<"fundraiser"> | number | null
    basecountry?: XOR<BasecountryNullableScalarRelationFilter, basecountryWhereInput> | null
    fundraiser_acceptedcurrencies?: Fundraiser_acceptedcurrenciesListRelationFilter
    fundraiser_contactlinks?: Fundraiser_contactlinksListRelationFilter
  }

  export type fundraiserOrderByWithRelationInput = {
    FundraiserID?: SortOrder
    FundraiserName?: SortOrder
    FundraiserEmail?: SortOrder
    FundraiserLogo?: SortOrderInput | SortOrder
    BaseCountryID?: SortOrderInput | SortOrder
    FundraiserCentralID?: SortOrderInput | SortOrder
    basecountry?: basecountryOrderByWithRelationInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesOrderByRelationAggregateInput
    fundraiser_contactlinks?: fundraiser_contactlinksOrderByRelationAggregateInput
    _relevance?: fundraiserOrderByRelevanceInput
  }

  export type fundraiserWhereUniqueInput = Prisma.AtLeast<{
    FundraiserID?: number
    FundraiserEmail?: string
    AND?: fundraiserWhereInput | fundraiserWhereInput[]
    OR?: fundraiserWhereInput[]
    NOT?: fundraiserWhereInput | fundraiserWhereInput[]
    FundraiserName?: StringFilter<"fundraiser"> | string
    FundraiserLogo?: StringNullableFilter<"fundraiser"> | string | null
    BaseCountryID?: IntNullableFilter<"fundraiser"> | number | null
    FundraiserCentralID?: IntNullableFilter<"fundraiser"> | number | null
    basecountry?: XOR<BasecountryNullableScalarRelationFilter, basecountryWhereInput> | null
    fundraiser_acceptedcurrencies?: Fundraiser_acceptedcurrenciesListRelationFilter
    fundraiser_contactlinks?: Fundraiser_contactlinksListRelationFilter
  }, "FundraiserID" | "FundraiserEmail">

  export type fundraiserOrderByWithAggregationInput = {
    FundraiserID?: SortOrder
    FundraiserName?: SortOrder
    FundraiserEmail?: SortOrder
    FundraiserLogo?: SortOrderInput | SortOrder
    BaseCountryID?: SortOrderInput | SortOrder
    FundraiserCentralID?: SortOrderInput | SortOrder
    _count?: fundraiserCountOrderByAggregateInput
    _avg?: fundraiserAvgOrderByAggregateInput
    _max?: fundraiserMaxOrderByAggregateInput
    _min?: fundraiserMinOrderByAggregateInput
    _sum?: fundraiserSumOrderByAggregateInput
  }

  export type fundraiserScalarWhereWithAggregatesInput = {
    AND?: fundraiserScalarWhereWithAggregatesInput | fundraiserScalarWhereWithAggregatesInput[]
    OR?: fundraiserScalarWhereWithAggregatesInput[]
    NOT?: fundraiserScalarWhereWithAggregatesInput | fundraiserScalarWhereWithAggregatesInput[]
    FundraiserID?: IntWithAggregatesFilter<"fundraiser"> | number
    FundraiserName?: StringWithAggregatesFilter<"fundraiser"> | string
    FundraiserEmail?: StringWithAggregatesFilter<"fundraiser"> | string
    FundraiserLogo?: StringNullableWithAggregatesFilter<"fundraiser"> | string | null
    BaseCountryID?: IntNullableWithAggregatesFilter<"fundraiser"> | number | null
    FundraiserCentralID?: IntNullableWithAggregatesFilter<"fundraiser"> | number | null
  }

  export type fundraiser_acceptedcurrenciesWhereInput = {
    AND?: fundraiser_acceptedcurrenciesWhereInput | fundraiser_acceptedcurrenciesWhereInput[]
    OR?: fundraiser_acceptedcurrenciesWhereInput[]
    NOT?: fundraiser_acceptedcurrenciesWhereInput | fundraiser_acceptedcurrenciesWhereInput[]
    FundraiserAcceptedCurrencyID?: IntFilter<"fundraiser_acceptedcurrencies"> | number
    FundraiserID?: IntNullableFilter<"fundraiser_acceptedcurrencies"> | number | null
    CurrencyID?: IntNullableFilter<"fundraiser_acceptedcurrencies"> | number | null
    fundraiser?: XOR<FundraiserNullableScalarRelationFilter, fundraiserWhereInput> | null
    currency?: XOR<CurrencyNullableScalarRelationFilter, currencyWhereInput> | null
  }

  export type fundraiser_acceptedcurrenciesOrderByWithRelationInput = {
    FundraiserAcceptedCurrencyID?: SortOrder
    FundraiserID?: SortOrderInput | SortOrder
    CurrencyID?: SortOrderInput | SortOrder
    fundraiser?: fundraiserOrderByWithRelationInput
    currency?: currencyOrderByWithRelationInput
  }

  export type fundraiser_acceptedcurrenciesWhereUniqueInput = Prisma.AtLeast<{
    FundraiserAcceptedCurrencyID?: number
    AND?: fundraiser_acceptedcurrenciesWhereInput | fundraiser_acceptedcurrenciesWhereInput[]
    OR?: fundraiser_acceptedcurrenciesWhereInput[]
    NOT?: fundraiser_acceptedcurrenciesWhereInput | fundraiser_acceptedcurrenciesWhereInput[]
    FundraiserID?: IntNullableFilter<"fundraiser_acceptedcurrencies"> | number | null
    CurrencyID?: IntNullableFilter<"fundraiser_acceptedcurrencies"> | number | null
    fundraiser?: XOR<FundraiserNullableScalarRelationFilter, fundraiserWhereInput> | null
    currency?: XOR<CurrencyNullableScalarRelationFilter, currencyWhereInput> | null
  }, "FundraiserAcceptedCurrencyID">

  export type fundraiser_acceptedcurrenciesOrderByWithAggregationInput = {
    FundraiserAcceptedCurrencyID?: SortOrder
    FundraiserID?: SortOrderInput | SortOrder
    CurrencyID?: SortOrderInput | SortOrder
    _count?: fundraiser_acceptedcurrenciesCountOrderByAggregateInput
    _avg?: fundraiser_acceptedcurrenciesAvgOrderByAggregateInput
    _max?: fundraiser_acceptedcurrenciesMaxOrderByAggregateInput
    _min?: fundraiser_acceptedcurrenciesMinOrderByAggregateInput
    _sum?: fundraiser_acceptedcurrenciesSumOrderByAggregateInput
  }

  export type fundraiser_acceptedcurrenciesScalarWhereWithAggregatesInput = {
    AND?: fundraiser_acceptedcurrenciesScalarWhereWithAggregatesInput | fundraiser_acceptedcurrenciesScalarWhereWithAggregatesInput[]
    OR?: fundraiser_acceptedcurrenciesScalarWhereWithAggregatesInput[]
    NOT?: fundraiser_acceptedcurrenciesScalarWhereWithAggregatesInput | fundraiser_acceptedcurrenciesScalarWhereWithAggregatesInput[]
    FundraiserAcceptedCurrencyID?: IntWithAggregatesFilter<"fundraiser_acceptedcurrencies"> | number
    FundraiserID?: IntNullableWithAggregatesFilter<"fundraiser_acceptedcurrencies"> | number | null
    CurrencyID?: IntNullableWithAggregatesFilter<"fundraiser_acceptedcurrencies"> | number | null
  }

  export type fundraiser_contactlinksWhereInput = {
    AND?: fundraiser_contactlinksWhereInput | fundraiser_contactlinksWhereInput[]
    OR?: fundraiser_contactlinksWhereInput[]
    NOT?: fundraiser_contactlinksWhereInput | fundraiser_contactlinksWhereInput[]
    ContactID?: IntFilter<"fundraiser_contactlinks"> | number
    FundraiserID?: IntNullableFilter<"fundraiser_contactlinks"> | number | null
    Platform?: IntNullableFilter<"fundraiser_contactlinks"> | number | null
    ContactURL?: StringFilter<"fundraiser_contactlinks"> | string
    fundraiser?: XOR<FundraiserNullableScalarRelationFilter, fundraiserWhereInput> | null
  }

  export type fundraiser_contactlinksOrderByWithRelationInput = {
    ContactID?: SortOrder
    FundraiserID?: SortOrderInput | SortOrder
    Platform?: SortOrderInput | SortOrder
    ContactURL?: SortOrder
    fundraiser?: fundraiserOrderByWithRelationInput
    _relevance?: fundraiser_contactlinksOrderByRelevanceInput
  }

  export type fundraiser_contactlinksWhereUniqueInput = Prisma.AtLeast<{
    ContactID?: number
    AND?: fundraiser_contactlinksWhereInput | fundraiser_contactlinksWhereInput[]
    OR?: fundraiser_contactlinksWhereInput[]
    NOT?: fundraiser_contactlinksWhereInput | fundraiser_contactlinksWhereInput[]
    FundraiserID?: IntNullableFilter<"fundraiser_contactlinks"> | number | null
    Platform?: IntNullableFilter<"fundraiser_contactlinks"> | number | null
    ContactURL?: StringFilter<"fundraiser_contactlinks"> | string
    fundraiser?: XOR<FundraiserNullableScalarRelationFilter, fundraiserWhereInput> | null
  }, "ContactID">

  export type fundraiser_contactlinksOrderByWithAggregationInput = {
    ContactID?: SortOrder
    FundraiserID?: SortOrderInput | SortOrder
    Platform?: SortOrderInput | SortOrder
    ContactURL?: SortOrder
    _count?: fundraiser_contactlinksCountOrderByAggregateInput
    _avg?: fundraiser_contactlinksAvgOrderByAggregateInput
    _max?: fundraiser_contactlinksMaxOrderByAggregateInput
    _min?: fundraiser_contactlinksMinOrderByAggregateInput
    _sum?: fundraiser_contactlinksSumOrderByAggregateInput
  }

  export type fundraiser_contactlinksScalarWhereWithAggregatesInput = {
    AND?: fundraiser_contactlinksScalarWhereWithAggregatesInput | fundraiser_contactlinksScalarWhereWithAggregatesInput[]
    OR?: fundraiser_contactlinksScalarWhereWithAggregatesInput[]
    NOT?: fundraiser_contactlinksScalarWhereWithAggregatesInput | fundraiser_contactlinksScalarWhereWithAggregatesInput[]
    ContactID?: IntWithAggregatesFilter<"fundraiser_contactlinks"> | number
    FundraiserID?: IntNullableWithAggregatesFilter<"fundraiser_contactlinks"> | number | null
    Platform?: IntNullableWithAggregatesFilter<"fundraiser_contactlinks"> | number | null
    ContactURL?: StringWithAggregatesFilter<"fundraiser_contactlinks"> | string
  }

  export type manychatWhereInput = {
    AND?: manychatWhereInput | manychatWhereInput[]
    OR?: manychatWhereInput[]
    NOT?: manychatWhereInput | manychatWhereInput[]
    ManyChatId?: IntFilter<"manychat"> | number
    ConversationId?: StringFilter<"manychat"> | string
    CustomerId?: IntFilter<"manychat"> | number
    CreateAt?: DateTimeFilter<"manychat"> | Date | string
    UpdateAt?: DateTimeFilter<"manychat"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
  }

  export type manychatOrderByWithRelationInput = {
    ManyChatId?: SortOrder
    ConversationId?: SortOrder
    CustomerId?: SortOrder
    CreateAt?: SortOrder
    UpdateAt?: SortOrder
    customer?: customerOrderByWithRelationInput
    _relevance?: manychatOrderByRelevanceInput
  }

  export type manychatWhereUniqueInput = Prisma.AtLeast<{
    ManyChatId?: number
    AND?: manychatWhereInput | manychatWhereInput[]
    OR?: manychatWhereInput[]
    NOT?: manychatWhereInput | manychatWhereInput[]
    ConversationId?: StringFilter<"manychat"> | string
    CustomerId?: IntFilter<"manychat"> | number
    CreateAt?: DateTimeFilter<"manychat"> | Date | string
    UpdateAt?: DateTimeFilter<"manychat"> | Date | string
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
  }, "ManyChatId">

  export type manychatOrderByWithAggregationInput = {
    ManyChatId?: SortOrder
    ConversationId?: SortOrder
    CustomerId?: SortOrder
    CreateAt?: SortOrder
    UpdateAt?: SortOrder
    _count?: manychatCountOrderByAggregateInput
    _avg?: manychatAvgOrderByAggregateInput
    _max?: manychatMaxOrderByAggregateInput
    _min?: manychatMinOrderByAggregateInput
    _sum?: manychatSumOrderByAggregateInput
  }

  export type manychatScalarWhereWithAggregatesInput = {
    AND?: manychatScalarWhereWithAggregatesInput | manychatScalarWhereWithAggregatesInput[]
    OR?: manychatScalarWhereWithAggregatesInput[]
    NOT?: manychatScalarWhereWithAggregatesInput | manychatScalarWhereWithAggregatesInput[]
    ManyChatId?: IntWithAggregatesFilter<"manychat"> | number
    ConversationId?: StringWithAggregatesFilter<"manychat"> | string
    CustomerId?: IntWithAggregatesFilter<"manychat"> | number
    CreateAt?: DateTimeWithAggregatesFilter<"manychat"> | Date | string
    UpdateAt?: DateTimeWithAggregatesFilter<"manychat"> | Date | string
  }

  export type minimumamountWhereInput = {
    AND?: minimumamountWhereInput | minimumamountWhereInput[]
    OR?: minimumamountWhereInput[]
    NOT?: minimumamountWhereInput | minimumamountWhereInput[]
    MinimumAmountId?: IntFilter<"minimumamount"> | number
    CurrencyId?: IntFilter<"minimumamount"> | number
    Amount?: DecimalFilter<"minimumamount"> | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFilter<"minimumamount"> | Date | string
    UpdatedAt?: DateTimeFilter<"minimumamount"> | Date | string
    currency?: XOR<CurrencyScalarRelationFilter, currencyWhereInput>
  }

  export type minimumamountOrderByWithRelationInput = {
    MinimumAmountId?: SortOrder
    CurrencyId?: SortOrder
    Amount?: SortOrder
    CreateAt?: SortOrder
    UpdatedAt?: SortOrder
    currency?: currencyOrderByWithRelationInput
  }

  export type minimumamountWhereUniqueInput = Prisma.AtLeast<{
    MinimumAmountId?: number
    AND?: minimumamountWhereInput | minimumamountWhereInput[]
    OR?: minimumamountWhereInput[]
    NOT?: minimumamountWhereInput | minimumamountWhereInput[]
    CurrencyId?: IntFilter<"minimumamount"> | number
    Amount?: DecimalFilter<"minimumamount"> | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFilter<"minimumamount"> | Date | string
    UpdatedAt?: DateTimeFilter<"minimumamount"> | Date | string
    currency?: XOR<CurrencyScalarRelationFilter, currencyWhereInput>
  }, "MinimumAmountId">

  export type minimumamountOrderByWithAggregationInput = {
    MinimumAmountId?: SortOrder
    CurrencyId?: SortOrder
    Amount?: SortOrder
    CreateAt?: SortOrder
    UpdatedAt?: SortOrder
    _count?: minimumamountCountOrderByAggregateInput
    _avg?: minimumamountAvgOrderByAggregateInput
    _max?: minimumamountMaxOrderByAggregateInput
    _min?: minimumamountMinOrderByAggregateInput
    _sum?: minimumamountSumOrderByAggregateInput
  }

  export type minimumamountScalarWhereWithAggregatesInput = {
    AND?: minimumamountScalarWhereWithAggregatesInput | minimumamountScalarWhereWithAggregatesInput[]
    OR?: minimumamountScalarWhereWithAggregatesInput[]
    NOT?: minimumamountScalarWhereWithAggregatesInput | minimumamountScalarWhereWithAggregatesInput[]
    MinimumAmountId?: IntWithAggregatesFilter<"minimumamount"> | number
    CurrencyId?: IntWithAggregatesFilter<"minimumamount"> | number
    Amount?: DecimalWithAggregatesFilter<"minimumamount"> | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeWithAggregatesFilter<"minimumamount"> | Date | string
    UpdatedAt?: DateTimeWithAggregatesFilter<"minimumamount"> | Date | string
  }

  export type noteWhereInput = {
    AND?: noteWhereInput | noteWhereInput[]
    OR?: noteWhereInput[]
    NOT?: noteWhereInput | noteWhereInput[]
    NoteID?: IntFilter<"note"> | number
    Note?: StringNullableFilter<"note"> | string | null
    Date?: DateTimeNullableFilter<"note"> | Date | string | null
    AgentID?: IntNullableFilter<"note"> | number | null
    agent?: XOR<AgentNullableScalarRelationFilter, agentWhereInput> | null
    transactions?: TransactionsListRelationFilter
  }

  export type noteOrderByWithRelationInput = {
    NoteID?: SortOrder
    Note?: SortOrderInput | SortOrder
    Date?: SortOrderInput | SortOrder
    AgentID?: SortOrderInput | SortOrder
    agent?: agentOrderByWithRelationInput
    transactions?: transactionsOrderByRelationAggregateInput
    _relevance?: noteOrderByRelevanceInput
  }

  export type noteWhereUniqueInput = Prisma.AtLeast<{
    NoteID?: number
    AND?: noteWhereInput | noteWhereInput[]
    OR?: noteWhereInput[]
    NOT?: noteWhereInput | noteWhereInput[]
    Note?: StringNullableFilter<"note"> | string | null
    Date?: DateTimeNullableFilter<"note"> | Date | string | null
    AgentID?: IntNullableFilter<"note"> | number | null
    agent?: XOR<AgentNullableScalarRelationFilter, agentWhereInput> | null
    transactions?: TransactionsListRelationFilter
  }, "NoteID">

  export type noteOrderByWithAggregationInput = {
    NoteID?: SortOrder
    Note?: SortOrderInput | SortOrder
    Date?: SortOrderInput | SortOrder
    AgentID?: SortOrderInput | SortOrder
    _count?: noteCountOrderByAggregateInput
    _avg?: noteAvgOrderByAggregateInput
    _max?: noteMaxOrderByAggregateInput
    _min?: noteMinOrderByAggregateInput
    _sum?: noteSumOrderByAggregateInput
  }

  export type noteScalarWhereWithAggregatesInput = {
    AND?: noteScalarWhereWithAggregatesInput | noteScalarWhereWithAggregatesInput[]
    OR?: noteScalarWhereWithAggregatesInput[]
    NOT?: noteScalarWhereWithAggregatesInput | noteScalarWhereWithAggregatesInput[]
    NoteID?: IntWithAggregatesFilter<"note"> | number
    Note?: StringNullableWithAggregatesFilter<"note"> | string | null
    Date?: DateTimeNullableWithAggregatesFilter<"note"> | Date | string | null
    AgentID?: IntNullableWithAggregatesFilter<"note"> | number | null
  }

  export type platformWhereInput = {
    AND?: platformWhereInput | platformWhereInput[]
    OR?: platformWhereInput[]
    NOT?: platformWhereInput | platformWhereInput[]
    PlatformID?: IntFilter<"platform"> | number
    PlatformName?: StringFilter<"platform"> | string
  }

  export type platformOrderByWithRelationInput = {
    PlatformID?: SortOrder
    PlatformName?: SortOrder
    _relevance?: platformOrderByRelevanceInput
  }

  export type platformWhereUniqueInput = Prisma.AtLeast<{
    PlatformID?: number
    PlatformName?: string
    AND?: platformWhereInput | platformWhereInput[]
    OR?: platformWhereInput[]
    NOT?: platformWhereInput | platformWhereInput[]
  }, "PlatformID" | "PlatformName">

  export type platformOrderByWithAggregationInput = {
    PlatformID?: SortOrder
    PlatformName?: SortOrder
    _count?: platformCountOrderByAggregateInput
    _avg?: platformAvgOrderByAggregateInput
    _max?: platformMaxOrderByAggregateInput
    _min?: platformMinOrderByAggregateInput
    _sum?: platformSumOrderByAggregateInput
  }

  export type platformScalarWhereWithAggregatesInput = {
    AND?: platformScalarWhereWithAggregatesInput | platformScalarWhereWithAggregatesInput[]
    OR?: platformScalarWhereWithAggregatesInput[]
    NOT?: platformScalarWhereWithAggregatesInput | platformScalarWhereWithAggregatesInput[]
    PlatformID?: IntWithAggregatesFilter<"platform"> | number
    PlatformName?: StringWithAggregatesFilter<"platform"> | string
  }

  export type screenshotWhereInput = {
    AND?: screenshotWhereInput | screenshotWhereInput[]
    OR?: screenshotWhereInput[]
    NOT?: screenshotWhereInput | screenshotWhereInput[]
    ScreenShotID?: IntFilter<"screenshot"> | number
    TransactionID?: IntNullableFilter<"screenshot"> | number | null
    ScreenShotLink?: StringNullableFilter<"screenshot"> | string | null
    transactions?: XOR<TransactionsNullableScalarRelationFilter, transactionsWhereInput> | null
  }

  export type screenshotOrderByWithRelationInput = {
    ScreenShotID?: SortOrder
    TransactionID?: SortOrderInput | SortOrder
    ScreenShotLink?: SortOrderInput | SortOrder
    transactions?: transactionsOrderByWithRelationInput
    _relevance?: screenshotOrderByRelevanceInput
  }

  export type screenshotWhereUniqueInput = Prisma.AtLeast<{
    ScreenShotID?: number
    AND?: screenshotWhereInput | screenshotWhereInput[]
    OR?: screenshotWhereInput[]
    NOT?: screenshotWhereInput | screenshotWhereInput[]
    TransactionID?: IntNullableFilter<"screenshot"> | number | null
    ScreenShotLink?: StringNullableFilter<"screenshot"> | string | null
    transactions?: XOR<TransactionsNullableScalarRelationFilter, transactionsWhereInput> | null
  }, "ScreenShotID">

  export type screenshotOrderByWithAggregationInput = {
    ScreenShotID?: SortOrder
    TransactionID?: SortOrderInput | SortOrder
    ScreenShotLink?: SortOrderInput | SortOrder
    _count?: screenshotCountOrderByAggregateInput
    _avg?: screenshotAvgOrderByAggregateInput
    _max?: screenshotMaxOrderByAggregateInput
    _min?: screenshotMinOrderByAggregateInput
    _sum?: screenshotSumOrderByAggregateInput
  }

  export type screenshotScalarWhereWithAggregatesInput = {
    AND?: screenshotScalarWhereWithAggregatesInput | screenshotScalarWhereWithAggregatesInput[]
    OR?: screenshotScalarWhereWithAggregatesInput[]
    NOT?: screenshotScalarWhereWithAggregatesInput | screenshotScalarWhereWithAggregatesInput[]
    ScreenShotID?: IntWithAggregatesFilter<"screenshot"> | number
    TransactionID?: IntNullableWithAggregatesFilter<"screenshot"> | number | null
    ScreenShotLink?: StringNullableWithAggregatesFilter<"screenshot"> | string | null
  }

  export type supportregionWhereInput = {
    AND?: supportregionWhereInput | supportregionWhereInput[]
    OR?: supportregionWhereInput[]
    NOT?: supportregionWhereInput | supportregionWhereInput[]
    SupportRegionID?: IntFilter<"supportregion"> | number
    Region?: StringNullableFilter<"supportregion"> | string | null
    transactions?: TransactionsListRelationFilter
  }

  export type supportregionOrderByWithRelationInput = {
    SupportRegionID?: SortOrder
    Region?: SortOrderInput | SortOrder
    transactions?: transactionsOrderByRelationAggregateInput
    _relevance?: supportregionOrderByRelevanceInput
  }

  export type supportregionWhereUniqueInput = Prisma.AtLeast<{
    SupportRegionID?: number
    AND?: supportregionWhereInput | supportregionWhereInput[]
    OR?: supportregionWhereInput[]
    NOT?: supportregionWhereInput | supportregionWhereInput[]
    Region?: StringNullableFilter<"supportregion"> | string | null
    transactions?: TransactionsListRelationFilter
  }, "SupportRegionID">

  export type supportregionOrderByWithAggregationInput = {
    SupportRegionID?: SortOrder
    Region?: SortOrderInput | SortOrder
    _count?: supportregionCountOrderByAggregateInput
    _avg?: supportregionAvgOrderByAggregateInput
    _max?: supportregionMaxOrderByAggregateInput
    _min?: supportregionMinOrderByAggregateInput
    _sum?: supportregionSumOrderByAggregateInput
  }

  export type supportregionScalarWhereWithAggregatesInput = {
    AND?: supportregionScalarWhereWithAggregatesInput | supportregionScalarWhereWithAggregatesInput[]
    OR?: supportregionScalarWhereWithAggregatesInput[]
    NOT?: supportregionScalarWhereWithAggregatesInput | supportregionScalarWhereWithAggregatesInput[]
    SupportRegionID?: IntWithAggregatesFilter<"supportregion"> | number
    Region?: StringNullableWithAggregatesFilter<"supportregion"> | string | null
  }

  export type transactionagentWhereInput = {
    AND?: transactionagentWhereInput | transactionagentWhereInput[]
    OR?: transactionagentWhereInput[]
    NOT?: transactionagentWhereInput | transactionagentWhereInput[]
    TransactionAgentID?: IntFilter<"transactionagent"> | number
    TransactionID?: IntNullableFilter<"transactionagent"> | number | null
    AgentID?: IntNullableFilter<"transactionagent"> | number | null
    LogDate?: DateTimeFilter<"transactionagent"> | Date | string
    transactions?: XOR<TransactionsNullableScalarRelationFilter, transactionsWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, agentWhereInput> | null
  }

  export type transactionagentOrderByWithRelationInput = {
    TransactionAgentID?: SortOrder
    TransactionID?: SortOrderInput | SortOrder
    AgentID?: SortOrderInput | SortOrder
    LogDate?: SortOrder
    transactions?: transactionsOrderByWithRelationInput
    agent?: agentOrderByWithRelationInput
  }

  export type transactionagentWhereUniqueInput = Prisma.AtLeast<{
    TransactionAgentID?: number
    AND?: transactionagentWhereInput | transactionagentWhereInput[]
    OR?: transactionagentWhereInput[]
    NOT?: transactionagentWhereInput | transactionagentWhereInput[]
    TransactionID?: IntNullableFilter<"transactionagent"> | number | null
    AgentID?: IntNullableFilter<"transactionagent"> | number | null
    LogDate?: DateTimeFilter<"transactionagent"> | Date | string
    transactions?: XOR<TransactionsNullableScalarRelationFilter, transactionsWhereInput> | null
    agent?: XOR<AgentNullableScalarRelationFilter, agentWhereInput> | null
  }, "TransactionAgentID">

  export type transactionagentOrderByWithAggregationInput = {
    TransactionAgentID?: SortOrder
    TransactionID?: SortOrderInput | SortOrder
    AgentID?: SortOrderInput | SortOrder
    LogDate?: SortOrder
    _count?: transactionagentCountOrderByAggregateInput
    _avg?: transactionagentAvgOrderByAggregateInput
    _max?: transactionagentMaxOrderByAggregateInput
    _min?: transactionagentMinOrderByAggregateInput
    _sum?: transactionagentSumOrderByAggregateInput
  }

  export type transactionagentScalarWhereWithAggregatesInput = {
    AND?: transactionagentScalarWhereWithAggregatesInput | transactionagentScalarWhereWithAggregatesInput[]
    OR?: transactionagentScalarWhereWithAggregatesInput[]
    NOT?: transactionagentScalarWhereWithAggregatesInput | transactionagentScalarWhereWithAggregatesInput[]
    TransactionAgentID?: IntWithAggregatesFilter<"transactionagent"> | number
    TransactionID?: IntNullableWithAggregatesFilter<"transactionagent"> | number | null
    AgentID?: IntNullableWithAggregatesFilter<"transactionagent"> | number | null
    LogDate?: DateTimeWithAggregatesFilter<"transactionagent"> | Date | string
  }

  export type transactionsWhereInput = {
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    TransactionID?: IntFilter<"transactions"> | number
    CustomerID?: IntNullableFilter<"transactions"> | number | null
    SupportRegionID?: IntNullableFilter<"transactions"> | number | null
    WalletID?: IntNullableFilter<"transactions"> | number | null
    Amount?: FloatNullableFilter<"transactions"> | number | null
    PaymentCheck?: BoolNullableFilter<"transactions"> | boolean | null
    PaymentCheckTime?: DateTimeFilter<"transactions"> | Date | string
    NoteID?: IntNullableFilter<"transactions"> | number | null
    TransactionDate?: DateTimeFilter<"transactions"> | Date | string
    PaymentDenied?: BoolNullableFilter<"transactions"> | boolean | null
    Month?: IntNullableFilter<"transactions"> | number | null
    HopeFuelID?: IntNullableFilter<"transactions"> | number | null
    formstatus?: FormstatusListRelationFilter
    screenshot?: ScreenshotListRelationFilter
    transactionagent?: TransactionagentListRelationFilter
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
    supportregion?: XOR<SupportregionNullableScalarRelationFilter, supportregionWhereInput> | null
    wallet?: XOR<WalletNullableScalarRelationFilter, walletWhereInput> | null
    note?: XOR<NoteNullableScalarRelationFilter, noteWhereInput> | null
  }

  export type transactionsOrderByWithRelationInput = {
    TransactionID?: SortOrder
    CustomerID?: SortOrderInput | SortOrder
    SupportRegionID?: SortOrderInput | SortOrder
    WalletID?: SortOrderInput | SortOrder
    Amount?: SortOrderInput | SortOrder
    PaymentCheck?: SortOrderInput | SortOrder
    PaymentCheckTime?: SortOrder
    NoteID?: SortOrderInput | SortOrder
    TransactionDate?: SortOrder
    PaymentDenied?: SortOrderInput | SortOrder
    Month?: SortOrderInput | SortOrder
    HopeFuelID?: SortOrderInput | SortOrder
    formstatus?: formstatusOrderByRelationAggregateInput
    screenshot?: screenshotOrderByRelationAggregateInput
    transactionagent?: transactionagentOrderByRelationAggregateInput
    customer?: customerOrderByWithRelationInput
    supportregion?: supportregionOrderByWithRelationInput
    wallet?: walletOrderByWithRelationInput
    note?: noteOrderByWithRelationInput
  }

  export type transactionsWhereUniqueInput = Prisma.AtLeast<{
    TransactionID?: number
    AND?: transactionsWhereInput | transactionsWhereInput[]
    OR?: transactionsWhereInput[]
    NOT?: transactionsWhereInput | transactionsWhereInput[]
    CustomerID?: IntNullableFilter<"transactions"> | number | null
    SupportRegionID?: IntNullableFilter<"transactions"> | number | null
    WalletID?: IntNullableFilter<"transactions"> | number | null
    Amount?: FloatNullableFilter<"transactions"> | number | null
    PaymentCheck?: BoolNullableFilter<"transactions"> | boolean | null
    PaymentCheckTime?: DateTimeFilter<"transactions"> | Date | string
    NoteID?: IntNullableFilter<"transactions"> | number | null
    TransactionDate?: DateTimeFilter<"transactions"> | Date | string
    PaymentDenied?: BoolNullableFilter<"transactions"> | boolean | null
    Month?: IntNullableFilter<"transactions"> | number | null
    HopeFuelID?: IntNullableFilter<"transactions"> | number | null
    formstatus?: FormstatusListRelationFilter
    screenshot?: ScreenshotListRelationFilter
    transactionagent?: TransactionagentListRelationFilter
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
    supportregion?: XOR<SupportregionNullableScalarRelationFilter, supportregionWhereInput> | null
    wallet?: XOR<WalletNullableScalarRelationFilter, walletWhereInput> | null
    note?: XOR<NoteNullableScalarRelationFilter, noteWhereInput> | null
  }, "TransactionID">

  export type transactionsOrderByWithAggregationInput = {
    TransactionID?: SortOrder
    CustomerID?: SortOrderInput | SortOrder
    SupportRegionID?: SortOrderInput | SortOrder
    WalletID?: SortOrderInput | SortOrder
    Amount?: SortOrderInput | SortOrder
    PaymentCheck?: SortOrderInput | SortOrder
    PaymentCheckTime?: SortOrder
    NoteID?: SortOrderInput | SortOrder
    TransactionDate?: SortOrder
    PaymentDenied?: SortOrderInput | SortOrder
    Month?: SortOrderInput | SortOrder
    HopeFuelID?: SortOrderInput | SortOrder
    _count?: transactionsCountOrderByAggregateInput
    _avg?: transactionsAvgOrderByAggregateInput
    _max?: transactionsMaxOrderByAggregateInput
    _min?: transactionsMinOrderByAggregateInput
    _sum?: transactionsSumOrderByAggregateInput
  }

  export type transactionsScalarWhereWithAggregatesInput = {
    AND?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    OR?: transactionsScalarWhereWithAggregatesInput[]
    NOT?: transactionsScalarWhereWithAggregatesInput | transactionsScalarWhereWithAggregatesInput[]
    TransactionID?: IntWithAggregatesFilter<"transactions"> | number
    CustomerID?: IntNullableWithAggregatesFilter<"transactions"> | number | null
    SupportRegionID?: IntNullableWithAggregatesFilter<"transactions"> | number | null
    WalletID?: IntNullableWithAggregatesFilter<"transactions"> | number | null
    Amount?: FloatNullableWithAggregatesFilter<"transactions"> | number | null
    PaymentCheck?: BoolNullableWithAggregatesFilter<"transactions"> | boolean | null
    PaymentCheckTime?: DateTimeWithAggregatesFilter<"transactions"> | Date | string
    NoteID?: IntNullableWithAggregatesFilter<"transactions"> | number | null
    TransactionDate?: DateTimeWithAggregatesFilter<"transactions"> | Date | string
    PaymentDenied?: BoolNullableWithAggregatesFilter<"transactions"> | boolean | null
    Month?: IntNullableWithAggregatesFilter<"transactions"> | number | null
    HopeFuelID?: IntNullableWithAggregatesFilter<"transactions"> | number | null
  }

  export type transactionstatusWhereInput = {
    AND?: transactionstatusWhereInput | transactionstatusWhereInput[]
    OR?: transactionstatusWhereInput[]
    NOT?: transactionstatusWhereInput | transactionstatusWhereInput[]
    TransactionStatusID?: IntFilter<"transactionstatus"> | number
    TransactionStatus?: StringFilter<"transactionstatus"> | string
    formstatus?: FormstatusListRelationFilter
  }

  export type transactionstatusOrderByWithRelationInput = {
    TransactionStatusID?: SortOrder
    TransactionStatus?: SortOrder
    formstatus?: formstatusOrderByRelationAggregateInput
    _relevance?: transactionstatusOrderByRelevanceInput
  }

  export type transactionstatusWhereUniqueInput = Prisma.AtLeast<{
    TransactionStatusID?: number
    AND?: transactionstatusWhereInput | transactionstatusWhereInput[]
    OR?: transactionstatusWhereInput[]
    NOT?: transactionstatusWhereInput | transactionstatusWhereInput[]
    TransactionStatus?: StringFilter<"transactionstatus"> | string
    formstatus?: FormstatusListRelationFilter
  }, "TransactionStatusID">

  export type transactionstatusOrderByWithAggregationInput = {
    TransactionStatusID?: SortOrder
    TransactionStatus?: SortOrder
    _count?: transactionstatusCountOrderByAggregateInput
    _avg?: transactionstatusAvgOrderByAggregateInput
    _max?: transactionstatusMaxOrderByAggregateInput
    _min?: transactionstatusMinOrderByAggregateInput
    _sum?: transactionstatusSumOrderByAggregateInput
  }

  export type transactionstatusScalarWhereWithAggregatesInput = {
    AND?: transactionstatusScalarWhereWithAggregatesInput | transactionstatusScalarWhereWithAggregatesInput[]
    OR?: transactionstatusScalarWhereWithAggregatesInput[]
    NOT?: transactionstatusScalarWhereWithAggregatesInput | transactionstatusScalarWhereWithAggregatesInput[]
    TransactionStatusID?: IntWithAggregatesFilter<"transactionstatus"> | number
    TransactionStatus?: StringWithAggregatesFilter<"transactionstatus"> | string
  }

  export type userroleWhereInput = {
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    UserRoleID?: IntFilter<"userrole"> | number
    UserRole?: StringNullableFilter<"userrole"> | string | null
    agent?: AgentListRelationFilter
  }

  export type userroleOrderByWithRelationInput = {
    UserRoleID?: SortOrder
    UserRole?: SortOrderInput | SortOrder
    agent?: agentOrderByRelationAggregateInput
    _relevance?: userroleOrderByRelevanceInput
  }

  export type userroleWhereUniqueInput = Prisma.AtLeast<{
    UserRoleID?: number
    AND?: userroleWhereInput | userroleWhereInput[]
    OR?: userroleWhereInput[]
    NOT?: userroleWhereInput | userroleWhereInput[]
    UserRole?: StringNullableFilter<"userrole"> | string | null
    agent?: AgentListRelationFilter
  }, "UserRoleID">

  export type userroleOrderByWithAggregationInput = {
    UserRoleID?: SortOrder
    UserRole?: SortOrderInput | SortOrder
    _count?: userroleCountOrderByAggregateInput
    _avg?: userroleAvgOrderByAggregateInput
    _max?: userroleMaxOrderByAggregateInput
    _min?: userroleMinOrderByAggregateInput
    _sum?: userroleSumOrderByAggregateInput
  }

  export type userroleScalarWhereWithAggregatesInput = {
    AND?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    OR?: userroleScalarWhereWithAggregatesInput[]
    NOT?: userroleScalarWhereWithAggregatesInput | userroleScalarWhereWithAggregatesInput[]
    UserRoleID?: IntWithAggregatesFilter<"userrole"> | number
    UserRole?: StringNullableWithAggregatesFilter<"userrole"> | string | null
  }

  export type walletWhereInput = {
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    WalletId?: IntFilter<"wallet"> | number
    CurrencyId?: IntNullableFilter<"wallet"> | number | null
    WalletName?: StringNullableFilter<"wallet"> | string | null
    transactions?: TransactionsListRelationFilter
    currency?: XOR<CurrencyNullableScalarRelationFilter, currencyWhereInput> | null
  }

  export type walletOrderByWithRelationInput = {
    WalletId?: SortOrder
    CurrencyId?: SortOrderInput | SortOrder
    WalletName?: SortOrderInput | SortOrder
    transactions?: transactionsOrderByRelationAggregateInput
    currency?: currencyOrderByWithRelationInput
    _relevance?: walletOrderByRelevanceInput
  }

  export type walletWhereUniqueInput = Prisma.AtLeast<{
    WalletId?: number
    AND?: walletWhereInput | walletWhereInput[]
    OR?: walletWhereInput[]
    NOT?: walletWhereInput | walletWhereInput[]
    CurrencyId?: IntNullableFilter<"wallet"> | number | null
    WalletName?: StringNullableFilter<"wallet"> | string | null
    transactions?: TransactionsListRelationFilter
    currency?: XOR<CurrencyNullableScalarRelationFilter, currencyWhereInput> | null
  }, "WalletId">

  export type walletOrderByWithAggregationInput = {
    WalletId?: SortOrder
    CurrencyId?: SortOrderInput | SortOrder
    WalletName?: SortOrderInput | SortOrder
    _count?: walletCountOrderByAggregateInput
    _avg?: walletAvgOrderByAggregateInput
    _max?: walletMaxOrderByAggregateInput
    _min?: walletMinOrderByAggregateInput
    _sum?: walletSumOrderByAggregateInput
  }

  export type walletScalarWhereWithAggregatesInput = {
    AND?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    OR?: walletScalarWhereWithAggregatesInput[]
    NOT?: walletScalarWhereWithAggregatesInput | walletScalarWhereWithAggregatesInput[]
    WalletId?: IntWithAggregatesFilter<"wallet"> | number
    CurrencyId?: IntNullableWithAggregatesFilter<"wallet"> | number | null
    WalletName?: StringNullableWithAggregatesFilter<"wallet"> | string | null
  }

  export type testing_new_tableWhereInput = {
    AND?: testing_new_tableWhereInput | testing_new_tableWhereInput[]
    OR?: testing_new_tableWhereInput[]
    NOT?: testing_new_tableWhereInput | testing_new_tableWhereInput[]
    Id?: IntFilter<"testing_new_table"> | number
    Name?: StringFilter<"testing_new_table"> | string
    CreatedAt?: DateTimeFilter<"testing_new_table"> | Date | string
    UpdatedAt?: DateTimeFilter<"testing_new_table"> | Date | string
  }

  export type testing_new_tableOrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    _relevance?: testing_new_tableOrderByRelevanceInput
  }

  export type testing_new_tableWhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: testing_new_tableWhereInput | testing_new_tableWhereInput[]
    OR?: testing_new_tableWhereInput[]
    NOT?: testing_new_tableWhereInput | testing_new_tableWhereInput[]
    Name?: StringFilter<"testing_new_table"> | string
    CreatedAt?: DateTimeFilter<"testing_new_table"> | Date | string
    UpdatedAt?: DateTimeFilter<"testing_new_table"> | Date | string
  }, "Id">

  export type testing_new_tableOrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    _count?: testing_new_tableCountOrderByAggregateInput
    _avg?: testing_new_tableAvgOrderByAggregateInput
    _max?: testing_new_tableMaxOrderByAggregateInput
    _min?: testing_new_tableMinOrderByAggregateInput
    _sum?: testing_new_tableSumOrderByAggregateInput
  }

  export type testing_new_tableScalarWhereWithAggregatesInput = {
    AND?: testing_new_tableScalarWhereWithAggregatesInput | testing_new_tableScalarWhereWithAggregatesInput[]
    OR?: testing_new_tableScalarWhereWithAggregatesInput[]
    NOT?: testing_new_tableScalarWhereWithAggregatesInput | testing_new_tableScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"testing_new_table"> | number
    Name?: StringWithAggregatesFilter<"testing_new_table"> | string
    CreatedAt?: DateTimeWithAggregatesFilter<"testing_new_table"> | Date | string
    UpdatedAt?: DateTimeWithAggregatesFilter<"testing_new_table"> | Date | string
  }

  export type testing_new_table2WhereInput = {
    AND?: testing_new_table2WhereInput | testing_new_table2WhereInput[]
    OR?: testing_new_table2WhereInput[]
    NOT?: testing_new_table2WhereInput | testing_new_table2WhereInput[]
    Id?: IntFilter<"testing_new_table2"> | number
    Name?: StringFilter<"testing_new_table2"> | string
    CreatedAt?: DateTimeFilter<"testing_new_table2"> | Date | string
    UpdatedAt?: DateTimeFilter<"testing_new_table2"> | Date | string
  }

  export type testing_new_table2OrderByWithRelationInput = {
    Id?: SortOrder
    Name?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    _relevance?: testing_new_table2OrderByRelevanceInput
  }

  export type testing_new_table2WhereUniqueInput = Prisma.AtLeast<{
    Id?: number
    AND?: testing_new_table2WhereInput | testing_new_table2WhereInput[]
    OR?: testing_new_table2WhereInput[]
    NOT?: testing_new_table2WhereInput | testing_new_table2WhereInput[]
    Name?: StringFilter<"testing_new_table2"> | string
    CreatedAt?: DateTimeFilter<"testing_new_table2"> | Date | string
    UpdatedAt?: DateTimeFilter<"testing_new_table2"> | Date | string
  }, "Id">

  export type testing_new_table2OrderByWithAggregationInput = {
    Id?: SortOrder
    Name?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
    _count?: testing_new_table2CountOrderByAggregateInput
    _avg?: testing_new_table2AvgOrderByAggregateInput
    _max?: testing_new_table2MaxOrderByAggregateInput
    _min?: testing_new_table2MinOrderByAggregateInput
    _sum?: testing_new_table2SumOrderByAggregateInput
  }

  export type testing_new_table2ScalarWhereWithAggregatesInput = {
    AND?: testing_new_table2ScalarWhereWithAggregatesInput | testing_new_table2ScalarWhereWithAggregatesInput[]
    OR?: testing_new_table2ScalarWhereWithAggregatesInput[]
    NOT?: testing_new_table2ScalarWhereWithAggregatesInput | testing_new_table2ScalarWhereWithAggregatesInput[]
    Id?: IntWithAggregatesFilter<"testing_new_table2"> | number
    Name?: StringWithAggregatesFilter<"testing_new_table2"> | string
    CreatedAt?: DateTimeWithAggregatesFilter<"testing_new_table2"> | Date | string
    UpdatedAt?: DateTimeWithAggregatesFilter<"testing_new_table2"> | Date | string
  }

  export type agentCreateInput = {
    AwsId?: string | null
    userrole?: userroleCreateNestedOneWithoutAgentInput
    customer?: customerCreateNestedManyWithoutAgentInput
    customerauditlogs?: customerauditlogsCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusCreateNestedManyWithoutAgentInput
    note?: noteCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentCreateNestedManyWithoutAgentInput
  }

  export type agentUncheckedCreateInput = {
    AgentId?: number
    AwsId?: string | null
    UserRoleId?: number | null
    customer?: customerUncheckedCreateNestedManyWithoutAgentInput
    customerauditlogs?: customerauditlogsUncheckedCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusUncheckedCreateNestedManyWithoutAgentInput
    note?: noteUncheckedCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type agentUpdateInput = {
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    userrole?: userroleUpdateOneWithoutAgentNestedInput
    customer?: customerUpdateManyWithoutAgentNestedInput
    customerauditlogs?: customerauditlogsUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUpdateManyWithoutAgentNestedInput
    note?: noteUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUpdateManyWithoutAgentNestedInput
  }

  export type agentUncheckedUpdateInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    UserRoleId?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: customerUncheckedUpdateManyWithoutAgentNestedInput
    customerauditlogs?: customerauditlogsUncheckedUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUncheckedUpdateManyWithoutAgentNestedInput
    note?: noteUncheckedUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type agentCreateManyInput = {
    AgentId?: number
    AwsId?: string | null
    UserRoleId?: number | null
  }

  export type agentUpdateManyMutationInput = {
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type agentUncheckedUpdateManyInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    UserRoleId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type basecountryCreateInput = {
    BaseCountryName: string
    exchangerates?: exchangeratesCreateNestedManyWithoutBasecountryInput
    fundraiser?: fundraiserCreateNestedManyWithoutBasecountryInput
  }

  export type basecountryUncheckedCreateInput = {
    BaseCountryID?: number
    BaseCountryName: string
    exchangerates?: exchangeratesUncheckedCreateNestedManyWithoutBasecountryInput
    fundraiser?: fundraiserUncheckedCreateNestedManyWithoutBasecountryInput
  }

  export type basecountryUpdateInput = {
    BaseCountryName?: StringFieldUpdateOperationsInput | string
    exchangerates?: exchangeratesUpdateManyWithoutBasecountryNestedInput
    fundraiser?: fundraiserUpdateManyWithoutBasecountryNestedInput
  }

  export type basecountryUncheckedUpdateInput = {
    BaseCountryID?: IntFieldUpdateOperationsInput | number
    BaseCountryName?: StringFieldUpdateOperationsInput | string
    exchangerates?: exchangeratesUncheckedUpdateManyWithoutBasecountryNestedInput
    fundraiser?: fundraiserUncheckedUpdateManyWithoutBasecountryNestedInput
  }

  export type basecountryCreateManyInput = {
    BaseCountryID?: number
    BaseCountryName: string
  }

  export type basecountryUpdateManyMutationInput = {
    BaseCountryName?: StringFieldUpdateOperationsInput | string
  }

  export type basecountryUncheckedUpdateManyInput = {
    BaseCountryID?: IntFieldUpdateOperationsInput | number
    BaseCountryName?: StringFieldUpdateOperationsInput | string
  }

  export type currencyCreateInput = {
    CurrencyCode?: string | null
    exchangerates?: exchangeratesCreateNestedManyWithoutCurrencyInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesCreateNestedManyWithoutCurrencyInput
    minimumamount?: minimumamountCreateNestedManyWithoutCurrencyInput
    wallet?: walletCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUncheckedCreateInput = {
    CurrencyId?: number
    CurrencyCode?: string | null
    exchangerates?: exchangeratesUncheckedCreateNestedManyWithoutCurrencyInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedCreateNestedManyWithoutCurrencyInput
    minimumamount?: minimumamountUncheckedCreateNestedManyWithoutCurrencyInput
    wallet?: walletUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUpdateInput = {
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    exchangerates?: exchangeratesUpdateManyWithoutCurrencyNestedInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUpdateManyWithoutCurrencyNestedInput
    minimumamount?: minimumamountUpdateManyWithoutCurrencyNestedInput
    wallet?: walletUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyUncheckedUpdateInput = {
    CurrencyId?: IntFieldUpdateOperationsInput | number
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    exchangerates?: exchangeratesUncheckedUpdateManyWithoutCurrencyNestedInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutCurrencyNestedInput
    minimumamount?: minimumamountUncheckedUpdateManyWithoutCurrencyNestedInput
    wallet?: walletUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyCreateManyInput = {
    CurrencyId?: number
    CurrencyCode?: string | null
  }

  export type currencyUpdateManyMutationInput = {
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type currencyUncheckedUpdateManyInput = {
    CurrencyId?: IntFieldUpdateOperationsInput | number
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customerCreateInput = {
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    CardID?: number | null
    agent?: agentCreateNestedOneWithoutCustomerInput
    customerauditlogs?: customerauditlogsCreateNestedManyWithoutCustomerInput
    manychat?: manychatCreateNestedManyWithoutCustomerInput
    transactions?: transactionsCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateInput = {
    CustomerId?: number
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    AgentId?: number | null
    CardID?: number | null
    customerauditlogs?: customerauditlogsUncheckedCreateNestedManyWithoutCustomerInput
    manychat?: manychatUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
    agent?: agentUpdateOneWithoutCustomerNestedInput
    customerauditlogs?: customerauditlogsUpdateManyWithoutCustomerNestedInput
    manychat?: manychatUpdateManyWithoutCustomerNestedInput
    transactions?: transactionsUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateInput = {
    CustomerId?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
    customerauditlogs?: customerauditlogsUncheckedUpdateManyWithoutCustomerNestedInput
    manychat?: manychatUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerCreateManyInput = {
    CustomerId?: number
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    AgentId?: number | null
    CardID?: number | null
  }

  export type customerUpdateManyMutationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type customerUncheckedUpdateManyInput = {
    CustomerId?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type customerauditlogsCreateInput = {
    FieldChanged: $Enums.customerauditlogs_FieldChanged
    OldValue?: string | null
    NewValue?: string | null
    ChangeDate?: Date | string
    agent: agentCreateNestedOneWithoutCustomerauditlogsInput
    customer: customerCreateNestedOneWithoutCustomerauditlogsInput
  }

  export type customerauditlogsUncheckedCreateInput = {
    LogId?: number
    AgentId: number
    FieldChanged: $Enums.customerauditlogs_FieldChanged
    OldValue?: string | null
    NewValue?: string | null
    CustomerId: number
    ChangeDate?: Date | string
  }

  export type customerauditlogsUpdateInput = {
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFieldUpdateOperationsInput | $Enums.customerauditlogs_FieldChanged
    OldValue?: NullableStringFieldUpdateOperationsInput | string | null
    NewValue?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: agentUpdateOneRequiredWithoutCustomerauditlogsNestedInput
    customer?: customerUpdateOneRequiredWithoutCustomerauditlogsNestedInput
  }

  export type customerauditlogsUncheckedUpdateInput = {
    LogId?: IntFieldUpdateOperationsInput | number
    AgentId?: IntFieldUpdateOperationsInput | number
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFieldUpdateOperationsInput | $Enums.customerauditlogs_FieldChanged
    OldValue?: NullableStringFieldUpdateOperationsInput | string | null
    NewValue?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: IntFieldUpdateOperationsInput | number
    ChangeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerauditlogsCreateManyInput = {
    LogId?: number
    AgentId: number
    FieldChanged: $Enums.customerauditlogs_FieldChanged
    OldValue?: string | null
    NewValue?: string | null
    CustomerId: number
    ChangeDate?: Date | string
  }

  export type customerauditlogsUpdateManyMutationInput = {
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFieldUpdateOperationsInput | $Enums.customerauditlogs_FieldChanged
    OldValue?: NullableStringFieldUpdateOperationsInput | string | null
    NewValue?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerauditlogsUncheckedUpdateManyInput = {
    LogId?: IntFieldUpdateOperationsInput | number
    AgentId?: IntFieldUpdateOperationsInput | number
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFieldUpdateOperationsInput | $Enums.customerauditlogs_FieldChanged
    OldValue?: NullableStringFieldUpdateOperationsInput | string | null
    NewValue?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: IntFieldUpdateOperationsInput | number
    ChangeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchangeratesCreateInput = {
    ExchangeRate: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
    basecountry: basecountryCreateNestedOneWithoutExchangeratesInput
    currency: currencyCreateNestedOneWithoutExchangeratesInput
  }

  export type exchangeratesUncheckedCreateInput = {
    ExchangeRateId?: number
    BaseCountryId: number
    CurrencyId: number
    ExchangeRate: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type exchangeratesUpdateInput = {
    ExchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basecountry?: basecountryUpdateOneRequiredWithoutExchangeratesNestedInput
    currency?: currencyUpdateOneRequiredWithoutExchangeratesNestedInput
  }

  export type exchangeratesUncheckedUpdateInput = {
    ExchangeRateId?: IntFieldUpdateOperationsInput | number
    BaseCountryId?: IntFieldUpdateOperationsInput | number
    CurrencyId?: IntFieldUpdateOperationsInput | number
    ExchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchangeratesCreateManyInput = {
    ExchangeRateId?: number
    BaseCountryId: number
    CurrencyId: number
    ExchangeRate: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type exchangeratesUpdateManyMutationInput = {
    ExchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchangeratesUncheckedUpdateManyInput = {
    ExchangeRateId?: IntFieldUpdateOperationsInput | number
    BaseCountryId?: IntFieldUpdateOperationsInput | number
    CurrencyId?: IntFieldUpdateOperationsInput | number
    ExchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formstatusCreateInput = {
    transactions?: transactionsCreateNestedOneWithoutFormstatusInput
    transactionstatus?: transactionstatusCreateNestedOneWithoutFormstatusInput
  }

  export type formstatusUncheckedCreateInput = {
    FormStatusID?: number
    TransactionID?: number | null
    TransactionStatusID?: number | null
  }

  export type formstatusUpdateInput = {
    transactions?: transactionsUpdateOneWithoutFormstatusNestedInput
    transactionstatus?: transactionstatusUpdateOneWithoutFormstatusNestedInput
  }

  export type formstatusUncheckedUpdateInput = {
    FormStatusID?: IntFieldUpdateOperationsInput | number
    TransactionID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionStatusID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type formstatusCreateManyInput = {
    FormStatusID?: number
    TransactionID?: number | null
    TransactionStatusID?: number | null
  }

  export type formstatusUpdateManyMutationInput = {

  }

  export type formstatusUncheckedUpdateManyInput = {
    FormStatusID?: IntFieldUpdateOperationsInput | number
    TransactionID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionStatusID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type formvisibilitystatusCreateInput = {
    IsFormOpen: boolean
    FormTimeStamp?: Date | string
    agent: agentCreateNestedOneWithoutFormvisibilitystatusInput
  }

  export type formvisibilitystatusUncheckedCreateInput = {
    VisibilityStatusId?: number
    AgentId: number
    IsFormOpen: boolean
    FormTimeStamp?: Date | string
  }

  export type formvisibilitystatusUpdateInput = {
    IsFormOpen?: BoolFieldUpdateOperationsInput | boolean
    FormTimeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: agentUpdateOneRequiredWithoutFormvisibilitystatusNestedInput
  }

  export type formvisibilitystatusUncheckedUpdateInput = {
    VisibilityStatusId?: IntFieldUpdateOperationsInput | number
    AgentId?: IntFieldUpdateOperationsInput | number
    IsFormOpen?: BoolFieldUpdateOperationsInput | boolean
    FormTimeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formvisibilitystatusCreateManyInput = {
    VisibilityStatusId?: number
    AgentId: number
    IsFormOpen: boolean
    FormTimeStamp?: Date | string
  }

  export type formvisibilitystatusUpdateManyMutationInput = {
    IsFormOpen?: BoolFieldUpdateOperationsInput | boolean
    FormTimeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formvisibilitystatusUncheckedUpdateManyInput = {
    VisibilityStatusId?: IntFieldUpdateOperationsInput | number
    AgentId?: IntFieldUpdateOperationsInput | number
    IsFormOpen?: BoolFieldUpdateOperationsInput | boolean
    FormTimeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fundraiserCreateInput = {
    FundraiserName: string
    FundraiserEmail: string
    FundraiserLogo?: string | null
    FundraiserCentralID?: number | null
    basecountry?: basecountryCreateNestedOneWithoutFundraiserInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesCreateNestedManyWithoutFundraiserInput
    fundraiser_contactlinks?: fundraiser_contactlinksCreateNestedManyWithoutFundraiserInput
  }

  export type fundraiserUncheckedCreateInput = {
    FundraiserID?: number
    FundraiserName: string
    FundraiserEmail: string
    FundraiserLogo?: string | null
    BaseCountryID?: number | null
    FundraiserCentralID?: number | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedCreateNestedManyWithoutFundraiserInput
    fundraiser_contactlinks?: fundraiser_contactlinksUncheckedCreateNestedManyWithoutFundraiserInput
  }

  export type fundraiserUpdateInput = {
    FundraiserName?: StringFieldUpdateOperationsInput | string
    FundraiserEmail?: StringFieldUpdateOperationsInput | string
    FundraiserLogo?: NullableStringFieldUpdateOperationsInput | string | null
    FundraiserCentralID?: NullableIntFieldUpdateOperationsInput | number | null
    basecountry?: basecountryUpdateOneWithoutFundraiserNestedInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUpdateManyWithoutFundraiserNestedInput
    fundraiser_contactlinks?: fundraiser_contactlinksUpdateManyWithoutFundraiserNestedInput
  }

  export type fundraiserUncheckedUpdateInput = {
    FundraiserID?: IntFieldUpdateOperationsInput | number
    FundraiserName?: StringFieldUpdateOperationsInput | string
    FundraiserEmail?: StringFieldUpdateOperationsInput | string
    FundraiserLogo?: NullableStringFieldUpdateOperationsInput | string | null
    BaseCountryID?: NullableIntFieldUpdateOperationsInput | number | null
    FundraiserCentralID?: NullableIntFieldUpdateOperationsInput | number | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutFundraiserNestedInput
    fundraiser_contactlinks?: fundraiser_contactlinksUncheckedUpdateManyWithoutFundraiserNestedInput
  }

  export type fundraiserCreateManyInput = {
    FundraiserID?: number
    FundraiserName: string
    FundraiserEmail: string
    FundraiserLogo?: string | null
    BaseCountryID?: number | null
    FundraiserCentralID?: number | null
  }

  export type fundraiserUpdateManyMutationInput = {
    FundraiserName?: StringFieldUpdateOperationsInput | string
    FundraiserEmail?: StringFieldUpdateOperationsInput | string
    FundraiserLogo?: NullableStringFieldUpdateOperationsInput | string | null
    FundraiserCentralID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fundraiserUncheckedUpdateManyInput = {
    FundraiserID?: IntFieldUpdateOperationsInput | number
    FundraiserName?: StringFieldUpdateOperationsInput | string
    FundraiserEmail?: StringFieldUpdateOperationsInput | string
    FundraiserLogo?: NullableStringFieldUpdateOperationsInput | string | null
    BaseCountryID?: NullableIntFieldUpdateOperationsInput | number | null
    FundraiserCentralID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fundraiser_acceptedcurrenciesCreateInput = {
    fundraiser?: fundraiserCreateNestedOneWithoutFundraiser_acceptedcurrenciesInput
    currency?: currencyCreateNestedOneWithoutFundraiser_acceptedcurrenciesInput
  }

  export type fundraiser_acceptedcurrenciesUncheckedCreateInput = {
    FundraiserAcceptedCurrencyID?: number
    FundraiserID?: number | null
    CurrencyID?: number | null
  }

  export type fundraiser_acceptedcurrenciesUpdateInput = {
    fundraiser?: fundraiserUpdateOneWithoutFundraiser_acceptedcurrenciesNestedInput
    currency?: currencyUpdateOneWithoutFundraiser_acceptedcurrenciesNestedInput
  }

  export type fundraiser_acceptedcurrenciesUncheckedUpdateInput = {
    FundraiserAcceptedCurrencyID?: IntFieldUpdateOperationsInput | number
    FundraiserID?: NullableIntFieldUpdateOperationsInput | number | null
    CurrencyID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fundraiser_acceptedcurrenciesCreateManyInput = {
    FundraiserAcceptedCurrencyID?: number
    FundraiserID?: number | null
    CurrencyID?: number | null
  }

  export type fundraiser_acceptedcurrenciesUpdateManyMutationInput = {

  }

  export type fundraiser_acceptedcurrenciesUncheckedUpdateManyInput = {
    FundraiserAcceptedCurrencyID?: IntFieldUpdateOperationsInput | number
    FundraiserID?: NullableIntFieldUpdateOperationsInput | number | null
    CurrencyID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fundraiser_contactlinksCreateInput = {
    Platform?: number | null
    ContactURL: string
    fundraiser?: fundraiserCreateNestedOneWithoutFundraiser_contactlinksInput
  }

  export type fundraiser_contactlinksUncheckedCreateInput = {
    ContactID?: number
    FundraiserID?: number | null
    Platform?: number | null
    ContactURL: string
  }

  export type fundraiser_contactlinksUpdateInput = {
    Platform?: NullableIntFieldUpdateOperationsInput | number | null
    ContactURL?: StringFieldUpdateOperationsInput | string
    fundraiser?: fundraiserUpdateOneWithoutFundraiser_contactlinksNestedInput
  }

  export type fundraiser_contactlinksUncheckedUpdateInput = {
    ContactID?: IntFieldUpdateOperationsInput | number
    FundraiserID?: NullableIntFieldUpdateOperationsInput | number | null
    Platform?: NullableIntFieldUpdateOperationsInput | number | null
    ContactURL?: StringFieldUpdateOperationsInput | string
  }

  export type fundraiser_contactlinksCreateManyInput = {
    ContactID?: number
    FundraiserID?: number | null
    Platform?: number | null
    ContactURL: string
  }

  export type fundraiser_contactlinksUpdateManyMutationInput = {
    Platform?: NullableIntFieldUpdateOperationsInput | number | null
    ContactURL?: StringFieldUpdateOperationsInput | string
  }

  export type fundraiser_contactlinksUncheckedUpdateManyInput = {
    ContactID?: IntFieldUpdateOperationsInput | number
    FundraiserID?: NullableIntFieldUpdateOperationsInput | number | null
    Platform?: NullableIntFieldUpdateOperationsInput | number | null
    ContactURL?: StringFieldUpdateOperationsInput | string
  }

  export type manychatCreateInput = {
    ConversationId: string
    CreateAt?: Date | string
    UpdateAt?: Date | string
    customer: customerCreateNestedOneWithoutManychatInput
  }

  export type manychatUncheckedCreateInput = {
    ManyChatId?: number
    ConversationId: string
    CustomerId: number
    CreateAt?: Date | string
    UpdateAt?: Date | string
  }

  export type manychatUpdateInput = {
    ConversationId?: StringFieldUpdateOperationsInput | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUpdateOneRequiredWithoutManychatNestedInput
  }

  export type manychatUncheckedUpdateInput = {
    ManyChatId?: IntFieldUpdateOperationsInput | number
    ConversationId?: StringFieldUpdateOperationsInput | string
    CustomerId?: IntFieldUpdateOperationsInput | number
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type manychatCreateManyInput = {
    ManyChatId?: number
    ConversationId: string
    CustomerId: number
    CreateAt?: Date | string
    UpdateAt?: Date | string
  }

  export type manychatUpdateManyMutationInput = {
    ConversationId?: StringFieldUpdateOperationsInput | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type manychatUncheckedUpdateManyInput = {
    ManyChatId?: IntFieldUpdateOperationsInput | number
    ConversationId?: StringFieldUpdateOperationsInput | string
    CustomerId?: IntFieldUpdateOperationsInput | number
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type minimumamountCreateInput = {
    Amount: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
    currency: currencyCreateNestedOneWithoutMinimumamountInput
  }

  export type minimumamountUncheckedCreateInput = {
    MinimumAmountId?: number
    CurrencyId: number
    Amount: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type minimumamountUpdateInput = {
    Amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: currencyUpdateOneRequiredWithoutMinimumamountNestedInput
  }

  export type minimumamountUncheckedUpdateInput = {
    MinimumAmountId?: IntFieldUpdateOperationsInput | number
    CurrencyId?: IntFieldUpdateOperationsInput | number
    Amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type minimumamountCreateManyInput = {
    MinimumAmountId?: number
    CurrencyId: number
    Amount: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type minimumamountUpdateManyMutationInput = {
    Amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type minimumamountUncheckedUpdateManyInput = {
    MinimumAmountId?: IntFieldUpdateOperationsInput | number
    CurrencyId?: IntFieldUpdateOperationsInput | number
    Amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteCreateInput = {
    Note?: string | null
    Date?: Date | string | null
    agent?: agentCreateNestedOneWithoutNoteInput
    transactions?: transactionsCreateNestedManyWithoutNoteInput
  }

  export type noteUncheckedCreateInput = {
    NoteID?: number
    Note?: string | null
    Date?: Date | string | null
    AgentID?: number | null
    transactions?: transactionsUncheckedCreateNestedManyWithoutNoteInput
  }

  export type noteUpdateInput = {
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agent?: agentUpdateOneWithoutNoteNestedInput
    transactions?: transactionsUpdateManyWithoutNoteNestedInput
  }

  export type noteUncheckedUpdateInput = {
    NoteID?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AgentID?: NullableIntFieldUpdateOperationsInput | number | null
    transactions?: transactionsUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type noteCreateManyInput = {
    NoteID?: number
    Note?: string | null
    Date?: Date | string | null
    AgentID?: number | null
  }

  export type noteUpdateManyMutationInput = {
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type noteUncheckedUpdateManyInput = {
    NoteID?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AgentID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type platformCreateInput = {
    PlatformName: string
  }

  export type platformUncheckedCreateInput = {
    PlatformID?: number
    PlatformName: string
  }

  export type platformUpdateInput = {
    PlatformName?: StringFieldUpdateOperationsInput | string
  }

  export type platformUncheckedUpdateInput = {
    PlatformID?: IntFieldUpdateOperationsInput | number
    PlatformName?: StringFieldUpdateOperationsInput | string
  }

  export type platformCreateManyInput = {
    PlatformID?: number
    PlatformName: string
  }

  export type platformUpdateManyMutationInput = {
    PlatformName?: StringFieldUpdateOperationsInput | string
  }

  export type platformUncheckedUpdateManyInput = {
    PlatformID?: IntFieldUpdateOperationsInput | number
    PlatformName?: StringFieldUpdateOperationsInput | string
  }

  export type screenshotCreateInput = {
    ScreenShotLink?: string | null
    transactions?: transactionsCreateNestedOneWithoutScreenshotInput
  }

  export type screenshotUncheckedCreateInput = {
    ScreenShotID?: number
    TransactionID?: number | null
    ScreenShotLink?: string | null
  }

  export type screenshotUpdateInput = {
    ScreenShotLink?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUpdateOneWithoutScreenshotNestedInput
  }

  export type screenshotUncheckedUpdateInput = {
    ScreenShotID?: IntFieldUpdateOperationsInput | number
    TransactionID?: NullableIntFieldUpdateOperationsInput | number | null
    ScreenShotLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type screenshotCreateManyInput = {
    ScreenShotID?: number
    TransactionID?: number | null
    ScreenShotLink?: string | null
  }

  export type screenshotUpdateManyMutationInput = {
    ScreenShotLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type screenshotUncheckedUpdateManyInput = {
    ScreenShotID?: IntFieldUpdateOperationsInput | number
    TransactionID?: NullableIntFieldUpdateOperationsInput | number | null
    ScreenShotLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type supportregionCreateInput = {
    Region?: string | null
    transactions?: transactionsCreateNestedManyWithoutSupportregionInput
  }

  export type supportregionUncheckedCreateInput = {
    SupportRegionID?: number
    Region?: string | null
    transactions?: transactionsUncheckedCreateNestedManyWithoutSupportregionInput
  }

  export type supportregionUpdateInput = {
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUpdateManyWithoutSupportregionNestedInput
  }

  export type supportregionUncheckedUpdateInput = {
    SupportRegionID?: IntFieldUpdateOperationsInput | number
    Region?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUncheckedUpdateManyWithoutSupportregionNestedInput
  }

  export type supportregionCreateManyInput = {
    SupportRegionID?: number
    Region?: string | null
  }

  export type supportregionUpdateManyMutationInput = {
    Region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type supportregionUncheckedUpdateManyInput = {
    SupportRegionID?: IntFieldUpdateOperationsInput | number
    Region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionagentCreateInput = {
    LogDate?: Date | string
    transactions?: transactionsCreateNestedOneWithoutTransactionagentInput
    agent?: agentCreateNestedOneWithoutTransactionagentInput
  }

  export type transactionagentUncheckedCreateInput = {
    TransactionAgentID?: number
    TransactionID?: number | null
    AgentID?: number | null
    LogDate?: Date | string
  }

  export type transactionagentUpdateInput = {
    LogDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUpdateOneWithoutTransactionagentNestedInput
    agent?: agentUpdateOneWithoutTransactionagentNestedInput
  }

  export type transactionagentUncheckedUpdateInput = {
    TransactionAgentID?: IntFieldUpdateOperationsInput | number
    TransactionID?: NullableIntFieldUpdateOperationsInput | number | null
    AgentID?: NullableIntFieldUpdateOperationsInput | number | null
    LogDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionagentCreateManyInput = {
    TransactionAgentID?: number
    TransactionID?: number | null
    AgentID?: number | null
    LogDate?: Date | string
  }

  export type transactionagentUpdateManyMutationInput = {
    LogDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionagentUncheckedUpdateManyInput = {
    TransactionAgentID?: IntFieldUpdateOperationsInput | number
    TransactionID?: NullableIntFieldUpdateOperationsInput | number | null
    AgentID?: NullableIntFieldUpdateOperationsInput | number | null
    LogDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsCreateInput = {
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentCreateNestedManyWithoutTransactionsInput
    customer?: customerCreateNestedOneWithoutTransactionsInput
    supportregion?: supportregionCreateNestedOneWithoutTransactionsInput
    wallet?: walletCreateNestedOneWithoutTransactionsInput
    note?: noteCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateInput = {
    TransactionID?: number
    CustomerID?: number | null
    SupportRegionID?: number | null
    WalletID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    NoteID?: number | null
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusUncheckedCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotUncheckedCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsUpdateInput = {
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUpdateManyWithoutTransactionsNestedInput
    customer?: customerUpdateOneWithoutTransactionsNestedInput
    supportregion?: supportregionUpdateOneWithoutTransactionsNestedInput
    wallet?: walletUpdateOneWithoutTransactionsNestedInput
    note?: noteUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    SupportRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    WalletID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NoteID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUncheckedUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUncheckedUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type transactionsCreateManyInput = {
    TransactionID?: number
    CustomerID?: number | null
    SupportRegionID?: number | null
    WalletID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    NoteID?: number | null
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
  }

  export type transactionsUpdateManyMutationInput = {
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type transactionsUncheckedUpdateManyInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    SupportRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    WalletID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NoteID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type transactionstatusCreateInput = {
    TransactionStatus: string
    formstatus?: formstatusCreateNestedManyWithoutTransactionstatusInput
  }

  export type transactionstatusUncheckedCreateInput = {
    TransactionStatusID?: number
    TransactionStatus: string
    formstatus?: formstatusUncheckedCreateNestedManyWithoutTransactionstatusInput
  }

  export type transactionstatusUpdateInput = {
    TransactionStatus?: StringFieldUpdateOperationsInput | string
    formstatus?: formstatusUpdateManyWithoutTransactionstatusNestedInput
  }

  export type transactionstatusUncheckedUpdateInput = {
    TransactionStatusID?: IntFieldUpdateOperationsInput | number
    TransactionStatus?: StringFieldUpdateOperationsInput | string
    formstatus?: formstatusUncheckedUpdateManyWithoutTransactionstatusNestedInput
  }

  export type transactionstatusCreateManyInput = {
    TransactionStatusID?: number
    TransactionStatus: string
  }

  export type transactionstatusUpdateManyMutationInput = {
    TransactionStatus?: StringFieldUpdateOperationsInput | string
  }

  export type transactionstatusUncheckedUpdateManyInput = {
    TransactionStatusID?: IntFieldUpdateOperationsInput | number
    TransactionStatus?: StringFieldUpdateOperationsInput | string
  }

  export type userroleCreateInput = {
    UserRole?: string | null
    agent?: agentCreateNestedManyWithoutUserroleInput
  }

  export type userroleUncheckedCreateInput = {
    UserRoleID?: number
    UserRole?: string | null
    agent?: agentUncheckedCreateNestedManyWithoutUserroleInput
  }

  export type userroleUpdateInput = {
    UserRole?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: agentUpdateManyWithoutUserroleNestedInput
  }

  export type userroleUncheckedUpdateInput = {
    UserRoleID?: IntFieldUpdateOperationsInput | number
    UserRole?: NullableStringFieldUpdateOperationsInput | string | null
    agent?: agentUncheckedUpdateManyWithoutUserroleNestedInput
  }

  export type userroleCreateManyInput = {
    UserRoleID?: number
    UserRole?: string | null
  }

  export type userroleUpdateManyMutationInput = {
    UserRole?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userroleUncheckedUpdateManyInput = {
    UserRoleID?: IntFieldUpdateOperationsInput | number
    UserRole?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type walletCreateInput = {
    WalletName?: string | null
    transactions?: transactionsCreateNestedManyWithoutWalletInput
    currency?: currencyCreateNestedOneWithoutWalletInput
  }

  export type walletUncheckedCreateInput = {
    WalletId?: number
    CurrencyId?: number | null
    WalletName?: string | null
    transactions?: transactionsUncheckedCreateNestedManyWithoutWalletInput
  }

  export type walletUpdateInput = {
    WalletName?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUpdateManyWithoutWalletNestedInput
    currency?: currencyUpdateOneWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateInput = {
    WalletId?: IntFieldUpdateOperationsInput | number
    CurrencyId?: NullableIntFieldUpdateOperationsInput | number | null
    WalletName?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type walletCreateManyInput = {
    WalletId?: number
    CurrencyId?: number | null
    WalletName?: string | null
  }

  export type walletUpdateManyMutationInput = {
    WalletName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type walletUncheckedUpdateManyInput = {
    WalletId?: IntFieldUpdateOperationsInput | number
    CurrencyId?: NullableIntFieldUpdateOperationsInput | number | null
    WalletName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type testing_new_tableCreateInput = {
    Name: string
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type testing_new_tableUncheckedCreateInput = {
    Id?: number
    Name: string
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type testing_new_tableUpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testing_new_tableUncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testing_new_tableCreateManyInput = {
    Id?: number
    Name: string
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type testing_new_tableUpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testing_new_tableUncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testing_new_table2CreateInput = {
    Name: string
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type testing_new_table2UncheckedCreateInput = {
    Id?: number
    Name: string
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type testing_new_table2UpdateInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testing_new_table2UncheckedUpdateInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testing_new_table2CreateManyInput = {
    Id?: number
    Name: string
    CreatedAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type testing_new_table2UpdateManyMutationInput = {
    Name?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type testing_new_table2UncheckedUpdateManyInput = {
    Id?: IntFieldUpdateOperationsInput | number
    Name?: StringFieldUpdateOperationsInput | string
    CreatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserroleNullableScalarRelationFilter = {
    is?: userroleWhereInput | null
    isNot?: userroleWhereInput | null
  }

  export type CustomerListRelationFilter = {
    every?: customerWhereInput
    some?: customerWhereInput
    none?: customerWhereInput
  }

  export type CustomerauditlogsListRelationFilter = {
    every?: customerauditlogsWhereInput
    some?: customerauditlogsWhereInput
    none?: customerauditlogsWhereInput
  }

  export type FormvisibilitystatusListRelationFilter = {
    every?: formvisibilitystatusWhereInput
    some?: formvisibilitystatusWhereInput
    none?: formvisibilitystatusWhereInput
  }

  export type NoteListRelationFilter = {
    every?: noteWhereInput
    some?: noteWhereInput
    none?: noteWhereInput
  }

  export type TransactionagentListRelationFilter = {
    every?: transactionagentWhereInput
    some?: transactionagentWhereInput
    none?: transactionagentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type customerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customerauditlogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type formvisibilitystatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type noteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transactionagentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type agentOrderByRelevanceInput = {
    fields: agentOrderByRelevanceFieldEnum | agentOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type agentCountOrderByAggregateInput = {
    AgentId?: SortOrder
    AwsId?: SortOrder
    UserRoleId?: SortOrder
  }

  export type agentAvgOrderByAggregateInput = {
    AgentId?: SortOrder
    UserRoleId?: SortOrder
  }

  export type agentMaxOrderByAggregateInput = {
    AgentId?: SortOrder
    AwsId?: SortOrder
    UserRoleId?: SortOrder
  }

  export type agentMinOrderByAggregateInput = {
    AgentId?: SortOrder
    AwsId?: SortOrder
    UserRoleId?: SortOrder
  }

  export type agentSumOrderByAggregateInput = {
    AgentId?: SortOrder
    UserRoleId?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type ExchangeratesListRelationFilter = {
    every?: exchangeratesWhereInput
    some?: exchangeratesWhereInput
    none?: exchangeratesWhereInput
  }

  export type FundraiserListRelationFilter = {
    every?: fundraiserWhereInput
    some?: fundraiserWhereInput
    none?: fundraiserWhereInput
  }

  export type exchangeratesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fundraiserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type basecountryOrderByRelevanceInput = {
    fields: basecountryOrderByRelevanceFieldEnum | basecountryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type basecountryCountOrderByAggregateInput = {
    BaseCountryID?: SortOrder
    BaseCountryName?: SortOrder
  }

  export type basecountryAvgOrderByAggregateInput = {
    BaseCountryID?: SortOrder
  }

  export type basecountryMaxOrderByAggregateInput = {
    BaseCountryID?: SortOrder
    BaseCountryName?: SortOrder
  }

  export type basecountryMinOrderByAggregateInput = {
    BaseCountryID?: SortOrder
    BaseCountryName?: SortOrder
  }

  export type basecountrySumOrderByAggregateInput = {
    BaseCountryID?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type Fundraiser_acceptedcurrenciesListRelationFilter = {
    every?: fundraiser_acceptedcurrenciesWhereInput
    some?: fundraiser_acceptedcurrenciesWhereInput
    none?: fundraiser_acceptedcurrenciesWhereInput
  }

  export type MinimumamountListRelationFilter = {
    every?: minimumamountWhereInput
    some?: minimumamountWhereInput
    none?: minimumamountWhereInput
  }

  export type WalletListRelationFilter = {
    every?: walletWhereInput
    some?: walletWhereInput
    none?: walletWhereInput
  }

  export type fundraiser_acceptedcurrenciesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type minimumamountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type walletOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type currencyOrderByRelevanceInput = {
    fields: currencyOrderByRelevanceFieldEnum | currencyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type currencyCountOrderByAggregateInput = {
    CurrencyId?: SortOrder
    CurrencyCode?: SortOrder
  }

  export type currencyAvgOrderByAggregateInput = {
    CurrencyId?: SortOrder
  }

  export type currencyMaxOrderByAggregateInput = {
    CurrencyId?: SortOrder
    CurrencyCode?: SortOrder
  }

  export type currencyMinOrderByAggregateInput = {
    CurrencyId?: SortOrder
    CurrencyCode?: SortOrder
  }

  export type currencySumOrderByAggregateInput = {
    CurrencyId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AgentNullableScalarRelationFilter = {
    is?: agentWhereInput | null
    isNot?: agentWhereInput | null
  }

  export type ManychatListRelationFilter = {
    every?: manychatWhereInput
    some?: manychatWhereInput
    none?: manychatWhereInput
  }

  export type TransactionsListRelationFilter = {
    every?: transactionsWhereInput
    some?: transactionsWhereInput
    none?: transactionsWhereInput
  }

  export type manychatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transactionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customerOrderByRelevanceInput = {
    fields: customerOrderByRelevanceFieldEnum | customerOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type customerCountOrderByAggregateInput = {
    CustomerId?: SortOrder
    Name?: SortOrder
    Email?: SortOrder
    ManyChatId?: SortOrder
    ExpireDate?: SortOrder
    UserCountry?: SortOrder
    ContactLink?: SortOrder
    AgentId?: SortOrder
    CardID?: SortOrder
  }

  export type customerAvgOrderByAggregateInput = {
    CustomerId?: SortOrder
    AgentId?: SortOrder
    CardID?: SortOrder
  }

  export type customerMaxOrderByAggregateInput = {
    CustomerId?: SortOrder
    Name?: SortOrder
    Email?: SortOrder
    ManyChatId?: SortOrder
    ExpireDate?: SortOrder
    UserCountry?: SortOrder
    ContactLink?: SortOrder
    AgentId?: SortOrder
    CardID?: SortOrder
  }

  export type customerMinOrderByAggregateInput = {
    CustomerId?: SortOrder
    Name?: SortOrder
    Email?: SortOrder
    ManyChatId?: SortOrder
    ExpireDate?: SortOrder
    UserCountry?: SortOrder
    ContactLink?: SortOrder
    AgentId?: SortOrder
    CardID?: SortOrder
  }

  export type customerSumOrderByAggregateInput = {
    CustomerId?: SortOrder
    AgentId?: SortOrder
    CardID?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Enumcustomerauditlogs_FieldChangedFilter<$PrismaModel = never> = {
    equals?: $Enums.customerauditlogs_FieldChanged | Enumcustomerauditlogs_FieldChangedFieldRefInput<$PrismaModel>
    in?: $Enums.customerauditlogs_FieldChanged[]
    notIn?: $Enums.customerauditlogs_FieldChanged[]
    not?: NestedEnumcustomerauditlogs_FieldChangedFilter<$PrismaModel> | $Enums.customerauditlogs_FieldChanged
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AgentScalarRelationFilter = {
    is?: agentWhereInput
    isNot?: agentWhereInput
  }

  export type CustomerScalarRelationFilter = {
    is?: customerWhereInput
    isNot?: customerWhereInput
  }

  export type customerauditlogsOrderByRelevanceInput = {
    fields: customerauditlogsOrderByRelevanceFieldEnum | customerauditlogsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type customerauditlogsCountOrderByAggregateInput = {
    LogId?: SortOrder
    AgentId?: SortOrder
    FieldChanged?: SortOrder
    OldValue?: SortOrder
    NewValue?: SortOrder
    CustomerId?: SortOrder
    ChangeDate?: SortOrder
  }

  export type customerauditlogsAvgOrderByAggregateInput = {
    LogId?: SortOrder
    AgentId?: SortOrder
    CustomerId?: SortOrder
  }

  export type customerauditlogsMaxOrderByAggregateInput = {
    LogId?: SortOrder
    AgentId?: SortOrder
    FieldChanged?: SortOrder
    OldValue?: SortOrder
    NewValue?: SortOrder
    CustomerId?: SortOrder
    ChangeDate?: SortOrder
  }

  export type customerauditlogsMinOrderByAggregateInput = {
    LogId?: SortOrder
    AgentId?: SortOrder
    FieldChanged?: SortOrder
    OldValue?: SortOrder
    NewValue?: SortOrder
    CustomerId?: SortOrder
    ChangeDate?: SortOrder
  }

  export type customerauditlogsSumOrderByAggregateInput = {
    LogId?: SortOrder
    AgentId?: SortOrder
    CustomerId?: SortOrder
  }

  export type Enumcustomerauditlogs_FieldChangedWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.customerauditlogs_FieldChanged | Enumcustomerauditlogs_FieldChangedFieldRefInput<$PrismaModel>
    in?: $Enums.customerauditlogs_FieldChanged[]
    notIn?: $Enums.customerauditlogs_FieldChanged[]
    not?: NestedEnumcustomerauditlogs_FieldChangedWithAggregatesFilter<$PrismaModel> | $Enums.customerauditlogs_FieldChanged
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcustomerauditlogs_FieldChangedFilter<$PrismaModel>
    _max?: NestedEnumcustomerauditlogs_FieldChangedFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BasecountryScalarRelationFilter = {
    is?: basecountryWhereInput
    isNot?: basecountryWhereInput
  }

  export type CurrencyScalarRelationFilter = {
    is?: currencyWhereInput
    isNot?: currencyWhereInput
  }

  export type exchangeratesCountOrderByAggregateInput = {
    ExchangeRateId?: SortOrder
    BaseCountryId?: SortOrder
    CurrencyId?: SortOrder
    ExchangeRate?: SortOrder
    CreateAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type exchangeratesAvgOrderByAggregateInput = {
    ExchangeRateId?: SortOrder
    BaseCountryId?: SortOrder
    CurrencyId?: SortOrder
    ExchangeRate?: SortOrder
  }

  export type exchangeratesMaxOrderByAggregateInput = {
    ExchangeRateId?: SortOrder
    BaseCountryId?: SortOrder
    CurrencyId?: SortOrder
    ExchangeRate?: SortOrder
    CreateAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type exchangeratesMinOrderByAggregateInput = {
    ExchangeRateId?: SortOrder
    BaseCountryId?: SortOrder
    CurrencyId?: SortOrder
    ExchangeRate?: SortOrder
    CreateAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type exchangeratesSumOrderByAggregateInput = {
    ExchangeRateId?: SortOrder
    BaseCountryId?: SortOrder
    CurrencyId?: SortOrder
    ExchangeRate?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type TransactionsNullableScalarRelationFilter = {
    is?: transactionsWhereInput | null
    isNot?: transactionsWhereInput | null
  }

  export type TransactionstatusNullableScalarRelationFilter = {
    is?: transactionstatusWhereInput | null
    isNot?: transactionstatusWhereInput | null
  }

  export type formstatusCountOrderByAggregateInput = {
    FormStatusID?: SortOrder
    TransactionID?: SortOrder
    TransactionStatusID?: SortOrder
  }

  export type formstatusAvgOrderByAggregateInput = {
    FormStatusID?: SortOrder
    TransactionID?: SortOrder
    TransactionStatusID?: SortOrder
  }

  export type formstatusMaxOrderByAggregateInput = {
    FormStatusID?: SortOrder
    TransactionID?: SortOrder
    TransactionStatusID?: SortOrder
  }

  export type formstatusMinOrderByAggregateInput = {
    FormStatusID?: SortOrder
    TransactionID?: SortOrder
    TransactionStatusID?: SortOrder
  }

  export type formstatusSumOrderByAggregateInput = {
    FormStatusID?: SortOrder
    TransactionID?: SortOrder
    TransactionStatusID?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type formvisibilitystatusCountOrderByAggregateInput = {
    VisibilityStatusId?: SortOrder
    AgentId?: SortOrder
    IsFormOpen?: SortOrder
    FormTimeStamp?: SortOrder
  }

  export type formvisibilitystatusAvgOrderByAggregateInput = {
    VisibilityStatusId?: SortOrder
    AgentId?: SortOrder
  }

  export type formvisibilitystatusMaxOrderByAggregateInput = {
    VisibilityStatusId?: SortOrder
    AgentId?: SortOrder
    IsFormOpen?: SortOrder
    FormTimeStamp?: SortOrder
  }

  export type formvisibilitystatusMinOrderByAggregateInput = {
    VisibilityStatusId?: SortOrder
    AgentId?: SortOrder
    IsFormOpen?: SortOrder
    FormTimeStamp?: SortOrder
  }

  export type formvisibilitystatusSumOrderByAggregateInput = {
    VisibilityStatusId?: SortOrder
    AgentId?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type BasecountryNullableScalarRelationFilter = {
    is?: basecountryWhereInput | null
    isNot?: basecountryWhereInput | null
  }

  export type Fundraiser_contactlinksListRelationFilter = {
    every?: fundraiser_contactlinksWhereInput
    some?: fundraiser_contactlinksWhereInput
    none?: fundraiser_contactlinksWhereInput
  }

  export type fundraiser_contactlinksOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fundraiserOrderByRelevanceInput = {
    fields: fundraiserOrderByRelevanceFieldEnum | fundraiserOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type fundraiserCountOrderByAggregateInput = {
    FundraiserID?: SortOrder
    FundraiserName?: SortOrder
    FundraiserEmail?: SortOrder
    FundraiserLogo?: SortOrder
    BaseCountryID?: SortOrder
    FundraiserCentralID?: SortOrder
  }

  export type fundraiserAvgOrderByAggregateInput = {
    FundraiserID?: SortOrder
    BaseCountryID?: SortOrder
    FundraiserCentralID?: SortOrder
  }

  export type fundraiserMaxOrderByAggregateInput = {
    FundraiserID?: SortOrder
    FundraiserName?: SortOrder
    FundraiserEmail?: SortOrder
    FundraiserLogo?: SortOrder
    BaseCountryID?: SortOrder
    FundraiserCentralID?: SortOrder
  }

  export type fundraiserMinOrderByAggregateInput = {
    FundraiserID?: SortOrder
    FundraiserName?: SortOrder
    FundraiserEmail?: SortOrder
    FundraiserLogo?: SortOrder
    BaseCountryID?: SortOrder
    FundraiserCentralID?: SortOrder
  }

  export type fundraiserSumOrderByAggregateInput = {
    FundraiserID?: SortOrder
    BaseCountryID?: SortOrder
    FundraiserCentralID?: SortOrder
  }

  export type FundraiserNullableScalarRelationFilter = {
    is?: fundraiserWhereInput | null
    isNot?: fundraiserWhereInput | null
  }

  export type CurrencyNullableScalarRelationFilter = {
    is?: currencyWhereInput | null
    isNot?: currencyWhereInput | null
  }

  export type fundraiser_acceptedcurrenciesCountOrderByAggregateInput = {
    FundraiserAcceptedCurrencyID?: SortOrder
    FundraiserID?: SortOrder
    CurrencyID?: SortOrder
  }

  export type fundraiser_acceptedcurrenciesAvgOrderByAggregateInput = {
    FundraiserAcceptedCurrencyID?: SortOrder
    FundraiserID?: SortOrder
    CurrencyID?: SortOrder
  }

  export type fundraiser_acceptedcurrenciesMaxOrderByAggregateInput = {
    FundraiserAcceptedCurrencyID?: SortOrder
    FundraiserID?: SortOrder
    CurrencyID?: SortOrder
  }

  export type fundraiser_acceptedcurrenciesMinOrderByAggregateInput = {
    FundraiserAcceptedCurrencyID?: SortOrder
    FundraiserID?: SortOrder
    CurrencyID?: SortOrder
  }

  export type fundraiser_acceptedcurrenciesSumOrderByAggregateInput = {
    FundraiserAcceptedCurrencyID?: SortOrder
    FundraiserID?: SortOrder
    CurrencyID?: SortOrder
  }

  export type fundraiser_contactlinksOrderByRelevanceInput = {
    fields: fundraiser_contactlinksOrderByRelevanceFieldEnum | fundraiser_contactlinksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type fundraiser_contactlinksCountOrderByAggregateInput = {
    ContactID?: SortOrder
    FundraiserID?: SortOrder
    Platform?: SortOrder
    ContactURL?: SortOrder
  }

  export type fundraiser_contactlinksAvgOrderByAggregateInput = {
    ContactID?: SortOrder
    FundraiserID?: SortOrder
    Platform?: SortOrder
  }

  export type fundraiser_contactlinksMaxOrderByAggregateInput = {
    ContactID?: SortOrder
    FundraiserID?: SortOrder
    Platform?: SortOrder
    ContactURL?: SortOrder
  }

  export type fundraiser_contactlinksMinOrderByAggregateInput = {
    ContactID?: SortOrder
    FundraiserID?: SortOrder
    Platform?: SortOrder
    ContactURL?: SortOrder
  }

  export type fundraiser_contactlinksSumOrderByAggregateInput = {
    ContactID?: SortOrder
    FundraiserID?: SortOrder
    Platform?: SortOrder
  }

  export type manychatOrderByRelevanceInput = {
    fields: manychatOrderByRelevanceFieldEnum | manychatOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type manychatCountOrderByAggregateInput = {
    ManyChatId?: SortOrder
    ConversationId?: SortOrder
    CustomerId?: SortOrder
    CreateAt?: SortOrder
    UpdateAt?: SortOrder
  }

  export type manychatAvgOrderByAggregateInput = {
    ManyChatId?: SortOrder
    CustomerId?: SortOrder
  }

  export type manychatMaxOrderByAggregateInput = {
    ManyChatId?: SortOrder
    ConversationId?: SortOrder
    CustomerId?: SortOrder
    CreateAt?: SortOrder
    UpdateAt?: SortOrder
  }

  export type manychatMinOrderByAggregateInput = {
    ManyChatId?: SortOrder
    ConversationId?: SortOrder
    CustomerId?: SortOrder
    CreateAt?: SortOrder
    UpdateAt?: SortOrder
  }

  export type manychatSumOrderByAggregateInput = {
    ManyChatId?: SortOrder
    CustomerId?: SortOrder
  }

  export type minimumamountCountOrderByAggregateInput = {
    MinimumAmountId?: SortOrder
    CurrencyId?: SortOrder
    Amount?: SortOrder
    CreateAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type minimumamountAvgOrderByAggregateInput = {
    MinimumAmountId?: SortOrder
    CurrencyId?: SortOrder
    Amount?: SortOrder
  }

  export type minimumamountMaxOrderByAggregateInput = {
    MinimumAmountId?: SortOrder
    CurrencyId?: SortOrder
    Amount?: SortOrder
    CreateAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type minimumamountMinOrderByAggregateInput = {
    MinimumAmountId?: SortOrder
    CurrencyId?: SortOrder
    Amount?: SortOrder
    CreateAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type minimumamountSumOrderByAggregateInput = {
    MinimumAmountId?: SortOrder
    CurrencyId?: SortOrder
    Amount?: SortOrder
  }

  export type noteOrderByRelevanceInput = {
    fields: noteOrderByRelevanceFieldEnum | noteOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type noteCountOrderByAggregateInput = {
    NoteID?: SortOrder
    Note?: SortOrder
    Date?: SortOrder
    AgentID?: SortOrder
  }

  export type noteAvgOrderByAggregateInput = {
    NoteID?: SortOrder
    AgentID?: SortOrder
  }

  export type noteMaxOrderByAggregateInput = {
    NoteID?: SortOrder
    Note?: SortOrder
    Date?: SortOrder
    AgentID?: SortOrder
  }

  export type noteMinOrderByAggregateInput = {
    NoteID?: SortOrder
    Note?: SortOrder
    Date?: SortOrder
    AgentID?: SortOrder
  }

  export type noteSumOrderByAggregateInput = {
    NoteID?: SortOrder
    AgentID?: SortOrder
  }

  export type platformOrderByRelevanceInput = {
    fields: platformOrderByRelevanceFieldEnum | platformOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type platformCountOrderByAggregateInput = {
    PlatformID?: SortOrder
    PlatformName?: SortOrder
  }

  export type platformAvgOrderByAggregateInput = {
    PlatformID?: SortOrder
  }

  export type platformMaxOrderByAggregateInput = {
    PlatformID?: SortOrder
    PlatformName?: SortOrder
  }

  export type platformMinOrderByAggregateInput = {
    PlatformID?: SortOrder
    PlatformName?: SortOrder
  }

  export type platformSumOrderByAggregateInput = {
    PlatformID?: SortOrder
  }

  export type screenshotOrderByRelevanceInput = {
    fields: screenshotOrderByRelevanceFieldEnum | screenshotOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type screenshotCountOrderByAggregateInput = {
    ScreenShotID?: SortOrder
    TransactionID?: SortOrder
    ScreenShotLink?: SortOrder
  }

  export type screenshotAvgOrderByAggregateInput = {
    ScreenShotID?: SortOrder
    TransactionID?: SortOrder
  }

  export type screenshotMaxOrderByAggregateInput = {
    ScreenShotID?: SortOrder
    TransactionID?: SortOrder
    ScreenShotLink?: SortOrder
  }

  export type screenshotMinOrderByAggregateInput = {
    ScreenShotID?: SortOrder
    TransactionID?: SortOrder
    ScreenShotLink?: SortOrder
  }

  export type screenshotSumOrderByAggregateInput = {
    ScreenShotID?: SortOrder
    TransactionID?: SortOrder
  }

  export type supportregionOrderByRelevanceInput = {
    fields: supportregionOrderByRelevanceFieldEnum | supportregionOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type supportregionCountOrderByAggregateInput = {
    SupportRegionID?: SortOrder
    Region?: SortOrder
  }

  export type supportregionAvgOrderByAggregateInput = {
    SupportRegionID?: SortOrder
  }

  export type supportregionMaxOrderByAggregateInput = {
    SupportRegionID?: SortOrder
    Region?: SortOrder
  }

  export type supportregionMinOrderByAggregateInput = {
    SupportRegionID?: SortOrder
    Region?: SortOrder
  }

  export type supportregionSumOrderByAggregateInput = {
    SupportRegionID?: SortOrder
  }

  export type transactionagentCountOrderByAggregateInput = {
    TransactionAgentID?: SortOrder
    TransactionID?: SortOrder
    AgentID?: SortOrder
    LogDate?: SortOrder
  }

  export type transactionagentAvgOrderByAggregateInput = {
    TransactionAgentID?: SortOrder
    TransactionID?: SortOrder
    AgentID?: SortOrder
  }

  export type transactionagentMaxOrderByAggregateInput = {
    TransactionAgentID?: SortOrder
    TransactionID?: SortOrder
    AgentID?: SortOrder
    LogDate?: SortOrder
  }

  export type transactionagentMinOrderByAggregateInput = {
    TransactionAgentID?: SortOrder
    TransactionID?: SortOrder
    AgentID?: SortOrder
    LogDate?: SortOrder
  }

  export type transactionagentSumOrderByAggregateInput = {
    TransactionAgentID?: SortOrder
    TransactionID?: SortOrder
    AgentID?: SortOrder
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type FormstatusListRelationFilter = {
    every?: formstatusWhereInput
    some?: formstatusWhereInput
    none?: formstatusWhereInput
  }

  export type ScreenshotListRelationFilter = {
    every?: screenshotWhereInput
    some?: screenshotWhereInput
    none?: screenshotWhereInput
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: customerWhereInput | null
    isNot?: customerWhereInput | null
  }

  export type SupportregionNullableScalarRelationFilter = {
    is?: supportregionWhereInput | null
    isNot?: supportregionWhereInput | null
  }

  export type WalletNullableScalarRelationFilter = {
    is?: walletWhereInput | null
    isNot?: walletWhereInput | null
  }

  export type NoteNullableScalarRelationFilter = {
    is?: noteWhereInput | null
    isNot?: noteWhereInput | null
  }

  export type formstatusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type screenshotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type transactionsCountOrderByAggregateInput = {
    TransactionID?: SortOrder
    CustomerID?: SortOrder
    SupportRegionID?: SortOrder
    WalletID?: SortOrder
    Amount?: SortOrder
    PaymentCheck?: SortOrder
    PaymentCheckTime?: SortOrder
    NoteID?: SortOrder
    TransactionDate?: SortOrder
    PaymentDenied?: SortOrder
    Month?: SortOrder
    HopeFuelID?: SortOrder
  }

  export type transactionsAvgOrderByAggregateInput = {
    TransactionID?: SortOrder
    CustomerID?: SortOrder
    SupportRegionID?: SortOrder
    WalletID?: SortOrder
    Amount?: SortOrder
    NoteID?: SortOrder
    Month?: SortOrder
    HopeFuelID?: SortOrder
  }

  export type transactionsMaxOrderByAggregateInput = {
    TransactionID?: SortOrder
    CustomerID?: SortOrder
    SupportRegionID?: SortOrder
    WalletID?: SortOrder
    Amount?: SortOrder
    PaymentCheck?: SortOrder
    PaymentCheckTime?: SortOrder
    NoteID?: SortOrder
    TransactionDate?: SortOrder
    PaymentDenied?: SortOrder
    Month?: SortOrder
    HopeFuelID?: SortOrder
  }

  export type transactionsMinOrderByAggregateInput = {
    TransactionID?: SortOrder
    CustomerID?: SortOrder
    SupportRegionID?: SortOrder
    WalletID?: SortOrder
    Amount?: SortOrder
    PaymentCheck?: SortOrder
    PaymentCheckTime?: SortOrder
    NoteID?: SortOrder
    TransactionDate?: SortOrder
    PaymentDenied?: SortOrder
    Month?: SortOrder
    HopeFuelID?: SortOrder
  }

  export type transactionsSumOrderByAggregateInput = {
    TransactionID?: SortOrder
    CustomerID?: SortOrder
    SupportRegionID?: SortOrder
    WalletID?: SortOrder
    Amount?: SortOrder
    NoteID?: SortOrder
    Month?: SortOrder
    HopeFuelID?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type transactionstatusOrderByRelevanceInput = {
    fields: transactionstatusOrderByRelevanceFieldEnum | transactionstatusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type transactionstatusCountOrderByAggregateInput = {
    TransactionStatusID?: SortOrder
    TransactionStatus?: SortOrder
  }

  export type transactionstatusAvgOrderByAggregateInput = {
    TransactionStatusID?: SortOrder
  }

  export type transactionstatusMaxOrderByAggregateInput = {
    TransactionStatusID?: SortOrder
    TransactionStatus?: SortOrder
  }

  export type transactionstatusMinOrderByAggregateInput = {
    TransactionStatusID?: SortOrder
    TransactionStatus?: SortOrder
  }

  export type transactionstatusSumOrderByAggregateInput = {
    TransactionStatusID?: SortOrder
  }

  export type AgentListRelationFilter = {
    every?: agentWhereInput
    some?: agentWhereInput
    none?: agentWhereInput
  }

  export type agentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userroleOrderByRelevanceInput = {
    fields: userroleOrderByRelevanceFieldEnum | userroleOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type userroleCountOrderByAggregateInput = {
    UserRoleID?: SortOrder
    UserRole?: SortOrder
  }

  export type userroleAvgOrderByAggregateInput = {
    UserRoleID?: SortOrder
  }

  export type userroleMaxOrderByAggregateInput = {
    UserRoleID?: SortOrder
    UserRole?: SortOrder
  }

  export type userroleMinOrderByAggregateInput = {
    UserRoleID?: SortOrder
    UserRole?: SortOrder
  }

  export type userroleSumOrderByAggregateInput = {
    UserRoleID?: SortOrder
  }

  export type walletOrderByRelevanceInput = {
    fields: walletOrderByRelevanceFieldEnum | walletOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type walletCountOrderByAggregateInput = {
    WalletId?: SortOrder
    CurrencyId?: SortOrder
    WalletName?: SortOrder
  }

  export type walletAvgOrderByAggregateInput = {
    WalletId?: SortOrder
    CurrencyId?: SortOrder
  }

  export type walletMaxOrderByAggregateInput = {
    WalletId?: SortOrder
    CurrencyId?: SortOrder
    WalletName?: SortOrder
  }

  export type walletMinOrderByAggregateInput = {
    WalletId?: SortOrder
    CurrencyId?: SortOrder
    WalletName?: SortOrder
  }

  export type walletSumOrderByAggregateInput = {
    WalletId?: SortOrder
    CurrencyId?: SortOrder
  }

  export type testing_new_tableOrderByRelevanceInput = {
    fields: testing_new_tableOrderByRelevanceFieldEnum | testing_new_tableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type testing_new_tableCountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type testing_new_tableAvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type testing_new_tableMaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type testing_new_tableMinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type testing_new_tableSumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type testing_new_table2OrderByRelevanceInput = {
    fields: testing_new_table2OrderByRelevanceFieldEnum | testing_new_table2OrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type testing_new_table2CountOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type testing_new_table2AvgOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type testing_new_table2MaxOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type testing_new_table2MinOrderByAggregateInput = {
    Id?: SortOrder
    Name?: SortOrder
    CreatedAt?: SortOrder
    UpdatedAt?: SortOrder
  }

  export type testing_new_table2SumOrderByAggregateInput = {
    Id?: SortOrder
  }

  export type userroleCreateNestedOneWithoutAgentInput = {
    create?: XOR<userroleCreateWithoutAgentInput, userroleUncheckedCreateWithoutAgentInput>
    connectOrCreate?: userroleCreateOrConnectWithoutAgentInput
    connect?: userroleWhereUniqueInput
  }

  export type customerCreateNestedManyWithoutAgentInput = {
    create?: XOR<customerCreateWithoutAgentInput, customerUncheckedCreateWithoutAgentInput> | customerCreateWithoutAgentInput[] | customerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: customerCreateOrConnectWithoutAgentInput | customerCreateOrConnectWithoutAgentInput[]
    createMany?: customerCreateManyAgentInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type customerauditlogsCreateNestedManyWithoutAgentInput = {
    create?: XOR<customerauditlogsCreateWithoutAgentInput, customerauditlogsUncheckedCreateWithoutAgentInput> | customerauditlogsCreateWithoutAgentInput[] | customerauditlogsUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: customerauditlogsCreateOrConnectWithoutAgentInput | customerauditlogsCreateOrConnectWithoutAgentInput[]
    createMany?: customerauditlogsCreateManyAgentInputEnvelope
    connect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
  }

  export type formvisibilitystatusCreateNestedManyWithoutAgentInput = {
    create?: XOR<formvisibilitystatusCreateWithoutAgentInput, formvisibilitystatusUncheckedCreateWithoutAgentInput> | formvisibilitystatusCreateWithoutAgentInput[] | formvisibilitystatusUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: formvisibilitystatusCreateOrConnectWithoutAgentInput | formvisibilitystatusCreateOrConnectWithoutAgentInput[]
    createMany?: formvisibilitystatusCreateManyAgentInputEnvelope
    connect?: formvisibilitystatusWhereUniqueInput | formvisibilitystatusWhereUniqueInput[]
  }

  export type noteCreateNestedManyWithoutAgentInput = {
    create?: XOR<noteCreateWithoutAgentInput, noteUncheckedCreateWithoutAgentInput> | noteCreateWithoutAgentInput[] | noteUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: noteCreateOrConnectWithoutAgentInput | noteCreateOrConnectWithoutAgentInput[]
    createMany?: noteCreateManyAgentInputEnvelope
    connect?: noteWhereUniqueInput | noteWhereUniqueInput[]
  }

  export type transactionagentCreateNestedManyWithoutAgentInput = {
    create?: XOR<transactionagentCreateWithoutAgentInput, transactionagentUncheckedCreateWithoutAgentInput> | transactionagentCreateWithoutAgentInput[] | transactionagentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: transactionagentCreateOrConnectWithoutAgentInput | transactionagentCreateOrConnectWithoutAgentInput[]
    createMany?: transactionagentCreateManyAgentInputEnvelope
    connect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
  }

  export type customerUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<customerCreateWithoutAgentInput, customerUncheckedCreateWithoutAgentInput> | customerCreateWithoutAgentInput[] | customerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: customerCreateOrConnectWithoutAgentInput | customerCreateOrConnectWithoutAgentInput[]
    createMany?: customerCreateManyAgentInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type customerauditlogsUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<customerauditlogsCreateWithoutAgentInput, customerauditlogsUncheckedCreateWithoutAgentInput> | customerauditlogsCreateWithoutAgentInput[] | customerauditlogsUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: customerauditlogsCreateOrConnectWithoutAgentInput | customerauditlogsCreateOrConnectWithoutAgentInput[]
    createMany?: customerauditlogsCreateManyAgentInputEnvelope
    connect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
  }

  export type formvisibilitystatusUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<formvisibilitystatusCreateWithoutAgentInput, formvisibilitystatusUncheckedCreateWithoutAgentInput> | formvisibilitystatusCreateWithoutAgentInput[] | formvisibilitystatusUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: formvisibilitystatusCreateOrConnectWithoutAgentInput | formvisibilitystatusCreateOrConnectWithoutAgentInput[]
    createMany?: formvisibilitystatusCreateManyAgentInputEnvelope
    connect?: formvisibilitystatusWhereUniqueInput | formvisibilitystatusWhereUniqueInput[]
  }

  export type noteUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<noteCreateWithoutAgentInput, noteUncheckedCreateWithoutAgentInput> | noteCreateWithoutAgentInput[] | noteUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: noteCreateOrConnectWithoutAgentInput | noteCreateOrConnectWithoutAgentInput[]
    createMany?: noteCreateManyAgentInputEnvelope
    connect?: noteWhereUniqueInput | noteWhereUniqueInput[]
  }

  export type transactionagentUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<transactionagentCreateWithoutAgentInput, transactionagentUncheckedCreateWithoutAgentInput> | transactionagentCreateWithoutAgentInput[] | transactionagentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: transactionagentCreateOrConnectWithoutAgentInput | transactionagentCreateOrConnectWithoutAgentInput[]
    createMany?: transactionagentCreateManyAgentInputEnvelope
    connect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type userroleUpdateOneWithoutAgentNestedInput = {
    create?: XOR<userroleCreateWithoutAgentInput, userroleUncheckedCreateWithoutAgentInput>
    connectOrCreate?: userroleCreateOrConnectWithoutAgentInput
    upsert?: userroleUpsertWithoutAgentInput
    disconnect?: userroleWhereInput | boolean
    delete?: userroleWhereInput | boolean
    connect?: userroleWhereUniqueInput
    update?: XOR<XOR<userroleUpdateToOneWithWhereWithoutAgentInput, userroleUpdateWithoutAgentInput>, userroleUncheckedUpdateWithoutAgentInput>
  }

  export type customerUpdateManyWithoutAgentNestedInput = {
    create?: XOR<customerCreateWithoutAgentInput, customerUncheckedCreateWithoutAgentInput> | customerCreateWithoutAgentInput[] | customerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: customerCreateOrConnectWithoutAgentInput | customerCreateOrConnectWithoutAgentInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutAgentInput | customerUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: customerCreateManyAgentInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutAgentInput | customerUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: customerUpdateManyWithWhereWithoutAgentInput | customerUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type customerauditlogsUpdateManyWithoutAgentNestedInput = {
    create?: XOR<customerauditlogsCreateWithoutAgentInput, customerauditlogsUncheckedCreateWithoutAgentInput> | customerauditlogsCreateWithoutAgentInput[] | customerauditlogsUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: customerauditlogsCreateOrConnectWithoutAgentInput | customerauditlogsCreateOrConnectWithoutAgentInput[]
    upsert?: customerauditlogsUpsertWithWhereUniqueWithoutAgentInput | customerauditlogsUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: customerauditlogsCreateManyAgentInputEnvelope
    set?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    disconnect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    delete?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    connect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    update?: customerauditlogsUpdateWithWhereUniqueWithoutAgentInput | customerauditlogsUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: customerauditlogsUpdateManyWithWhereWithoutAgentInput | customerauditlogsUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: customerauditlogsScalarWhereInput | customerauditlogsScalarWhereInput[]
  }

  export type formvisibilitystatusUpdateManyWithoutAgentNestedInput = {
    create?: XOR<formvisibilitystatusCreateWithoutAgentInput, formvisibilitystatusUncheckedCreateWithoutAgentInput> | formvisibilitystatusCreateWithoutAgentInput[] | formvisibilitystatusUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: formvisibilitystatusCreateOrConnectWithoutAgentInput | formvisibilitystatusCreateOrConnectWithoutAgentInput[]
    upsert?: formvisibilitystatusUpsertWithWhereUniqueWithoutAgentInput | formvisibilitystatusUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: formvisibilitystatusCreateManyAgentInputEnvelope
    set?: formvisibilitystatusWhereUniqueInput | formvisibilitystatusWhereUniqueInput[]
    disconnect?: formvisibilitystatusWhereUniqueInput | formvisibilitystatusWhereUniqueInput[]
    delete?: formvisibilitystatusWhereUniqueInput | formvisibilitystatusWhereUniqueInput[]
    connect?: formvisibilitystatusWhereUniqueInput | formvisibilitystatusWhereUniqueInput[]
    update?: formvisibilitystatusUpdateWithWhereUniqueWithoutAgentInput | formvisibilitystatusUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: formvisibilitystatusUpdateManyWithWhereWithoutAgentInput | formvisibilitystatusUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: formvisibilitystatusScalarWhereInput | formvisibilitystatusScalarWhereInput[]
  }

  export type noteUpdateManyWithoutAgentNestedInput = {
    create?: XOR<noteCreateWithoutAgentInput, noteUncheckedCreateWithoutAgentInput> | noteCreateWithoutAgentInput[] | noteUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: noteCreateOrConnectWithoutAgentInput | noteCreateOrConnectWithoutAgentInput[]
    upsert?: noteUpsertWithWhereUniqueWithoutAgentInput | noteUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: noteCreateManyAgentInputEnvelope
    set?: noteWhereUniqueInput | noteWhereUniqueInput[]
    disconnect?: noteWhereUniqueInput | noteWhereUniqueInput[]
    delete?: noteWhereUniqueInput | noteWhereUniqueInput[]
    connect?: noteWhereUniqueInput | noteWhereUniqueInput[]
    update?: noteUpdateWithWhereUniqueWithoutAgentInput | noteUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: noteUpdateManyWithWhereWithoutAgentInput | noteUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: noteScalarWhereInput | noteScalarWhereInput[]
  }

  export type transactionagentUpdateManyWithoutAgentNestedInput = {
    create?: XOR<transactionagentCreateWithoutAgentInput, transactionagentUncheckedCreateWithoutAgentInput> | transactionagentCreateWithoutAgentInput[] | transactionagentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: transactionagentCreateOrConnectWithoutAgentInput | transactionagentCreateOrConnectWithoutAgentInput[]
    upsert?: transactionagentUpsertWithWhereUniqueWithoutAgentInput | transactionagentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: transactionagentCreateManyAgentInputEnvelope
    set?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    disconnect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    delete?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    connect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    update?: transactionagentUpdateWithWhereUniqueWithoutAgentInput | transactionagentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: transactionagentUpdateManyWithWhereWithoutAgentInput | transactionagentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: transactionagentScalarWhereInput | transactionagentScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type customerUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<customerCreateWithoutAgentInput, customerUncheckedCreateWithoutAgentInput> | customerCreateWithoutAgentInput[] | customerUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: customerCreateOrConnectWithoutAgentInput | customerCreateOrConnectWithoutAgentInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutAgentInput | customerUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: customerCreateManyAgentInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutAgentInput | customerUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: customerUpdateManyWithWhereWithoutAgentInput | customerUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type customerauditlogsUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<customerauditlogsCreateWithoutAgentInput, customerauditlogsUncheckedCreateWithoutAgentInput> | customerauditlogsCreateWithoutAgentInput[] | customerauditlogsUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: customerauditlogsCreateOrConnectWithoutAgentInput | customerauditlogsCreateOrConnectWithoutAgentInput[]
    upsert?: customerauditlogsUpsertWithWhereUniqueWithoutAgentInput | customerauditlogsUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: customerauditlogsCreateManyAgentInputEnvelope
    set?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    disconnect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    delete?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    connect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    update?: customerauditlogsUpdateWithWhereUniqueWithoutAgentInput | customerauditlogsUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: customerauditlogsUpdateManyWithWhereWithoutAgentInput | customerauditlogsUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: customerauditlogsScalarWhereInput | customerauditlogsScalarWhereInput[]
  }

  export type formvisibilitystatusUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<formvisibilitystatusCreateWithoutAgentInput, formvisibilitystatusUncheckedCreateWithoutAgentInput> | formvisibilitystatusCreateWithoutAgentInput[] | formvisibilitystatusUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: formvisibilitystatusCreateOrConnectWithoutAgentInput | formvisibilitystatusCreateOrConnectWithoutAgentInput[]
    upsert?: formvisibilitystatusUpsertWithWhereUniqueWithoutAgentInput | formvisibilitystatusUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: formvisibilitystatusCreateManyAgentInputEnvelope
    set?: formvisibilitystatusWhereUniqueInput | formvisibilitystatusWhereUniqueInput[]
    disconnect?: formvisibilitystatusWhereUniqueInput | formvisibilitystatusWhereUniqueInput[]
    delete?: formvisibilitystatusWhereUniqueInput | formvisibilitystatusWhereUniqueInput[]
    connect?: formvisibilitystatusWhereUniqueInput | formvisibilitystatusWhereUniqueInput[]
    update?: formvisibilitystatusUpdateWithWhereUniqueWithoutAgentInput | formvisibilitystatusUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: formvisibilitystatusUpdateManyWithWhereWithoutAgentInput | formvisibilitystatusUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: formvisibilitystatusScalarWhereInput | formvisibilitystatusScalarWhereInput[]
  }

  export type noteUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<noteCreateWithoutAgentInput, noteUncheckedCreateWithoutAgentInput> | noteCreateWithoutAgentInput[] | noteUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: noteCreateOrConnectWithoutAgentInput | noteCreateOrConnectWithoutAgentInput[]
    upsert?: noteUpsertWithWhereUniqueWithoutAgentInput | noteUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: noteCreateManyAgentInputEnvelope
    set?: noteWhereUniqueInput | noteWhereUniqueInput[]
    disconnect?: noteWhereUniqueInput | noteWhereUniqueInput[]
    delete?: noteWhereUniqueInput | noteWhereUniqueInput[]
    connect?: noteWhereUniqueInput | noteWhereUniqueInput[]
    update?: noteUpdateWithWhereUniqueWithoutAgentInput | noteUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: noteUpdateManyWithWhereWithoutAgentInput | noteUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: noteScalarWhereInput | noteScalarWhereInput[]
  }

  export type transactionagentUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<transactionagentCreateWithoutAgentInput, transactionagentUncheckedCreateWithoutAgentInput> | transactionagentCreateWithoutAgentInput[] | transactionagentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: transactionagentCreateOrConnectWithoutAgentInput | transactionagentCreateOrConnectWithoutAgentInput[]
    upsert?: transactionagentUpsertWithWhereUniqueWithoutAgentInput | transactionagentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: transactionagentCreateManyAgentInputEnvelope
    set?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    disconnect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    delete?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    connect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    update?: transactionagentUpdateWithWhereUniqueWithoutAgentInput | transactionagentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: transactionagentUpdateManyWithWhereWithoutAgentInput | transactionagentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: transactionagentScalarWhereInput | transactionagentScalarWhereInput[]
  }

  export type exchangeratesCreateNestedManyWithoutBasecountryInput = {
    create?: XOR<exchangeratesCreateWithoutBasecountryInput, exchangeratesUncheckedCreateWithoutBasecountryInput> | exchangeratesCreateWithoutBasecountryInput[] | exchangeratesUncheckedCreateWithoutBasecountryInput[]
    connectOrCreate?: exchangeratesCreateOrConnectWithoutBasecountryInput | exchangeratesCreateOrConnectWithoutBasecountryInput[]
    createMany?: exchangeratesCreateManyBasecountryInputEnvelope
    connect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
  }

  export type fundraiserCreateNestedManyWithoutBasecountryInput = {
    create?: XOR<fundraiserCreateWithoutBasecountryInput, fundraiserUncheckedCreateWithoutBasecountryInput> | fundraiserCreateWithoutBasecountryInput[] | fundraiserUncheckedCreateWithoutBasecountryInput[]
    connectOrCreate?: fundraiserCreateOrConnectWithoutBasecountryInput | fundraiserCreateOrConnectWithoutBasecountryInput[]
    createMany?: fundraiserCreateManyBasecountryInputEnvelope
    connect?: fundraiserWhereUniqueInput | fundraiserWhereUniqueInput[]
  }

  export type exchangeratesUncheckedCreateNestedManyWithoutBasecountryInput = {
    create?: XOR<exchangeratesCreateWithoutBasecountryInput, exchangeratesUncheckedCreateWithoutBasecountryInput> | exchangeratesCreateWithoutBasecountryInput[] | exchangeratesUncheckedCreateWithoutBasecountryInput[]
    connectOrCreate?: exchangeratesCreateOrConnectWithoutBasecountryInput | exchangeratesCreateOrConnectWithoutBasecountryInput[]
    createMany?: exchangeratesCreateManyBasecountryInputEnvelope
    connect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
  }

  export type fundraiserUncheckedCreateNestedManyWithoutBasecountryInput = {
    create?: XOR<fundraiserCreateWithoutBasecountryInput, fundraiserUncheckedCreateWithoutBasecountryInput> | fundraiserCreateWithoutBasecountryInput[] | fundraiserUncheckedCreateWithoutBasecountryInput[]
    connectOrCreate?: fundraiserCreateOrConnectWithoutBasecountryInput | fundraiserCreateOrConnectWithoutBasecountryInput[]
    createMany?: fundraiserCreateManyBasecountryInputEnvelope
    connect?: fundraiserWhereUniqueInput | fundraiserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type exchangeratesUpdateManyWithoutBasecountryNestedInput = {
    create?: XOR<exchangeratesCreateWithoutBasecountryInput, exchangeratesUncheckedCreateWithoutBasecountryInput> | exchangeratesCreateWithoutBasecountryInput[] | exchangeratesUncheckedCreateWithoutBasecountryInput[]
    connectOrCreate?: exchangeratesCreateOrConnectWithoutBasecountryInput | exchangeratesCreateOrConnectWithoutBasecountryInput[]
    upsert?: exchangeratesUpsertWithWhereUniqueWithoutBasecountryInput | exchangeratesUpsertWithWhereUniqueWithoutBasecountryInput[]
    createMany?: exchangeratesCreateManyBasecountryInputEnvelope
    set?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    disconnect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    delete?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    connect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    update?: exchangeratesUpdateWithWhereUniqueWithoutBasecountryInput | exchangeratesUpdateWithWhereUniqueWithoutBasecountryInput[]
    updateMany?: exchangeratesUpdateManyWithWhereWithoutBasecountryInput | exchangeratesUpdateManyWithWhereWithoutBasecountryInput[]
    deleteMany?: exchangeratesScalarWhereInput | exchangeratesScalarWhereInput[]
  }

  export type fundraiserUpdateManyWithoutBasecountryNestedInput = {
    create?: XOR<fundraiserCreateWithoutBasecountryInput, fundraiserUncheckedCreateWithoutBasecountryInput> | fundraiserCreateWithoutBasecountryInput[] | fundraiserUncheckedCreateWithoutBasecountryInput[]
    connectOrCreate?: fundraiserCreateOrConnectWithoutBasecountryInput | fundraiserCreateOrConnectWithoutBasecountryInput[]
    upsert?: fundraiserUpsertWithWhereUniqueWithoutBasecountryInput | fundraiserUpsertWithWhereUniqueWithoutBasecountryInput[]
    createMany?: fundraiserCreateManyBasecountryInputEnvelope
    set?: fundraiserWhereUniqueInput | fundraiserWhereUniqueInput[]
    disconnect?: fundraiserWhereUniqueInput | fundraiserWhereUniqueInput[]
    delete?: fundraiserWhereUniqueInput | fundraiserWhereUniqueInput[]
    connect?: fundraiserWhereUniqueInput | fundraiserWhereUniqueInput[]
    update?: fundraiserUpdateWithWhereUniqueWithoutBasecountryInput | fundraiserUpdateWithWhereUniqueWithoutBasecountryInput[]
    updateMany?: fundraiserUpdateManyWithWhereWithoutBasecountryInput | fundraiserUpdateManyWithWhereWithoutBasecountryInput[]
    deleteMany?: fundraiserScalarWhereInput | fundraiserScalarWhereInput[]
  }

  export type exchangeratesUncheckedUpdateManyWithoutBasecountryNestedInput = {
    create?: XOR<exchangeratesCreateWithoutBasecountryInput, exchangeratesUncheckedCreateWithoutBasecountryInput> | exchangeratesCreateWithoutBasecountryInput[] | exchangeratesUncheckedCreateWithoutBasecountryInput[]
    connectOrCreate?: exchangeratesCreateOrConnectWithoutBasecountryInput | exchangeratesCreateOrConnectWithoutBasecountryInput[]
    upsert?: exchangeratesUpsertWithWhereUniqueWithoutBasecountryInput | exchangeratesUpsertWithWhereUniqueWithoutBasecountryInput[]
    createMany?: exchangeratesCreateManyBasecountryInputEnvelope
    set?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    disconnect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    delete?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    connect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    update?: exchangeratesUpdateWithWhereUniqueWithoutBasecountryInput | exchangeratesUpdateWithWhereUniqueWithoutBasecountryInput[]
    updateMany?: exchangeratesUpdateManyWithWhereWithoutBasecountryInput | exchangeratesUpdateManyWithWhereWithoutBasecountryInput[]
    deleteMany?: exchangeratesScalarWhereInput | exchangeratesScalarWhereInput[]
  }

  export type fundraiserUncheckedUpdateManyWithoutBasecountryNestedInput = {
    create?: XOR<fundraiserCreateWithoutBasecountryInput, fundraiserUncheckedCreateWithoutBasecountryInput> | fundraiserCreateWithoutBasecountryInput[] | fundraiserUncheckedCreateWithoutBasecountryInput[]
    connectOrCreate?: fundraiserCreateOrConnectWithoutBasecountryInput | fundraiserCreateOrConnectWithoutBasecountryInput[]
    upsert?: fundraiserUpsertWithWhereUniqueWithoutBasecountryInput | fundraiserUpsertWithWhereUniqueWithoutBasecountryInput[]
    createMany?: fundraiserCreateManyBasecountryInputEnvelope
    set?: fundraiserWhereUniqueInput | fundraiserWhereUniqueInput[]
    disconnect?: fundraiserWhereUniqueInput | fundraiserWhereUniqueInput[]
    delete?: fundraiserWhereUniqueInput | fundraiserWhereUniqueInput[]
    connect?: fundraiserWhereUniqueInput | fundraiserWhereUniqueInput[]
    update?: fundraiserUpdateWithWhereUniqueWithoutBasecountryInput | fundraiserUpdateWithWhereUniqueWithoutBasecountryInput[]
    updateMany?: fundraiserUpdateManyWithWhereWithoutBasecountryInput | fundraiserUpdateManyWithWhereWithoutBasecountryInput[]
    deleteMany?: fundraiserScalarWhereInput | fundraiserScalarWhereInput[]
  }

  export type exchangeratesCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<exchangeratesCreateWithoutCurrencyInput, exchangeratesUncheckedCreateWithoutCurrencyInput> | exchangeratesCreateWithoutCurrencyInput[] | exchangeratesUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: exchangeratesCreateOrConnectWithoutCurrencyInput | exchangeratesCreateOrConnectWithoutCurrencyInput[]
    createMany?: exchangeratesCreateManyCurrencyInputEnvelope
    connect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
  }

  export type fundraiser_acceptedcurrenciesCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<fundraiser_acceptedcurrenciesCreateWithoutCurrencyInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutCurrencyInput> | fundraiser_acceptedcurrenciesCreateWithoutCurrencyInput[] | fundraiser_acceptedcurrenciesUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: fundraiser_acceptedcurrenciesCreateOrConnectWithoutCurrencyInput | fundraiser_acceptedcurrenciesCreateOrConnectWithoutCurrencyInput[]
    createMany?: fundraiser_acceptedcurrenciesCreateManyCurrencyInputEnvelope
    connect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
  }

  export type minimumamountCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<minimumamountCreateWithoutCurrencyInput, minimumamountUncheckedCreateWithoutCurrencyInput> | minimumamountCreateWithoutCurrencyInput[] | minimumamountUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: minimumamountCreateOrConnectWithoutCurrencyInput | minimumamountCreateOrConnectWithoutCurrencyInput[]
    createMany?: minimumamountCreateManyCurrencyInputEnvelope
    connect?: minimumamountWhereUniqueInput | minimumamountWhereUniqueInput[]
  }

  export type walletCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<walletCreateWithoutCurrencyInput, walletUncheckedCreateWithoutCurrencyInput> | walletCreateWithoutCurrencyInput[] | walletUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: walletCreateOrConnectWithoutCurrencyInput | walletCreateOrConnectWithoutCurrencyInput[]
    createMany?: walletCreateManyCurrencyInputEnvelope
    connect?: walletWhereUniqueInput | walletWhereUniqueInput[]
  }

  export type exchangeratesUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<exchangeratesCreateWithoutCurrencyInput, exchangeratesUncheckedCreateWithoutCurrencyInput> | exchangeratesCreateWithoutCurrencyInput[] | exchangeratesUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: exchangeratesCreateOrConnectWithoutCurrencyInput | exchangeratesCreateOrConnectWithoutCurrencyInput[]
    createMany?: exchangeratesCreateManyCurrencyInputEnvelope
    connect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
  }

  export type fundraiser_acceptedcurrenciesUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<fundraiser_acceptedcurrenciesCreateWithoutCurrencyInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutCurrencyInput> | fundraiser_acceptedcurrenciesCreateWithoutCurrencyInput[] | fundraiser_acceptedcurrenciesUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: fundraiser_acceptedcurrenciesCreateOrConnectWithoutCurrencyInput | fundraiser_acceptedcurrenciesCreateOrConnectWithoutCurrencyInput[]
    createMany?: fundraiser_acceptedcurrenciesCreateManyCurrencyInputEnvelope
    connect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
  }

  export type minimumamountUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<minimumamountCreateWithoutCurrencyInput, minimumamountUncheckedCreateWithoutCurrencyInput> | minimumamountCreateWithoutCurrencyInput[] | minimumamountUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: minimumamountCreateOrConnectWithoutCurrencyInput | minimumamountCreateOrConnectWithoutCurrencyInput[]
    createMany?: minimumamountCreateManyCurrencyInputEnvelope
    connect?: minimumamountWhereUniqueInput | minimumamountWhereUniqueInput[]
  }

  export type walletUncheckedCreateNestedManyWithoutCurrencyInput = {
    create?: XOR<walletCreateWithoutCurrencyInput, walletUncheckedCreateWithoutCurrencyInput> | walletCreateWithoutCurrencyInput[] | walletUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: walletCreateOrConnectWithoutCurrencyInput | walletCreateOrConnectWithoutCurrencyInput[]
    createMany?: walletCreateManyCurrencyInputEnvelope
    connect?: walletWhereUniqueInput | walletWhereUniqueInput[]
  }

  export type exchangeratesUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<exchangeratesCreateWithoutCurrencyInput, exchangeratesUncheckedCreateWithoutCurrencyInput> | exchangeratesCreateWithoutCurrencyInput[] | exchangeratesUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: exchangeratesCreateOrConnectWithoutCurrencyInput | exchangeratesCreateOrConnectWithoutCurrencyInput[]
    upsert?: exchangeratesUpsertWithWhereUniqueWithoutCurrencyInput | exchangeratesUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: exchangeratesCreateManyCurrencyInputEnvelope
    set?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    disconnect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    delete?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    connect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    update?: exchangeratesUpdateWithWhereUniqueWithoutCurrencyInput | exchangeratesUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: exchangeratesUpdateManyWithWhereWithoutCurrencyInput | exchangeratesUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: exchangeratesScalarWhereInput | exchangeratesScalarWhereInput[]
  }

  export type fundraiser_acceptedcurrenciesUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<fundraiser_acceptedcurrenciesCreateWithoutCurrencyInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutCurrencyInput> | fundraiser_acceptedcurrenciesCreateWithoutCurrencyInput[] | fundraiser_acceptedcurrenciesUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: fundraiser_acceptedcurrenciesCreateOrConnectWithoutCurrencyInput | fundraiser_acceptedcurrenciesCreateOrConnectWithoutCurrencyInput[]
    upsert?: fundraiser_acceptedcurrenciesUpsertWithWhereUniqueWithoutCurrencyInput | fundraiser_acceptedcurrenciesUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: fundraiser_acceptedcurrenciesCreateManyCurrencyInputEnvelope
    set?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    disconnect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    delete?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    connect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    update?: fundraiser_acceptedcurrenciesUpdateWithWhereUniqueWithoutCurrencyInput | fundraiser_acceptedcurrenciesUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: fundraiser_acceptedcurrenciesUpdateManyWithWhereWithoutCurrencyInput | fundraiser_acceptedcurrenciesUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: fundraiser_acceptedcurrenciesScalarWhereInput | fundraiser_acceptedcurrenciesScalarWhereInput[]
  }

  export type minimumamountUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<minimumamountCreateWithoutCurrencyInput, minimumamountUncheckedCreateWithoutCurrencyInput> | minimumamountCreateWithoutCurrencyInput[] | minimumamountUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: minimumamountCreateOrConnectWithoutCurrencyInput | minimumamountCreateOrConnectWithoutCurrencyInput[]
    upsert?: minimumamountUpsertWithWhereUniqueWithoutCurrencyInput | minimumamountUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: minimumamountCreateManyCurrencyInputEnvelope
    set?: minimumamountWhereUniqueInput | minimumamountWhereUniqueInput[]
    disconnect?: minimumamountWhereUniqueInput | minimumamountWhereUniqueInput[]
    delete?: minimumamountWhereUniqueInput | minimumamountWhereUniqueInput[]
    connect?: minimumamountWhereUniqueInput | minimumamountWhereUniqueInput[]
    update?: minimumamountUpdateWithWhereUniqueWithoutCurrencyInput | minimumamountUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: minimumamountUpdateManyWithWhereWithoutCurrencyInput | minimumamountUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: minimumamountScalarWhereInput | minimumamountScalarWhereInput[]
  }

  export type walletUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<walletCreateWithoutCurrencyInput, walletUncheckedCreateWithoutCurrencyInput> | walletCreateWithoutCurrencyInput[] | walletUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: walletCreateOrConnectWithoutCurrencyInput | walletCreateOrConnectWithoutCurrencyInput[]
    upsert?: walletUpsertWithWhereUniqueWithoutCurrencyInput | walletUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: walletCreateManyCurrencyInputEnvelope
    set?: walletWhereUniqueInput | walletWhereUniqueInput[]
    disconnect?: walletWhereUniqueInput | walletWhereUniqueInput[]
    delete?: walletWhereUniqueInput | walletWhereUniqueInput[]
    connect?: walletWhereUniqueInput | walletWhereUniqueInput[]
    update?: walletUpdateWithWhereUniqueWithoutCurrencyInput | walletUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: walletUpdateManyWithWhereWithoutCurrencyInput | walletUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: walletScalarWhereInput | walletScalarWhereInput[]
  }

  export type exchangeratesUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<exchangeratesCreateWithoutCurrencyInput, exchangeratesUncheckedCreateWithoutCurrencyInput> | exchangeratesCreateWithoutCurrencyInput[] | exchangeratesUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: exchangeratesCreateOrConnectWithoutCurrencyInput | exchangeratesCreateOrConnectWithoutCurrencyInput[]
    upsert?: exchangeratesUpsertWithWhereUniqueWithoutCurrencyInput | exchangeratesUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: exchangeratesCreateManyCurrencyInputEnvelope
    set?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    disconnect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    delete?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    connect?: exchangeratesWhereUniqueInput | exchangeratesWhereUniqueInput[]
    update?: exchangeratesUpdateWithWhereUniqueWithoutCurrencyInput | exchangeratesUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: exchangeratesUpdateManyWithWhereWithoutCurrencyInput | exchangeratesUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: exchangeratesScalarWhereInput | exchangeratesScalarWhereInput[]
  }

  export type fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<fundraiser_acceptedcurrenciesCreateWithoutCurrencyInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutCurrencyInput> | fundraiser_acceptedcurrenciesCreateWithoutCurrencyInput[] | fundraiser_acceptedcurrenciesUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: fundraiser_acceptedcurrenciesCreateOrConnectWithoutCurrencyInput | fundraiser_acceptedcurrenciesCreateOrConnectWithoutCurrencyInput[]
    upsert?: fundraiser_acceptedcurrenciesUpsertWithWhereUniqueWithoutCurrencyInput | fundraiser_acceptedcurrenciesUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: fundraiser_acceptedcurrenciesCreateManyCurrencyInputEnvelope
    set?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    disconnect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    delete?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    connect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    update?: fundraiser_acceptedcurrenciesUpdateWithWhereUniqueWithoutCurrencyInput | fundraiser_acceptedcurrenciesUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: fundraiser_acceptedcurrenciesUpdateManyWithWhereWithoutCurrencyInput | fundraiser_acceptedcurrenciesUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: fundraiser_acceptedcurrenciesScalarWhereInput | fundraiser_acceptedcurrenciesScalarWhereInput[]
  }

  export type minimumamountUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<minimumamountCreateWithoutCurrencyInput, minimumamountUncheckedCreateWithoutCurrencyInput> | minimumamountCreateWithoutCurrencyInput[] | minimumamountUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: minimumamountCreateOrConnectWithoutCurrencyInput | minimumamountCreateOrConnectWithoutCurrencyInput[]
    upsert?: minimumamountUpsertWithWhereUniqueWithoutCurrencyInput | minimumamountUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: minimumamountCreateManyCurrencyInputEnvelope
    set?: minimumamountWhereUniqueInput | minimumamountWhereUniqueInput[]
    disconnect?: minimumamountWhereUniqueInput | minimumamountWhereUniqueInput[]
    delete?: minimumamountWhereUniqueInput | minimumamountWhereUniqueInput[]
    connect?: minimumamountWhereUniqueInput | minimumamountWhereUniqueInput[]
    update?: minimumamountUpdateWithWhereUniqueWithoutCurrencyInput | minimumamountUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: minimumamountUpdateManyWithWhereWithoutCurrencyInput | minimumamountUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: minimumamountScalarWhereInput | minimumamountScalarWhereInput[]
  }

  export type walletUncheckedUpdateManyWithoutCurrencyNestedInput = {
    create?: XOR<walletCreateWithoutCurrencyInput, walletUncheckedCreateWithoutCurrencyInput> | walletCreateWithoutCurrencyInput[] | walletUncheckedCreateWithoutCurrencyInput[]
    connectOrCreate?: walletCreateOrConnectWithoutCurrencyInput | walletCreateOrConnectWithoutCurrencyInput[]
    upsert?: walletUpsertWithWhereUniqueWithoutCurrencyInput | walletUpsertWithWhereUniqueWithoutCurrencyInput[]
    createMany?: walletCreateManyCurrencyInputEnvelope
    set?: walletWhereUniqueInput | walletWhereUniqueInput[]
    disconnect?: walletWhereUniqueInput | walletWhereUniqueInput[]
    delete?: walletWhereUniqueInput | walletWhereUniqueInput[]
    connect?: walletWhereUniqueInput | walletWhereUniqueInput[]
    update?: walletUpdateWithWhereUniqueWithoutCurrencyInput | walletUpdateWithWhereUniqueWithoutCurrencyInput[]
    updateMany?: walletUpdateManyWithWhereWithoutCurrencyInput | walletUpdateManyWithWhereWithoutCurrencyInput[]
    deleteMany?: walletScalarWhereInput | walletScalarWhereInput[]
  }

  export type agentCreateNestedOneWithoutCustomerInput = {
    create?: XOR<agentCreateWithoutCustomerInput, agentUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: agentCreateOrConnectWithoutCustomerInput
    connect?: agentWhereUniqueInput
  }

  export type customerauditlogsCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customerauditlogsCreateWithoutCustomerInput, customerauditlogsUncheckedCreateWithoutCustomerInput> | customerauditlogsCreateWithoutCustomerInput[] | customerauditlogsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerauditlogsCreateOrConnectWithoutCustomerInput | customerauditlogsCreateOrConnectWithoutCustomerInput[]
    createMany?: customerauditlogsCreateManyCustomerInputEnvelope
    connect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
  }

  export type manychatCreateNestedManyWithoutCustomerInput = {
    create?: XOR<manychatCreateWithoutCustomerInput, manychatUncheckedCreateWithoutCustomerInput> | manychatCreateWithoutCustomerInput[] | manychatUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: manychatCreateOrConnectWithoutCustomerInput | manychatCreateOrConnectWithoutCustomerInput[]
    createMany?: manychatCreateManyCustomerInputEnvelope
    connect?: manychatWhereUniqueInput | manychatWhereUniqueInput[]
  }

  export type transactionsCreateNestedManyWithoutCustomerInput = {
    create?: XOR<transactionsCreateWithoutCustomerInput, transactionsUncheckedCreateWithoutCustomerInput> | transactionsCreateWithoutCustomerInput[] | transactionsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCustomerInput | transactionsCreateOrConnectWithoutCustomerInput[]
    createMany?: transactionsCreateManyCustomerInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type customerauditlogsUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<customerauditlogsCreateWithoutCustomerInput, customerauditlogsUncheckedCreateWithoutCustomerInput> | customerauditlogsCreateWithoutCustomerInput[] | customerauditlogsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerauditlogsCreateOrConnectWithoutCustomerInput | customerauditlogsCreateOrConnectWithoutCustomerInput[]
    createMany?: customerauditlogsCreateManyCustomerInputEnvelope
    connect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
  }

  export type manychatUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<manychatCreateWithoutCustomerInput, manychatUncheckedCreateWithoutCustomerInput> | manychatCreateWithoutCustomerInput[] | manychatUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: manychatCreateOrConnectWithoutCustomerInput | manychatCreateOrConnectWithoutCustomerInput[]
    createMany?: manychatCreateManyCustomerInputEnvelope
    connect?: manychatWhereUniqueInput | manychatWhereUniqueInput[]
  }

  export type transactionsUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<transactionsCreateWithoutCustomerInput, transactionsUncheckedCreateWithoutCustomerInput> | transactionsCreateWithoutCustomerInput[] | transactionsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCustomerInput | transactionsCreateOrConnectWithoutCustomerInput[]
    createMany?: transactionsCreateManyCustomerInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type agentUpdateOneWithoutCustomerNestedInput = {
    create?: XOR<agentCreateWithoutCustomerInput, agentUncheckedCreateWithoutCustomerInput>
    connectOrCreate?: agentCreateOrConnectWithoutCustomerInput
    upsert?: agentUpsertWithoutCustomerInput
    disconnect?: agentWhereInput | boolean
    delete?: agentWhereInput | boolean
    connect?: agentWhereUniqueInput
    update?: XOR<XOR<agentUpdateToOneWithWhereWithoutCustomerInput, agentUpdateWithoutCustomerInput>, agentUncheckedUpdateWithoutCustomerInput>
  }

  export type customerauditlogsUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customerauditlogsCreateWithoutCustomerInput, customerauditlogsUncheckedCreateWithoutCustomerInput> | customerauditlogsCreateWithoutCustomerInput[] | customerauditlogsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerauditlogsCreateOrConnectWithoutCustomerInput | customerauditlogsCreateOrConnectWithoutCustomerInput[]
    upsert?: customerauditlogsUpsertWithWhereUniqueWithoutCustomerInput | customerauditlogsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customerauditlogsCreateManyCustomerInputEnvelope
    set?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    disconnect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    delete?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    connect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    update?: customerauditlogsUpdateWithWhereUniqueWithoutCustomerInput | customerauditlogsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customerauditlogsUpdateManyWithWhereWithoutCustomerInput | customerauditlogsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customerauditlogsScalarWhereInput | customerauditlogsScalarWhereInput[]
  }

  export type manychatUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<manychatCreateWithoutCustomerInput, manychatUncheckedCreateWithoutCustomerInput> | manychatCreateWithoutCustomerInput[] | manychatUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: manychatCreateOrConnectWithoutCustomerInput | manychatCreateOrConnectWithoutCustomerInput[]
    upsert?: manychatUpsertWithWhereUniqueWithoutCustomerInput | manychatUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: manychatCreateManyCustomerInputEnvelope
    set?: manychatWhereUniqueInput | manychatWhereUniqueInput[]
    disconnect?: manychatWhereUniqueInput | manychatWhereUniqueInput[]
    delete?: manychatWhereUniqueInput | manychatWhereUniqueInput[]
    connect?: manychatWhereUniqueInput | manychatWhereUniqueInput[]
    update?: manychatUpdateWithWhereUniqueWithoutCustomerInput | manychatUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: manychatUpdateManyWithWhereWithoutCustomerInput | manychatUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: manychatScalarWhereInput | manychatScalarWhereInput[]
  }

  export type transactionsUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<transactionsCreateWithoutCustomerInput, transactionsUncheckedCreateWithoutCustomerInput> | transactionsCreateWithoutCustomerInput[] | transactionsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCustomerInput | transactionsCreateOrConnectWithoutCustomerInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutCustomerInput | transactionsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: transactionsCreateManyCustomerInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutCustomerInput | transactionsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutCustomerInput | transactionsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type customerauditlogsUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<customerauditlogsCreateWithoutCustomerInput, customerauditlogsUncheckedCreateWithoutCustomerInput> | customerauditlogsCreateWithoutCustomerInput[] | customerauditlogsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: customerauditlogsCreateOrConnectWithoutCustomerInput | customerauditlogsCreateOrConnectWithoutCustomerInput[]
    upsert?: customerauditlogsUpsertWithWhereUniqueWithoutCustomerInput | customerauditlogsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: customerauditlogsCreateManyCustomerInputEnvelope
    set?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    disconnect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    delete?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    connect?: customerauditlogsWhereUniqueInput | customerauditlogsWhereUniqueInput[]
    update?: customerauditlogsUpdateWithWhereUniqueWithoutCustomerInput | customerauditlogsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: customerauditlogsUpdateManyWithWhereWithoutCustomerInput | customerauditlogsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: customerauditlogsScalarWhereInput | customerauditlogsScalarWhereInput[]
  }

  export type manychatUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<manychatCreateWithoutCustomerInput, manychatUncheckedCreateWithoutCustomerInput> | manychatCreateWithoutCustomerInput[] | manychatUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: manychatCreateOrConnectWithoutCustomerInput | manychatCreateOrConnectWithoutCustomerInput[]
    upsert?: manychatUpsertWithWhereUniqueWithoutCustomerInput | manychatUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: manychatCreateManyCustomerInputEnvelope
    set?: manychatWhereUniqueInput | manychatWhereUniqueInput[]
    disconnect?: manychatWhereUniqueInput | manychatWhereUniqueInput[]
    delete?: manychatWhereUniqueInput | manychatWhereUniqueInput[]
    connect?: manychatWhereUniqueInput | manychatWhereUniqueInput[]
    update?: manychatUpdateWithWhereUniqueWithoutCustomerInput | manychatUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: manychatUpdateManyWithWhereWithoutCustomerInput | manychatUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: manychatScalarWhereInput | manychatScalarWhereInput[]
  }

  export type transactionsUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<transactionsCreateWithoutCustomerInput, transactionsUncheckedCreateWithoutCustomerInput> | transactionsCreateWithoutCustomerInput[] | transactionsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutCustomerInput | transactionsCreateOrConnectWithoutCustomerInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutCustomerInput | transactionsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: transactionsCreateManyCustomerInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutCustomerInput | transactionsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutCustomerInput | transactionsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type agentCreateNestedOneWithoutCustomerauditlogsInput = {
    create?: XOR<agentCreateWithoutCustomerauditlogsInput, agentUncheckedCreateWithoutCustomerauditlogsInput>
    connectOrCreate?: agentCreateOrConnectWithoutCustomerauditlogsInput
    connect?: agentWhereUniqueInput
  }

  export type customerCreateNestedOneWithoutCustomerauditlogsInput = {
    create?: XOR<customerCreateWithoutCustomerauditlogsInput, customerUncheckedCreateWithoutCustomerauditlogsInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomerauditlogsInput
    connect?: customerWhereUniqueInput
  }

  export type Enumcustomerauditlogs_FieldChangedFieldUpdateOperationsInput = {
    set?: $Enums.customerauditlogs_FieldChanged
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type agentUpdateOneRequiredWithoutCustomerauditlogsNestedInput = {
    create?: XOR<agentCreateWithoutCustomerauditlogsInput, agentUncheckedCreateWithoutCustomerauditlogsInput>
    connectOrCreate?: agentCreateOrConnectWithoutCustomerauditlogsInput
    upsert?: agentUpsertWithoutCustomerauditlogsInput
    connect?: agentWhereUniqueInput
    update?: XOR<XOR<agentUpdateToOneWithWhereWithoutCustomerauditlogsInput, agentUpdateWithoutCustomerauditlogsInput>, agentUncheckedUpdateWithoutCustomerauditlogsInput>
  }

  export type customerUpdateOneRequiredWithoutCustomerauditlogsNestedInput = {
    create?: XOR<customerCreateWithoutCustomerauditlogsInput, customerUncheckedCreateWithoutCustomerauditlogsInput>
    connectOrCreate?: customerCreateOrConnectWithoutCustomerauditlogsInput
    upsert?: customerUpsertWithoutCustomerauditlogsInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutCustomerauditlogsInput, customerUpdateWithoutCustomerauditlogsInput>, customerUncheckedUpdateWithoutCustomerauditlogsInput>
  }

  export type basecountryCreateNestedOneWithoutExchangeratesInput = {
    create?: XOR<basecountryCreateWithoutExchangeratesInput, basecountryUncheckedCreateWithoutExchangeratesInput>
    connectOrCreate?: basecountryCreateOrConnectWithoutExchangeratesInput
    connect?: basecountryWhereUniqueInput
  }

  export type currencyCreateNestedOneWithoutExchangeratesInput = {
    create?: XOR<currencyCreateWithoutExchangeratesInput, currencyUncheckedCreateWithoutExchangeratesInput>
    connectOrCreate?: currencyCreateOrConnectWithoutExchangeratesInput
    connect?: currencyWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type basecountryUpdateOneRequiredWithoutExchangeratesNestedInput = {
    create?: XOR<basecountryCreateWithoutExchangeratesInput, basecountryUncheckedCreateWithoutExchangeratesInput>
    connectOrCreate?: basecountryCreateOrConnectWithoutExchangeratesInput
    upsert?: basecountryUpsertWithoutExchangeratesInput
    connect?: basecountryWhereUniqueInput
    update?: XOR<XOR<basecountryUpdateToOneWithWhereWithoutExchangeratesInput, basecountryUpdateWithoutExchangeratesInput>, basecountryUncheckedUpdateWithoutExchangeratesInput>
  }

  export type currencyUpdateOneRequiredWithoutExchangeratesNestedInput = {
    create?: XOR<currencyCreateWithoutExchangeratesInput, currencyUncheckedCreateWithoutExchangeratesInput>
    connectOrCreate?: currencyCreateOrConnectWithoutExchangeratesInput
    upsert?: currencyUpsertWithoutExchangeratesInput
    connect?: currencyWhereUniqueInput
    update?: XOR<XOR<currencyUpdateToOneWithWhereWithoutExchangeratesInput, currencyUpdateWithoutExchangeratesInput>, currencyUncheckedUpdateWithoutExchangeratesInput>
  }

  export type transactionsCreateNestedOneWithoutFormstatusInput = {
    create?: XOR<transactionsCreateWithoutFormstatusInput, transactionsUncheckedCreateWithoutFormstatusInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutFormstatusInput
    connect?: transactionsWhereUniqueInput
  }

  export type transactionstatusCreateNestedOneWithoutFormstatusInput = {
    create?: XOR<transactionstatusCreateWithoutFormstatusInput, transactionstatusUncheckedCreateWithoutFormstatusInput>
    connectOrCreate?: transactionstatusCreateOrConnectWithoutFormstatusInput
    connect?: transactionstatusWhereUniqueInput
  }

  export type transactionsUpdateOneWithoutFormstatusNestedInput = {
    create?: XOR<transactionsCreateWithoutFormstatusInput, transactionsUncheckedCreateWithoutFormstatusInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutFormstatusInput
    upsert?: transactionsUpsertWithoutFormstatusInput
    disconnect?: transactionsWhereInput | boolean
    delete?: transactionsWhereInput | boolean
    connect?: transactionsWhereUniqueInput
    update?: XOR<XOR<transactionsUpdateToOneWithWhereWithoutFormstatusInput, transactionsUpdateWithoutFormstatusInput>, transactionsUncheckedUpdateWithoutFormstatusInput>
  }

  export type transactionstatusUpdateOneWithoutFormstatusNestedInput = {
    create?: XOR<transactionstatusCreateWithoutFormstatusInput, transactionstatusUncheckedCreateWithoutFormstatusInput>
    connectOrCreate?: transactionstatusCreateOrConnectWithoutFormstatusInput
    upsert?: transactionstatusUpsertWithoutFormstatusInput
    disconnect?: transactionstatusWhereInput | boolean
    delete?: transactionstatusWhereInput | boolean
    connect?: transactionstatusWhereUniqueInput
    update?: XOR<XOR<transactionstatusUpdateToOneWithWhereWithoutFormstatusInput, transactionstatusUpdateWithoutFormstatusInput>, transactionstatusUncheckedUpdateWithoutFormstatusInput>
  }

  export type agentCreateNestedOneWithoutFormvisibilitystatusInput = {
    create?: XOR<agentCreateWithoutFormvisibilitystatusInput, agentUncheckedCreateWithoutFormvisibilitystatusInput>
    connectOrCreate?: agentCreateOrConnectWithoutFormvisibilitystatusInput
    connect?: agentWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type agentUpdateOneRequiredWithoutFormvisibilitystatusNestedInput = {
    create?: XOR<agentCreateWithoutFormvisibilitystatusInput, agentUncheckedCreateWithoutFormvisibilitystatusInput>
    connectOrCreate?: agentCreateOrConnectWithoutFormvisibilitystatusInput
    upsert?: agentUpsertWithoutFormvisibilitystatusInput
    connect?: agentWhereUniqueInput
    update?: XOR<XOR<agentUpdateToOneWithWhereWithoutFormvisibilitystatusInput, agentUpdateWithoutFormvisibilitystatusInput>, agentUncheckedUpdateWithoutFormvisibilitystatusInput>
  }

  export type basecountryCreateNestedOneWithoutFundraiserInput = {
    create?: XOR<basecountryCreateWithoutFundraiserInput, basecountryUncheckedCreateWithoutFundraiserInput>
    connectOrCreate?: basecountryCreateOrConnectWithoutFundraiserInput
    connect?: basecountryWhereUniqueInput
  }

  export type fundraiser_acceptedcurrenciesCreateNestedManyWithoutFundraiserInput = {
    create?: XOR<fundraiser_acceptedcurrenciesCreateWithoutFundraiserInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutFundraiserInput> | fundraiser_acceptedcurrenciesCreateWithoutFundraiserInput[] | fundraiser_acceptedcurrenciesUncheckedCreateWithoutFundraiserInput[]
    connectOrCreate?: fundraiser_acceptedcurrenciesCreateOrConnectWithoutFundraiserInput | fundraiser_acceptedcurrenciesCreateOrConnectWithoutFundraiserInput[]
    createMany?: fundraiser_acceptedcurrenciesCreateManyFundraiserInputEnvelope
    connect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
  }

  export type fundraiser_contactlinksCreateNestedManyWithoutFundraiserInput = {
    create?: XOR<fundraiser_contactlinksCreateWithoutFundraiserInput, fundraiser_contactlinksUncheckedCreateWithoutFundraiserInput> | fundraiser_contactlinksCreateWithoutFundraiserInput[] | fundraiser_contactlinksUncheckedCreateWithoutFundraiserInput[]
    connectOrCreate?: fundraiser_contactlinksCreateOrConnectWithoutFundraiserInput | fundraiser_contactlinksCreateOrConnectWithoutFundraiserInput[]
    createMany?: fundraiser_contactlinksCreateManyFundraiserInputEnvelope
    connect?: fundraiser_contactlinksWhereUniqueInput | fundraiser_contactlinksWhereUniqueInput[]
  }

  export type fundraiser_acceptedcurrenciesUncheckedCreateNestedManyWithoutFundraiserInput = {
    create?: XOR<fundraiser_acceptedcurrenciesCreateWithoutFundraiserInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutFundraiserInput> | fundraiser_acceptedcurrenciesCreateWithoutFundraiserInput[] | fundraiser_acceptedcurrenciesUncheckedCreateWithoutFundraiserInput[]
    connectOrCreate?: fundraiser_acceptedcurrenciesCreateOrConnectWithoutFundraiserInput | fundraiser_acceptedcurrenciesCreateOrConnectWithoutFundraiserInput[]
    createMany?: fundraiser_acceptedcurrenciesCreateManyFundraiserInputEnvelope
    connect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
  }

  export type fundraiser_contactlinksUncheckedCreateNestedManyWithoutFundraiserInput = {
    create?: XOR<fundraiser_contactlinksCreateWithoutFundraiserInput, fundraiser_contactlinksUncheckedCreateWithoutFundraiserInput> | fundraiser_contactlinksCreateWithoutFundraiserInput[] | fundraiser_contactlinksUncheckedCreateWithoutFundraiserInput[]
    connectOrCreate?: fundraiser_contactlinksCreateOrConnectWithoutFundraiserInput | fundraiser_contactlinksCreateOrConnectWithoutFundraiserInput[]
    createMany?: fundraiser_contactlinksCreateManyFundraiserInputEnvelope
    connect?: fundraiser_contactlinksWhereUniqueInput | fundraiser_contactlinksWhereUniqueInput[]
  }

  export type basecountryUpdateOneWithoutFundraiserNestedInput = {
    create?: XOR<basecountryCreateWithoutFundraiserInput, basecountryUncheckedCreateWithoutFundraiserInput>
    connectOrCreate?: basecountryCreateOrConnectWithoutFundraiserInput
    upsert?: basecountryUpsertWithoutFundraiserInput
    disconnect?: basecountryWhereInput | boolean
    delete?: basecountryWhereInput | boolean
    connect?: basecountryWhereUniqueInput
    update?: XOR<XOR<basecountryUpdateToOneWithWhereWithoutFundraiserInput, basecountryUpdateWithoutFundraiserInput>, basecountryUncheckedUpdateWithoutFundraiserInput>
  }

  export type fundraiser_acceptedcurrenciesUpdateManyWithoutFundraiserNestedInput = {
    create?: XOR<fundraiser_acceptedcurrenciesCreateWithoutFundraiserInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutFundraiserInput> | fundraiser_acceptedcurrenciesCreateWithoutFundraiserInput[] | fundraiser_acceptedcurrenciesUncheckedCreateWithoutFundraiserInput[]
    connectOrCreate?: fundraiser_acceptedcurrenciesCreateOrConnectWithoutFundraiserInput | fundraiser_acceptedcurrenciesCreateOrConnectWithoutFundraiserInput[]
    upsert?: fundraiser_acceptedcurrenciesUpsertWithWhereUniqueWithoutFundraiserInput | fundraiser_acceptedcurrenciesUpsertWithWhereUniqueWithoutFundraiserInput[]
    createMany?: fundraiser_acceptedcurrenciesCreateManyFundraiserInputEnvelope
    set?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    disconnect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    delete?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    connect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    update?: fundraiser_acceptedcurrenciesUpdateWithWhereUniqueWithoutFundraiserInput | fundraiser_acceptedcurrenciesUpdateWithWhereUniqueWithoutFundraiserInput[]
    updateMany?: fundraiser_acceptedcurrenciesUpdateManyWithWhereWithoutFundraiserInput | fundraiser_acceptedcurrenciesUpdateManyWithWhereWithoutFundraiserInput[]
    deleteMany?: fundraiser_acceptedcurrenciesScalarWhereInput | fundraiser_acceptedcurrenciesScalarWhereInput[]
  }

  export type fundraiser_contactlinksUpdateManyWithoutFundraiserNestedInput = {
    create?: XOR<fundraiser_contactlinksCreateWithoutFundraiserInput, fundraiser_contactlinksUncheckedCreateWithoutFundraiserInput> | fundraiser_contactlinksCreateWithoutFundraiserInput[] | fundraiser_contactlinksUncheckedCreateWithoutFundraiserInput[]
    connectOrCreate?: fundraiser_contactlinksCreateOrConnectWithoutFundraiserInput | fundraiser_contactlinksCreateOrConnectWithoutFundraiserInput[]
    upsert?: fundraiser_contactlinksUpsertWithWhereUniqueWithoutFundraiserInput | fundraiser_contactlinksUpsertWithWhereUniqueWithoutFundraiserInput[]
    createMany?: fundraiser_contactlinksCreateManyFundraiserInputEnvelope
    set?: fundraiser_contactlinksWhereUniqueInput | fundraiser_contactlinksWhereUniqueInput[]
    disconnect?: fundraiser_contactlinksWhereUniqueInput | fundraiser_contactlinksWhereUniqueInput[]
    delete?: fundraiser_contactlinksWhereUniqueInput | fundraiser_contactlinksWhereUniqueInput[]
    connect?: fundraiser_contactlinksWhereUniqueInput | fundraiser_contactlinksWhereUniqueInput[]
    update?: fundraiser_contactlinksUpdateWithWhereUniqueWithoutFundraiserInput | fundraiser_contactlinksUpdateWithWhereUniqueWithoutFundraiserInput[]
    updateMany?: fundraiser_contactlinksUpdateManyWithWhereWithoutFundraiserInput | fundraiser_contactlinksUpdateManyWithWhereWithoutFundraiserInput[]
    deleteMany?: fundraiser_contactlinksScalarWhereInput | fundraiser_contactlinksScalarWhereInput[]
  }

  export type fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutFundraiserNestedInput = {
    create?: XOR<fundraiser_acceptedcurrenciesCreateWithoutFundraiserInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutFundraiserInput> | fundraiser_acceptedcurrenciesCreateWithoutFundraiserInput[] | fundraiser_acceptedcurrenciesUncheckedCreateWithoutFundraiserInput[]
    connectOrCreate?: fundraiser_acceptedcurrenciesCreateOrConnectWithoutFundraiserInput | fundraiser_acceptedcurrenciesCreateOrConnectWithoutFundraiserInput[]
    upsert?: fundraiser_acceptedcurrenciesUpsertWithWhereUniqueWithoutFundraiserInput | fundraiser_acceptedcurrenciesUpsertWithWhereUniqueWithoutFundraiserInput[]
    createMany?: fundraiser_acceptedcurrenciesCreateManyFundraiserInputEnvelope
    set?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    disconnect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    delete?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    connect?: fundraiser_acceptedcurrenciesWhereUniqueInput | fundraiser_acceptedcurrenciesWhereUniqueInput[]
    update?: fundraiser_acceptedcurrenciesUpdateWithWhereUniqueWithoutFundraiserInput | fundraiser_acceptedcurrenciesUpdateWithWhereUniqueWithoutFundraiserInput[]
    updateMany?: fundraiser_acceptedcurrenciesUpdateManyWithWhereWithoutFundraiserInput | fundraiser_acceptedcurrenciesUpdateManyWithWhereWithoutFundraiserInput[]
    deleteMany?: fundraiser_acceptedcurrenciesScalarWhereInput | fundraiser_acceptedcurrenciesScalarWhereInput[]
  }

  export type fundraiser_contactlinksUncheckedUpdateManyWithoutFundraiserNestedInput = {
    create?: XOR<fundraiser_contactlinksCreateWithoutFundraiserInput, fundraiser_contactlinksUncheckedCreateWithoutFundraiserInput> | fundraiser_contactlinksCreateWithoutFundraiserInput[] | fundraiser_contactlinksUncheckedCreateWithoutFundraiserInput[]
    connectOrCreate?: fundraiser_contactlinksCreateOrConnectWithoutFundraiserInput | fundraiser_contactlinksCreateOrConnectWithoutFundraiserInput[]
    upsert?: fundraiser_contactlinksUpsertWithWhereUniqueWithoutFundraiserInput | fundraiser_contactlinksUpsertWithWhereUniqueWithoutFundraiserInput[]
    createMany?: fundraiser_contactlinksCreateManyFundraiserInputEnvelope
    set?: fundraiser_contactlinksWhereUniqueInput | fundraiser_contactlinksWhereUniqueInput[]
    disconnect?: fundraiser_contactlinksWhereUniqueInput | fundraiser_contactlinksWhereUniqueInput[]
    delete?: fundraiser_contactlinksWhereUniqueInput | fundraiser_contactlinksWhereUniqueInput[]
    connect?: fundraiser_contactlinksWhereUniqueInput | fundraiser_contactlinksWhereUniqueInput[]
    update?: fundraiser_contactlinksUpdateWithWhereUniqueWithoutFundraiserInput | fundraiser_contactlinksUpdateWithWhereUniqueWithoutFundraiserInput[]
    updateMany?: fundraiser_contactlinksUpdateManyWithWhereWithoutFundraiserInput | fundraiser_contactlinksUpdateManyWithWhereWithoutFundraiserInput[]
    deleteMany?: fundraiser_contactlinksScalarWhereInput | fundraiser_contactlinksScalarWhereInput[]
  }

  export type fundraiserCreateNestedOneWithoutFundraiser_acceptedcurrenciesInput = {
    create?: XOR<fundraiserCreateWithoutFundraiser_acceptedcurrenciesInput, fundraiserUncheckedCreateWithoutFundraiser_acceptedcurrenciesInput>
    connectOrCreate?: fundraiserCreateOrConnectWithoutFundraiser_acceptedcurrenciesInput
    connect?: fundraiserWhereUniqueInput
  }

  export type currencyCreateNestedOneWithoutFundraiser_acceptedcurrenciesInput = {
    create?: XOR<currencyCreateWithoutFundraiser_acceptedcurrenciesInput, currencyUncheckedCreateWithoutFundraiser_acceptedcurrenciesInput>
    connectOrCreate?: currencyCreateOrConnectWithoutFundraiser_acceptedcurrenciesInput
    connect?: currencyWhereUniqueInput
  }

  export type fundraiserUpdateOneWithoutFundraiser_acceptedcurrenciesNestedInput = {
    create?: XOR<fundraiserCreateWithoutFundraiser_acceptedcurrenciesInput, fundraiserUncheckedCreateWithoutFundraiser_acceptedcurrenciesInput>
    connectOrCreate?: fundraiserCreateOrConnectWithoutFundraiser_acceptedcurrenciesInput
    upsert?: fundraiserUpsertWithoutFundraiser_acceptedcurrenciesInput
    disconnect?: fundraiserWhereInput | boolean
    delete?: fundraiserWhereInput | boolean
    connect?: fundraiserWhereUniqueInput
    update?: XOR<XOR<fundraiserUpdateToOneWithWhereWithoutFundraiser_acceptedcurrenciesInput, fundraiserUpdateWithoutFundraiser_acceptedcurrenciesInput>, fundraiserUncheckedUpdateWithoutFundraiser_acceptedcurrenciesInput>
  }

  export type currencyUpdateOneWithoutFundraiser_acceptedcurrenciesNestedInput = {
    create?: XOR<currencyCreateWithoutFundraiser_acceptedcurrenciesInput, currencyUncheckedCreateWithoutFundraiser_acceptedcurrenciesInput>
    connectOrCreate?: currencyCreateOrConnectWithoutFundraiser_acceptedcurrenciesInput
    upsert?: currencyUpsertWithoutFundraiser_acceptedcurrenciesInput
    disconnect?: currencyWhereInput | boolean
    delete?: currencyWhereInput | boolean
    connect?: currencyWhereUniqueInput
    update?: XOR<XOR<currencyUpdateToOneWithWhereWithoutFundraiser_acceptedcurrenciesInput, currencyUpdateWithoutFundraiser_acceptedcurrenciesInput>, currencyUncheckedUpdateWithoutFundraiser_acceptedcurrenciesInput>
  }

  export type fundraiserCreateNestedOneWithoutFundraiser_contactlinksInput = {
    create?: XOR<fundraiserCreateWithoutFundraiser_contactlinksInput, fundraiserUncheckedCreateWithoutFundraiser_contactlinksInput>
    connectOrCreate?: fundraiserCreateOrConnectWithoutFundraiser_contactlinksInput
    connect?: fundraiserWhereUniqueInput
  }

  export type fundraiserUpdateOneWithoutFundraiser_contactlinksNestedInput = {
    create?: XOR<fundraiserCreateWithoutFundraiser_contactlinksInput, fundraiserUncheckedCreateWithoutFundraiser_contactlinksInput>
    connectOrCreate?: fundraiserCreateOrConnectWithoutFundraiser_contactlinksInput
    upsert?: fundraiserUpsertWithoutFundraiser_contactlinksInput
    disconnect?: fundraiserWhereInput | boolean
    delete?: fundraiserWhereInput | boolean
    connect?: fundraiserWhereUniqueInput
    update?: XOR<XOR<fundraiserUpdateToOneWithWhereWithoutFundraiser_contactlinksInput, fundraiserUpdateWithoutFundraiser_contactlinksInput>, fundraiserUncheckedUpdateWithoutFundraiser_contactlinksInput>
  }

  export type customerCreateNestedOneWithoutManychatInput = {
    create?: XOR<customerCreateWithoutManychatInput, customerUncheckedCreateWithoutManychatInput>
    connectOrCreate?: customerCreateOrConnectWithoutManychatInput
    connect?: customerWhereUniqueInput
  }

  export type customerUpdateOneRequiredWithoutManychatNestedInput = {
    create?: XOR<customerCreateWithoutManychatInput, customerUncheckedCreateWithoutManychatInput>
    connectOrCreate?: customerCreateOrConnectWithoutManychatInput
    upsert?: customerUpsertWithoutManychatInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutManychatInput, customerUpdateWithoutManychatInput>, customerUncheckedUpdateWithoutManychatInput>
  }

  export type currencyCreateNestedOneWithoutMinimumamountInput = {
    create?: XOR<currencyCreateWithoutMinimumamountInput, currencyUncheckedCreateWithoutMinimumamountInput>
    connectOrCreate?: currencyCreateOrConnectWithoutMinimumamountInput
    connect?: currencyWhereUniqueInput
  }

  export type currencyUpdateOneRequiredWithoutMinimumamountNestedInput = {
    create?: XOR<currencyCreateWithoutMinimumamountInput, currencyUncheckedCreateWithoutMinimumamountInput>
    connectOrCreate?: currencyCreateOrConnectWithoutMinimumamountInput
    upsert?: currencyUpsertWithoutMinimumamountInput
    connect?: currencyWhereUniqueInput
    update?: XOR<XOR<currencyUpdateToOneWithWhereWithoutMinimumamountInput, currencyUpdateWithoutMinimumamountInput>, currencyUncheckedUpdateWithoutMinimumamountInput>
  }

  export type agentCreateNestedOneWithoutNoteInput = {
    create?: XOR<agentCreateWithoutNoteInput, agentUncheckedCreateWithoutNoteInput>
    connectOrCreate?: agentCreateOrConnectWithoutNoteInput
    connect?: agentWhereUniqueInput
  }

  export type transactionsCreateNestedManyWithoutNoteInput = {
    create?: XOR<transactionsCreateWithoutNoteInput, transactionsUncheckedCreateWithoutNoteInput> | transactionsCreateWithoutNoteInput[] | transactionsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutNoteInput | transactionsCreateOrConnectWithoutNoteInput[]
    createMany?: transactionsCreateManyNoteInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type transactionsUncheckedCreateNestedManyWithoutNoteInput = {
    create?: XOR<transactionsCreateWithoutNoteInput, transactionsUncheckedCreateWithoutNoteInput> | transactionsCreateWithoutNoteInput[] | transactionsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutNoteInput | transactionsCreateOrConnectWithoutNoteInput[]
    createMany?: transactionsCreateManyNoteInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type agentUpdateOneWithoutNoteNestedInput = {
    create?: XOR<agentCreateWithoutNoteInput, agentUncheckedCreateWithoutNoteInput>
    connectOrCreate?: agentCreateOrConnectWithoutNoteInput
    upsert?: agentUpsertWithoutNoteInput
    disconnect?: agentWhereInput | boolean
    delete?: agentWhereInput | boolean
    connect?: agentWhereUniqueInput
    update?: XOR<XOR<agentUpdateToOneWithWhereWithoutNoteInput, agentUpdateWithoutNoteInput>, agentUncheckedUpdateWithoutNoteInput>
  }

  export type transactionsUpdateManyWithoutNoteNestedInput = {
    create?: XOR<transactionsCreateWithoutNoteInput, transactionsUncheckedCreateWithoutNoteInput> | transactionsCreateWithoutNoteInput[] | transactionsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutNoteInput | transactionsCreateOrConnectWithoutNoteInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutNoteInput | transactionsUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: transactionsCreateManyNoteInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutNoteInput | transactionsUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutNoteInput | transactionsUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type transactionsUncheckedUpdateManyWithoutNoteNestedInput = {
    create?: XOR<transactionsCreateWithoutNoteInput, transactionsUncheckedCreateWithoutNoteInput> | transactionsCreateWithoutNoteInput[] | transactionsUncheckedCreateWithoutNoteInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutNoteInput | transactionsCreateOrConnectWithoutNoteInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutNoteInput | transactionsUpsertWithWhereUniqueWithoutNoteInput[]
    createMany?: transactionsCreateManyNoteInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutNoteInput | transactionsUpdateWithWhereUniqueWithoutNoteInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutNoteInput | transactionsUpdateManyWithWhereWithoutNoteInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type transactionsCreateNestedOneWithoutScreenshotInput = {
    create?: XOR<transactionsCreateWithoutScreenshotInput, transactionsUncheckedCreateWithoutScreenshotInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutScreenshotInput
    connect?: transactionsWhereUniqueInput
  }

  export type transactionsUpdateOneWithoutScreenshotNestedInput = {
    create?: XOR<transactionsCreateWithoutScreenshotInput, transactionsUncheckedCreateWithoutScreenshotInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutScreenshotInput
    upsert?: transactionsUpsertWithoutScreenshotInput
    disconnect?: transactionsWhereInput | boolean
    delete?: transactionsWhereInput | boolean
    connect?: transactionsWhereUniqueInput
    update?: XOR<XOR<transactionsUpdateToOneWithWhereWithoutScreenshotInput, transactionsUpdateWithoutScreenshotInput>, transactionsUncheckedUpdateWithoutScreenshotInput>
  }

  export type transactionsCreateNestedManyWithoutSupportregionInput = {
    create?: XOR<transactionsCreateWithoutSupportregionInput, transactionsUncheckedCreateWithoutSupportregionInput> | transactionsCreateWithoutSupportregionInput[] | transactionsUncheckedCreateWithoutSupportregionInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutSupportregionInput | transactionsCreateOrConnectWithoutSupportregionInput[]
    createMany?: transactionsCreateManySupportregionInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type transactionsUncheckedCreateNestedManyWithoutSupportregionInput = {
    create?: XOR<transactionsCreateWithoutSupportregionInput, transactionsUncheckedCreateWithoutSupportregionInput> | transactionsCreateWithoutSupportregionInput[] | transactionsUncheckedCreateWithoutSupportregionInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutSupportregionInput | transactionsCreateOrConnectWithoutSupportregionInput[]
    createMany?: transactionsCreateManySupportregionInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type transactionsUpdateManyWithoutSupportregionNestedInput = {
    create?: XOR<transactionsCreateWithoutSupportregionInput, transactionsUncheckedCreateWithoutSupportregionInput> | transactionsCreateWithoutSupportregionInput[] | transactionsUncheckedCreateWithoutSupportregionInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutSupportregionInput | transactionsCreateOrConnectWithoutSupportregionInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutSupportregionInput | transactionsUpsertWithWhereUniqueWithoutSupportregionInput[]
    createMany?: transactionsCreateManySupportregionInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutSupportregionInput | transactionsUpdateWithWhereUniqueWithoutSupportregionInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutSupportregionInput | transactionsUpdateManyWithWhereWithoutSupportregionInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type transactionsUncheckedUpdateManyWithoutSupportregionNestedInput = {
    create?: XOR<transactionsCreateWithoutSupportregionInput, transactionsUncheckedCreateWithoutSupportregionInput> | transactionsCreateWithoutSupportregionInput[] | transactionsUncheckedCreateWithoutSupportregionInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutSupportregionInput | transactionsCreateOrConnectWithoutSupportregionInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutSupportregionInput | transactionsUpsertWithWhereUniqueWithoutSupportregionInput[]
    createMany?: transactionsCreateManySupportregionInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutSupportregionInput | transactionsUpdateWithWhereUniqueWithoutSupportregionInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutSupportregionInput | transactionsUpdateManyWithWhereWithoutSupportregionInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type transactionsCreateNestedOneWithoutTransactionagentInput = {
    create?: XOR<transactionsCreateWithoutTransactionagentInput, transactionsUncheckedCreateWithoutTransactionagentInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutTransactionagentInput
    connect?: transactionsWhereUniqueInput
  }

  export type agentCreateNestedOneWithoutTransactionagentInput = {
    create?: XOR<agentCreateWithoutTransactionagentInput, agentUncheckedCreateWithoutTransactionagentInput>
    connectOrCreate?: agentCreateOrConnectWithoutTransactionagentInput
    connect?: agentWhereUniqueInput
  }

  export type transactionsUpdateOneWithoutTransactionagentNestedInput = {
    create?: XOR<transactionsCreateWithoutTransactionagentInput, transactionsUncheckedCreateWithoutTransactionagentInput>
    connectOrCreate?: transactionsCreateOrConnectWithoutTransactionagentInput
    upsert?: transactionsUpsertWithoutTransactionagentInput
    disconnect?: transactionsWhereInput | boolean
    delete?: transactionsWhereInput | boolean
    connect?: transactionsWhereUniqueInput
    update?: XOR<XOR<transactionsUpdateToOneWithWhereWithoutTransactionagentInput, transactionsUpdateWithoutTransactionagentInput>, transactionsUncheckedUpdateWithoutTransactionagentInput>
  }

  export type agentUpdateOneWithoutTransactionagentNestedInput = {
    create?: XOR<agentCreateWithoutTransactionagentInput, agentUncheckedCreateWithoutTransactionagentInput>
    connectOrCreate?: agentCreateOrConnectWithoutTransactionagentInput
    upsert?: agentUpsertWithoutTransactionagentInput
    disconnect?: agentWhereInput | boolean
    delete?: agentWhereInput | boolean
    connect?: agentWhereUniqueInput
    update?: XOR<XOR<agentUpdateToOneWithWhereWithoutTransactionagentInput, agentUpdateWithoutTransactionagentInput>, agentUncheckedUpdateWithoutTransactionagentInput>
  }

  export type formstatusCreateNestedManyWithoutTransactionsInput = {
    create?: XOR<formstatusCreateWithoutTransactionsInput, formstatusUncheckedCreateWithoutTransactionsInput> | formstatusCreateWithoutTransactionsInput[] | formstatusUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: formstatusCreateOrConnectWithoutTransactionsInput | formstatusCreateOrConnectWithoutTransactionsInput[]
    createMany?: formstatusCreateManyTransactionsInputEnvelope
    connect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
  }

  export type screenshotCreateNestedManyWithoutTransactionsInput = {
    create?: XOR<screenshotCreateWithoutTransactionsInput, screenshotUncheckedCreateWithoutTransactionsInput> | screenshotCreateWithoutTransactionsInput[] | screenshotUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: screenshotCreateOrConnectWithoutTransactionsInput | screenshotCreateOrConnectWithoutTransactionsInput[]
    createMany?: screenshotCreateManyTransactionsInputEnvelope
    connect?: screenshotWhereUniqueInput | screenshotWhereUniqueInput[]
  }

  export type transactionagentCreateNestedManyWithoutTransactionsInput = {
    create?: XOR<transactionagentCreateWithoutTransactionsInput, transactionagentUncheckedCreateWithoutTransactionsInput> | transactionagentCreateWithoutTransactionsInput[] | transactionagentUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: transactionagentCreateOrConnectWithoutTransactionsInput | transactionagentCreateOrConnectWithoutTransactionsInput[]
    createMany?: transactionagentCreateManyTransactionsInputEnvelope
    connect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
  }

  export type customerCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<customerCreateWithoutTransactionsInput, customerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: customerCreateOrConnectWithoutTransactionsInput
    connect?: customerWhereUniqueInput
  }

  export type supportregionCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<supportregionCreateWithoutTransactionsInput, supportregionUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: supportregionCreateOrConnectWithoutTransactionsInput
    connect?: supportregionWhereUniqueInput
  }

  export type walletCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<walletCreateWithoutTransactionsInput, walletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: walletCreateOrConnectWithoutTransactionsInput
    connect?: walletWhereUniqueInput
  }

  export type noteCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<noteCreateWithoutTransactionsInput, noteUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: noteCreateOrConnectWithoutTransactionsInput
    connect?: noteWhereUniqueInput
  }

  export type formstatusUncheckedCreateNestedManyWithoutTransactionsInput = {
    create?: XOR<formstatusCreateWithoutTransactionsInput, formstatusUncheckedCreateWithoutTransactionsInput> | formstatusCreateWithoutTransactionsInput[] | formstatusUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: formstatusCreateOrConnectWithoutTransactionsInput | formstatusCreateOrConnectWithoutTransactionsInput[]
    createMany?: formstatusCreateManyTransactionsInputEnvelope
    connect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
  }

  export type screenshotUncheckedCreateNestedManyWithoutTransactionsInput = {
    create?: XOR<screenshotCreateWithoutTransactionsInput, screenshotUncheckedCreateWithoutTransactionsInput> | screenshotCreateWithoutTransactionsInput[] | screenshotUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: screenshotCreateOrConnectWithoutTransactionsInput | screenshotCreateOrConnectWithoutTransactionsInput[]
    createMany?: screenshotCreateManyTransactionsInputEnvelope
    connect?: screenshotWhereUniqueInput | screenshotWhereUniqueInput[]
  }

  export type transactionagentUncheckedCreateNestedManyWithoutTransactionsInput = {
    create?: XOR<transactionagentCreateWithoutTransactionsInput, transactionagentUncheckedCreateWithoutTransactionsInput> | transactionagentCreateWithoutTransactionsInput[] | transactionagentUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: transactionagentCreateOrConnectWithoutTransactionsInput | transactionagentCreateOrConnectWithoutTransactionsInput[]
    createMany?: transactionagentCreateManyTransactionsInputEnvelope
    connect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type formstatusUpdateManyWithoutTransactionsNestedInput = {
    create?: XOR<formstatusCreateWithoutTransactionsInput, formstatusUncheckedCreateWithoutTransactionsInput> | formstatusCreateWithoutTransactionsInput[] | formstatusUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: formstatusCreateOrConnectWithoutTransactionsInput | formstatusCreateOrConnectWithoutTransactionsInput[]
    upsert?: formstatusUpsertWithWhereUniqueWithoutTransactionsInput | formstatusUpsertWithWhereUniqueWithoutTransactionsInput[]
    createMany?: formstatusCreateManyTransactionsInputEnvelope
    set?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    disconnect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    delete?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    connect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    update?: formstatusUpdateWithWhereUniqueWithoutTransactionsInput | formstatusUpdateWithWhereUniqueWithoutTransactionsInput[]
    updateMany?: formstatusUpdateManyWithWhereWithoutTransactionsInput | formstatusUpdateManyWithWhereWithoutTransactionsInput[]
    deleteMany?: formstatusScalarWhereInput | formstatusScalarWhereInput[]
  }

  export type screenshotUpdateManyWithoutTransactionsNestedInput = {
    create?: XOR<screenshotCreateWithoutTransactionsInput, screenshotUncheckedCreateWithoutTransactionsInput> | screenshotCreateWithoutTransactionsInput[] | screenshotUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: screenshotCreateOrConnectWithoutTransactionsInput | screenshotCreateOrConnectWithoutTransactionsInput[]
    upsert?: screenshotUpsertWithWhereUniqueWithoutTransactionsInput | screenshotUpsertWithWhereUniqueWithoutTransactionsInput[]
    createMany?: screenshotCreateManyTransactionsInputEnvelope
    set?: screenshotWhereUniqueInput | screenshotWhereUniqueInput[]
    disconnect?: screenshotWhereUniqueInput | screenshotWhereUniqueInput[]
    delete?: screenshotWhereUniqueInput | screenshotWhereUniqueInput[]
    connect?: screenshotWhereUniqueInput | screenshotWhereUniqueInput[]
    update?: screenshotUpdateWithWhereUniqueWithoutTransactionsInput | screenshotUpdateWithWhereUniqueWithoutTransactionsInput[]
    updateMany?: screenshotUpdateManyWithWhereWithoutTransactionsInput | screenshotUpdateManyWithWhereWithoutTransactionsInput[]
    deleteMany?: screenshotScalarWhereInput | screenshotScalarWhereInput[]
  }

  export type transactionagentUpdateManyWithoutTransactionsNestedInput = {
    create?: XOR<transactionagentCreateWithoutTransactionsInput, transactionagentUncheckedCreateWithoutTransactionsInput> | transactionagentCreateWithoutTransactionsInput[] | transactionagentUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: transactionagentCreateOrConnectWithoutTransactionsInput | transactionagentCreateOrConnectWithoutTransactionsInput[]
    upsert?: transactionagentUpsertWithWhereUniqueWithoutTransactionsInput | transactionagentUpsertWithWhereUniqueWithoutTransactionsInput[]
    createMany?: transactionagentCreateManyTransactionsInputEnvelope
    set?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    disconnect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    delete?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    connect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    update?: transactionagentUpdateWithWhereUniqueWithoutTransactionsInput | transactionagentUpdateWithWhereUniqueWithoutTransactionsInput[]
    updateMany?: transactionagentUpdateManyWithWhereWithoutTransactionsInput | transactionagentUpdateManyWithWhereWithoutTransactionsInput[]
    deleteMany?: transactionagentScalarWhereInput | transactionagentScalarWhereInput[]
  }

  export type customerUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<customerCreateWithoutTransactionsInput, customerUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: customerCreateOrConnectWithoutTransactionsInput
    upsert?: customerUpsertWithoutTransactionsInput
    disconnect?: customerWhereInput | boolean
    delete?: customerWhereInput | boolean
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutTransactionsInput, customerUpdateWithoutTransactionsInput>, customerUncheckedUpdateWithoutTransactionsInput>
  }

  export type supportregionUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<supportregionCreateWithoutTransactionsInput, supportregionUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: supportregionCreateOrConnectWithoutTransactionsInput
    upsert?: supportregionUpsertWithoutTransactionsInput
    disconnect?: supportregionWhereInput | boolean
    delete?: supportregionWhereInput | boolean
    connect?: supportregionWhereUniqueInput
    update?: XOR<XOR<supportregionUpdateToOneWithWhereWithoutTransactionsInput, supportregionUpdateWithoutTransactionsInput>, supportregionUncheckedUpdateWithoutTransactionsInput>
  }

  export type walletUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<walletCreateWithoutTransactionsInput, walletUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: walletCreateOrConnectWithoutTransactionsInput
    upsert?: walletUpsertWithoutTransactionsInput
    disconnect?: walletWhereInput | boolean
    delete?: walletWhereInput | boolean
    connect?: walletWhereUniqueInput
    update?: XOR<XOR<walletUpdateToOneWithWhereWithoutTransactionsInput, walletUpdateWithoutTransactionsInput>, walletUncheckedUpdateWithoutTransactionsInput>
  }

  export type noteUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<noteCreateWithoutTransactionsInput, noteUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: noteCreateOrConnectWithoutTransactionsInput
    upsert?: noteUpsertWithoutTransactionsInput
    disconnect?: noteWhereInput | boolean
    delete?: noteWhereInput | boolean
    connect?: noteWhereUniqueInput
    update?: XOR<XOR<noteUpdateToOneWithWhereWithoutTransactionsInput, noteUpdateWithoutTransactionsInput>, noteUncheckedUpdateWithoutTransactionsInput>
  }

  export type formstatusUncheckedUpdateManyWithoutTransactionsNestedInput = {
    create?: XOR<formstatusCreateWithoutTransactionsInput, formstatusUncheckedCreateWithoutTransactionsInput> | formstatusCreateWithoutTransactionsInput[] | formstatusUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: formstatusCreateOrConnectWithoutTransactionsInput | formstatusCreateOrConnectWithoutTransactionsInput[]
    upsert?: formstatusUpsertWithWhereUniqueWithoutTransactionsInput | formstatusUpsertWithWhereUniqueWithoutTransactionsInput[]
    createMany?: formstatusCreateManyTransactionsInputEnvelope
    set?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    disconnect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    delete?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    connect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    update?: formstatusUpdateWithWhereUniqueWithoutTransactionsInput | formstatusUpdateWithWhereUniqueWithoutTransactionsInput[]
    updateMany?: formstatusUpdateManyWithWhereWithoutTransactionsInput | formstatusUpdateManyWithWhereWithoutTransactionsInput[]
    deleteMany?: formstatusScalarWhereInput | formstatusScalarWhereInput[]
  }

  export type screenshotUncheckedUpdateManyWithoutTransactionsNestedInput = {
    create?: XOR<screenshotCreateWithoutTransactionsInput, screenshotUncheckedCreateWithoutTransactionsInput> | screenshotCreateWithoutTransactionsInput[] | screenshotUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: screenshotCreateOrConnectWithoutTransactionsInput | screenshotCreateOrConnectWithoutTransactionsInput[]
    upsert?: screenshotUpsertWithWhereUniqueWithoutTransactionsInput | screenshotUpsertWithWhereUniqueWithoutTransactionsInput[]
    createMany?: screenshotCreateManyTransactionsInputEnvelope
    set?: screenshotWhereUniqueInput | screenshotWhereUniqueInput[]
    disconnect?: screenshotWhereUniqueInput | screenshotWhereUniqueInput[]
    delete?: screenshotWhereUniqueInput | screenshotWhereUniqueInput[]
    connect?: screenshotWhereUniqueInput | screenshotWhereUniqueInput[]
    update?: screenshotUpdateWithWhereUniqueWithoutTransactionsInput | screenshotUpdateWithWhereUniqueWithoutTransactionsInput[]
    updateMany?: screenshotUpdateManyWithWhereWithoutTransactionsInput | screenshotUpdateManyWithWhereWithoutTransactionsInput[]
    deleteMany?: screenshotScalarWhereInput | screenshotScalarWhereInput[]
  }

  export type transactionagentUncheckedUpdateManyWithoutTransactionsNestedInput = {
    create?: XOR<transactionagentCreateWithoutTransactionsInput, transactionagentUncheckedCreateWithoutTransactionsInput> | transactionagentCreateWithoutTransactionsInput[] | transactionagentUncheckedCreateWithoutTransactionsInput[]
    connectOrCreate?: transactionagentCreateOrConnectWithoutTransactionsInput | transactionagentCreateOrConnectWithoutTransactionsInput[]
    upsert?: transactionagentUpsertWithWhereUniqueWithoutTransactionsInput | transactionagentUpsertWithWhereUniqueWithoutTransactionsInput[]
    createMany?: transactionagentCreateManyTransactionsInputEnvelope
    set?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    disconnect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    delete?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    connect?: transactionagentWhereUniqueInput | transactionagentWhereUniqueInput[]
    update?: transactionagentUpdateWithWhereUniqueWithoutTransactionsInput | transactionagentUpdateWithWhereUniqueWithoutTransactionsInput[]
    updateMany?: transactionagentUpdateManyWithWhereWithoutTransactionsInput | transactionagentUpdateManyWithWhereWithoutTransactionsInput[]
    deleteMany?: transactionagentScalarWhereInput | transactionagentScalarWhereInput[]
  }

  export type formstatusCreateNestedManyWithoutTransactionstatusInput = {
    create?: XOR<formstatusCreateWithoutTransactionstatusInput, formstatusUncheckedCreateWithoutTransactionstatusInput> | formstatusCreateWithoutTransactionstatusInput[] | formstatusUncheckedCreateWithoutTransactionstatusInput[]
    connectOrCreate?: formstatusCreateOrConnectWithoutTransactionstatusInput | formstatusCreateOrConnectWithoutTransactionstatusInput[]
    createMany?: formstatusCreateManyTransactionstatusInputEnvelope
    connect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
  }

  export type formstatusUncheckedCreateNestedManyWithoutTransactionstatusInput = {
    create?: XOR<formstatusCreateWithoutTransactionstatusInput, formstatusUncheckedCreateWithoutTransactionstatusInput> | formstatusCreateWithoutTransactionstatusInput[] | formstatusUncheckedCreateWithoutTransactionstatusInput[]
    connectOrCreate?: formstatusCreateOrConnectWithoutTransactionstatusInput | formstatusCreateOrConnectWithoutTransactionstatusInput[]
    createMany?: formstatusCreateManyTransactionstatusInputEnvelope
    connect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
  }

  export type formstatusUpdateManyWithoutTransactionstatusNestedInput = {
    create?: XOR<formstatusCreateWithoutTransactionstatusInput, formstatusUncheckedCreateWithoutTransactionstatusInput> | formstatusCreateWithoutTransactionstatusInput[] | formstatusUncheckedCreateWithoutTransactionstatusInput[]
    connectOrCreate?: formstatusCreateOrConnectWithoutTransactionstatusInput | formstatusCreateOrConnectWithoutTransactionstatusInput[]
    upsert?: formstatusUpsertWithWhereUniqueWithoutTransactionstatusInput | formstatusUpsertWithWhereUniqueWithoutTransactionstatusInput[]
    createMany?: formstatusCreateManyTransactionstatusInputEnvelope
    set?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    disconnect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    delete?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    connect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    update?: formstatusUpdateWithWhereUniqueWithoutTransactionstatusInput | formstatusUpdateWithWhereUniqueWithoutTransactionstatusInput[]
    updateMany?: formstatusUpdateManyWithWhereWithoutTransactionstatusInput | formstatusUpdateManyWithWhereWithoutTransactionstatusInput[]
    deleteMany?: formstatusScalarWhereInput | formstatusScalarWhereInput[]
  }

  export type formstatusUncheckedUpdateManyWithoutTransactionstatusNestedInput = {
    create?: XOR<formstatusCreateWithoutTransactionstatusInput, formstatusUncheckedCreateWithoutTransactionstatusInput> | formstatusCreateWithoutTransactionstatusInput[] | formstatusUncheckedCreateWithoutTransactionstatusInput[]
    connectOrCreate?: formstatusCreateOrConnectWithoutTransactionstatusInput | formstatusCreateOrConnectWithoutTransactionstatusInput[]
    upsert?: formstatusUpsertWithWhereUniqueWithoutTransactionstatusInput | formstatusUpsertWithWhereUniqueWithoutTransactionstatusInput[]
    createMany?: formstatusCreateManyTransactionstatusInputEnvelope
    set?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    disconnect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    delete?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    connect?: formstatusWhereUniqueInput | formstatusWhereUniqueInput[]
    update?: formstatusUpdateWithWhereUniqueWithoutTransactionstatusInput | formstatusUpdateWithWhereUniqueWithoutTransactionstatusInput[]
    updateMany?: formstatusUpdateManyWithWhereWithoutTransactionstatusInput | formstatusUpdateManyWithWhereWithoutTransactionstatusInput[]
    deleteMany?: formstatusScalarWhereInput | formstatusScalarWhereInput[]
  }

  export type agentCreateNestedManyWithoutUserroleInput = {
    create?: XOR<agentCreateWithoutUserroleInput, agentUncheckedCreateWithoutUserroleInput> | agentCreateWithoutUserroleInput[] | agentUncheckedCreateWithoutUserroleInput[]
    connectOrCreate?: agentCreateOrConnectWithoutUserroleInput | agentCreateOrConnectWithoutUserroleInput[]
    createMany?: agentCreateManyUserroleInputEnvelope
    connect?: agentWhereUniqueInput | agentWhereUniqueInput[]
  }

  export type agentUncheckedCreateNestedManyWithoutUserroleInput = {
    create?: XOR<agentCreateWithoutUserroleInput, agentUncheckedCreateWithoutUserroleInput> | agentCreateWithoutUserroleInput[] | agentUncheckedCreateWithoutUserroleInput[]
    connectOrCreate?: agentCreateOrConnectWithoutUserroleInput | agentCreateOrConnectWithoutUserroleInput[]
    createMany?: agentCreateManyUserroleInputEnvelope
    connect?: agentWhereUniqueInput | agentWhereUniqueInput[]
  }

  export type agentUpdateManyWithoutUserroleNestedInput = {
    create?: XOR<agentCreateWithoutUserroleInput, agentUncheckedCreateWithoutUserroleInput> | agentCreateWithoutUserroleInput[] | agentUncheckedCreateWithoutUserroleInput[]
    connectOrCreate?: agentCreateOrConnectWithoutUserroleInput | agentCreateOrConnectWithoutUserroleInput[]
    upsert?: agentUpsertWithWhereUniqueWithoutUserroleInput | agentUpsertWithWhereUniqueWithoutUserroleInput[]
    createMany?: agentCreateManyUserroleInputEnvelope
    set?: agentWhereUniqueInput | agentWhereUniqueInput[]
    disconnect?: agentWhereUniqueInput | agentWhereUniqueInput[]
    delete?: agentWhereUniqueInput | agentWhereUniqueInput[]
    connect?: agentWhereUniqueInput | agentWhereUniqueInput[]
    update?: agentUpdateWithWhereUniqueWithoutUserroleInput | agentUpdateWithWhereUniqueWithoutUserroleInput[]
    updateMany?: agentUpdateManyWithWhereWithoutUserroleInput | agentUpdateManyWithWhereWithoutUserroleInput[]
    deleteMany?: agentScalarWhereInput | agentScalarWhereInput[]
  }

  export type agentUncheckedUpdateManyWithoutUserroleNestedInput = {
    create?: XOR<agentCreateWithoutUserroleInput, agentUncheckedCreateWithoutUserroleInput> | agentCreateWithoutUserroleInput[] | agentUncheckedCreateWithoutUserroleInput[]
    connectOrCreate?: agentCreateOrConnectWithoutUserroleInput | agentCreateOrConnectWithoutUserroleInput[]
    upsert?: agentUpsertWithWhereUniqueWithoutUserroleInput | agentUpsertWithWhereUniqueWithoutUserroleInput[]
    createMany?: agentCreateManyUserroleInputEnvelope
    set?: agentWhereUniqueInput | agentWhereUniqueInput[]
    disconnect?: agentWhereUniqueInput | agentWhereUniqueInput[]
    delete?: agentWhereUniqueInput | agentWhereUniqueInput[]
    connect?: agentWhereUniqueInput | agentWhereUniqueInput[]
    update?: agentUpdateWithWhereUniqueWithoutUserroleInput | agentUpdateWithWhereUniqueWithoutUserroleInput[]
    updateMany?: agentUpdateManyWithWhereWithoutUserroleInput | agentUpdateManyWithWhereWithoutUserroleInput[]
    deleteMany?: agentScalarWhereInput | agentScalarWhereInput[]
  }

  export type transactionsCreateNestedManyWithoutWalletInput = {
    create?: XOR<transactionsCreateWithoutWalletInput, transactionsUncheckedCreateWithoutWalletInput> | transactionsCreateWithoutWalletInput[] | transactionsUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutWalletInput | transactionsCreateOrConnectWithoutWalletInput[]
    createMany?: transactionsCreateManyWalletInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type currencyCreateNestedOneWithoutWalletInput = {
    create?: XOR<currencyCreateWithoutWalletInput, currencyUncheckedCreateWithoutWalletInput>
    connectOrCreate?: currencyCreateOrConnectWithoutWalletInput
    connect?: currencyWhereUniqueInput
  }

  export type transactionsUncheckedCreateNestedManyWithoutWalletInput = {
    create?: XOR<transactionsCreateWithoutWalletInput, transactionsUncheckedCreateWithoutWalletInput> | transactionsCreateWithoutWalletInput[] | transactionsUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutWalletInput | transactionsCreateOrConnectWithoutWalletInput[]
    createMany?: transactionsCreateManyWalletInputEnvelope
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
  }

  export type transactionsUpdateManyWithoutWalletNestedInput = {
    create?: XOR<transactionsCreateWithoutWalletInput, transactionsUncheckedCreateWithoutWalletInput> | transactionsCreateWithoutWalletInput[] | transactionsUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutWalletInput | transactionsCreateOrConnectWithoutWalletInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutWalletInput | transactionsUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: transactionsCreateManyWalletInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutWalletInput | transactionsUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutWalletInput | transactionsUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type currencyUpdateOneWithoutWalletNestedInput = {
    create?: XOR<currencyCreateWithoutWalletInput, currencyUncheckedCreateWithoutWalletInput>
    connectOrCreate?: currencyCreateOrConnectWithoutWalletInput
    upsert?: currencyUpsertWithoutWalletInput
    disconnect?: currencyWhereInput | boolean
    delete?: currencyWhereInput | boolean
    connect?: currencyWhereUniqueInput
    update?: XOR<XOR<currencyUpdateToOneWithWhereWithoutWalletInput, currencyUpdateWithoutWalletInput>, currencyUncheckedUpdateWithoutWalletInput>
  }

  export type transactionsUncheckedUpdateManyWithoutWalletNestedInput = {
    create?: XOR<transactionsCreateWithoutWalletInput, transactionsUncheckedCreateWithoutWalletInput> | transactionsCreateWithoutWalletInput[] | transactionsUncheckedCreateWithoutWalletInput[]
    connectOrCreate?: transactionsCreateOrConnectWithoutWalletInput | transactionsCreateOrConnectWithoutWalletInput[]
    upsert?: transactionsUpsertWithWhereUniqueWithoutWalletInput | transactionsUpsertWithWhereUniqueWithoutWalletInput[]
    createMany?: transactionsCreateManyWalletInputEnvelope
    set?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    disconnect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    delete?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    connect?: transactionsWhereUniqueInput | transactionsWhereUniqueInput[]
    update?: transactionsUpdateWithWhereUniqueWithoutWalletInput | transactionsUpdateWithWhereUniqueWithoutWalletInput[]
    updateMany?: transactionsUpdateManyWithWhereWithoutWalletInput | transactionsUpdateManyWithWhereWithoutWalletInput[]
    deleteMany?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumcustomerauditlogs_FieldChangedFilter<$PrismaModel = never> = {
    equals?: $Enums.customerauditlogs_FieldChanged | Enumcustomerauditlogs_FieldChangedFieldRefInput<$PrismaModel>
    in?: $Enums.customerauditlogs_FieldChanged[]
    notIn?: $Enums.customerauditlogs_FieldChanged[]
    not?: NestedEnumcustomerauditlogs_FieldChangedFilter<$PrismaModel> | $Enums.customerauditlogs_FieldChanged
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumcustomerauditlogs_FieldChangedWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.customerauditlogs_FieldChanged | Enumcustomerauditlogs_FieldChangedFieldRefInput<$PrismaModel>
    in?: $Enums.customerauditlogs_FieldChanged[]
    notIn?: $Enums.customerauditlogs_FieldChanged[]
    not?: NestedEnumcustomerauditlogs_FieldChangedWithAggregatesFilter<$PrismaModel> | $Enums.customerauditlogs_FieldChanged
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumcustomerauditlogs_FieldChangedFilter<$PrismaModel>
    _max?: NestedEnumcustomerauditlogs_FieldChangedFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type userroleCreateWithoutAgentInput = {
    UserRole?: string | null
  }

  export type userroleUncheckedCreateWithoutAgentInput = {
    UserRoleID?: number
    UserRole?: string | null
  }

  export type userroleCreateOrConnectWithoutAgentInput = {
    where: userroleWhereUniqueInput
    create: XOR<userroleCreateWithoutAgentInput, userroleUncheckedCreateWithoutAgentInput>
  }

  export type customerCreateWithoutAgentInput = {
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    CardID?: number | null
    customerauditlogs?: customerauditlogsCreateNestedManyWithoutCustomerInput
    manychat?: manychatCreateNestedManyWithoutCustomerInput
    transactions?: transactionsCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutAgentInput = {
    CustomerId?: number
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    CardID?: number | null
    customerauditlogs?: customerauditlogsUncheckedCreateNestedManyWithoutCustomerInput
    manychat?: manychatUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutAgentInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutAgentInput, customerUncheckedCreateWithoutAgentInput>
  }

  export type customerCreateManyAgentInputEnvelope = {
    data: customerCreateManyAgentInput | customerCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type customerauditlogsCreateWithoutAgentInput = {
    FieldChanged: $Enums.customerauditlogs_FieldChanged
    OldValue?: string | null
    NewValue?: string | null
    ChangeDate?: Date | string
    customer: customerCreateNestedOneWithoutCustomerauditlogsInput
  }

  export type customerauditlogsUncheckedCreateWithoutAgentInput = {
    LogId?: number
    FieldChanged: $Enums.customerauditlogs_FieldChanged
    OldValue?: string | null
    NewValue?: string | null
    CustomerId: number
    ChangeDate?: Date | string
  }

  export type customerauditlogsCreateOrConnectWithoutAgentInput = {
    where: customerauditlogsWhereUniqueInput
    create: XOR<customerauditlogsCreateWithoutAgentInput, customerauditlogsUncheckedCreateWithoutAgentInput>
  }

  export type customerauditlogsCreateManyAgentInputEnvelope = {
    data: customerauditlogsCreateManyAgentInput | customerauditlogsCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type formvisibilitystatusCreateWithoutAgentInput = {
    IsFormOpen: boolean
    FormTimeStamp?: Date | string
  }

  export type formvisibilitystatusUncheckedCreateWithoutAgentInput = {
    VisibilityStatusId?: number
    IsFormOpen: boolean
    FormTimeStamp?: Date | string
  }

  export type formvisibilitystatusCreateOrConnectWithoutAgentInput = {
    where: formvisibilitystatusWhereUniqueInput
    create: XOR<formvisibilitystatusCreateWithoutAgentInput, formvisibilitystatusUncheckedCreateWithoutAgentInput>
  }

  export type formvisibilitystatusCreateManyAgentInputEnvelope = {
    data: formvisibilitystatusCreateManyAgentInput | formvisibilitystatusCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type noteCreateWithoutAgentInput = {
    Note?: string | null
    Date?: Date | string | null
    transactions?: transactionsCreateNestedManyWithoutNoteInput
  }

  export type noteUncheckedCreateWithoutAgentInput = {
    NoteID?: number
    Note?: string | null
    Date?: Date | string | null
    transactions?: transactionsUncheckedCreateNestedManyWithoutNoteInput
  }

  export type noteCreateOrConnectWithoutAgentInput = {
    where: noteWhereUniqueInput
    create: XOR<noteCreateWithoutAgentInput, noteUncheckedCreateWithoutAgentInput>
  }

  export type noteCreateManyAgentInputEnvelope = {
    data: noteCreateManyAgentInput | noteCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type transactionagentCreateWithoutAgentInput = {
    LogDate?: Date | string
    transactions?: transactionsCreateNestedOneWithoutTransactionagentInput
  }

  export type transactionagentUncheckedCreateWithoutAgentInput = {
    TransactionAgentID?: number
    TransactionID?: number | null
    LogDate?: Date | string
  }

  export type transactionagentCreateOrConnectWithoutAgentInput = {
    where: transactionagentWhereUniqueInput
    create: XOR<transactionagentCreateWithoutAgentInput, transactionagentUncheckedCreateWithoutAgentInput>
  }

  export type transactionagentCreateManyAgentInputEnvelope = {
    data: transactionagentCreateManyAgentInput | transactionagentCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type userroleUpsertWithoutAgentInput = {
    update: XOR<userroleUpdateWithoutAgentInput, userroleUncheckedUpdateWithoutAgentInput>
    create: XOR<userroleCreateWithoutAgentInput, userroleUncheckedCreateWithoutAgentInput>
    where?: userroleWhereInput
  }

  export type userroleUpdateToOneWithWhereWithoutAgentInput = {
    where?: userroleWhereInput
    data: XOR<userroleUpdateWithoutAgentInput, userroleUncheckedUpdateWithoutAgentInput>
  }

  export type userroleUpdateWithoutAgentInput = {
    UserRole?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type userroleUncheckedUpdateWithoutAgentInput = {
    UserRoleID?: IntFieldUpdateOperationsInput | number
    UserRole?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customerUpsertWithWhereUniqueWithoutAgentInput = {
    where: customerWhereUniqueInput
    update: XOR<customerUpdateWithoutAgentInput, customerUncheckedUpdateWithoutAgentInput>
    create: XOR<customerCreateWithoutAgentInput, customerUncheckedCreateWithoutAgentInput>
  }

  export type customerUpdateWithWhereUniqueWithoutAgentInput = {
    where: customerWhereUniqueInput
    data: XOR<customerUpdateWithoutAgentInput, customerUncheckedUpdateWithoutAgentInput>
  }

  export type customerUpdateManyWithWhereWithoutAgentInput = {
    where: customerScalarWhereInput
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyWithoutAgentInput>
  }

  export type customerScalarWhereInput = {
    AND?: customerScalarWhereInput | customerScalarWhereInput[]
    OR?: customerScalarWhereInput[]
    NOT?: customerScalarWhereInput | customerScalarWhereInput[]
    CustomerId?: IntFilter<"customer"> | number
    Name?: StringNullableFilter<"customer"> | string | null
    Email?: StringNullableFilter<"customer"> | string | null
    ManyChatId?: StringNullableFilter<"customer"> | string | null
    ExpireDate?: DateTimeNullableFilter<"customer"> | Date | string | null
    UserCountry?: StringNullableFilter<"customer"> | string | null
    ContactLink?: StringNullableFilter<"customer"> | string | null
    AgentId?: IntNullableFilter<"customer"> | number | null
    CardID?: IntNullableFilter<"customer"> | number | null
  }

  export type customerauditlogsUpsertWithWhereUniqueWithoutAgentInput = {
    where: customerauditlogsWhereUniqueInput
    update: XOR<customerauditlogsUpdateWithoutAgentInput, customerauditlogsUncheckedUpdateWithoutAgentInput>
    create: XOR<customerauditlogsCreateWithoutAgentInput, customerauditlogsUncheckedCreateWithoutAgentInput>
  }

  export type customerauditlogsUpdateWithWhereUniqueWithoutAgentInput = {
    where: customerauditlogsWhereUniqueInput
    data: XOR<customerauditlogsUpdateWithoutAgentInput, customerauditlogsUncheckedUpdateWithoutAgentInput>
  }

  export type customerauditlogsUpdateManyWithWhereWithoutAgentInput = {
    where: customerauditlogsScalarWhereInput
    data: XOR<customerauditlogsUpdateManyMutationInput, customerauditlogsUncheckedUpdateManyWithoutAgentInput>
  }

  export type customerauditlogsScalarWhereInput = {
    AND?: customerauditlogsScalarWhereInput | customerauditlogsScalarWhereInput[]
    OR?: customerauditlogsScalarWhereInput[]
    NOT?: customerauditlogsScalarWhereInput | customerauditlogsScalarWhereInput[]
    LogId?: IntFilter<"customerauditlogs"> | number
    AgentId?: IntFilter<"customerauditlogs"> | number
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFilter<"customerauditlogs"> | $Enums.customerauditlogs_FieldChanged
    OldValue?: StringNullableFilter<"customerauditlogs"> | string | null
    NewValue?: StringNullableFilter<"customerauditlogs"> | string | null
    CustomerId?: IntFilter<"customerauditlogs"> | number
    ChangeDate?: DateTimeFilter<"customerauditlogs"> | Date | string
  }

  export type formvisibilitystatusUpsertWithWhereUniqueWithoutAgentInput = {
    where: formvisibilitystatusWhereUniqueInput
    update: XOR<formvisibilitystatusUpdateWithoutAgentInput, formvisibilitystatusUncheckedUpdateWithoutAgentInput>
    create: XOR<formvisibilitystatusCreateWithoutAgentInput, formvisibilitystatusUncheckedCreateWithoutAgentInput>
  }

  export type formvisibilitystatusUpdateWithWhereUniqueWithoutAgentInput = {
    where: formvisibilitystatusWhereUniqueInput
    data: XOR<formvisibilitystatusUpdateWithoutAgentInput, formvisibilitystatusUncheckedUpdateWithoutAgentInput>
  }

  export type formvisibilitystatusUpdateManyWithWhereWithoutAgentInput = {
    where: formvisibilitystatusScalarWhereInput
    data: XOR<formvisibilitystatusUpdateManyMutationInput, formvisibilitystatusUncheckedUpdateManyWithoutAgentInput>
  }

  export type formvisibilitystatusScalarWhereInput = {
    AND?: formvisibilitystatusScalarWhereInput | formvisibilitystatusScalarWhereInput[]
    OR?: formvisibilitystatusScalarWhereInput[]
    NOT?: formvisibilitystatusScalarWhereInput | formvisibilitystatusScalarWhereInput[]
    VisibilityStatusId?: IntFilter<"formvisibilitystatus"> | number
    AgentId?: IntFilter<"formvisibilitystatus"> | number
    IsFormOpen?: BoolFilter<"formvisibilitystatus"> | boolean
    FormTimeStamp?: DateTimeFilter<"formvisibilitystatus"> | Date | string
  }

  export type noteUpsertWithWhereUniqueWithoutAgentInput = {
    where: noteWhereUniqueInput
    update: XOR<noteUpdateWithoutAgentInput, noteUncheckedUpdateWithoutAgentInput>
    create: XOR<noteCreateWithoutAgentInput, noteUncheckedCreateWithoutAgentInput>
  }

  export type noteUpdateWithWhereUniqueWithoutAgentInput = {
    where: noteWhereUniqueInput
    data: XOR<noteUpdateWithoutAgentInput, noteUncheckedUpdateWithoutAgentInput>
  }

  export type noteUpdateManyWithWhereWithoutAgentInput = {
    where: noteScalarWhereInput
    data: XOR<noteUpdateManyMutationInput, noteUncheckedUpdateManyWithoutAgentInput>
  }

  export type noteScalarWhereInput = {
    AND?: noteScalarWhereInput | noteScalarWhereInput[]
    OR?: noteScalarWhereInput[]
    NOT?: noteScalarWhereInput | noteScalarWhereInput[]
    NoteID?: IntFilter<"note"> | number
    Note?: StringNullableFilter<"note"> | string | null
    Date?: DateTimeNullableFilter<"note"> | Date | string | null
    AgentID?: IntNullableFilter<"note"> | number | null
  }

  export type transactionagentUpsertWithWhereUniqueWithoutAgentInput = {
    where: transactionagentWhereUniqueInput
    update: XOR<transactionagentUpdateWithoutAgentInput, transactionagentUncheckedUpdateWithoutAgentInput>
    create: XOR<transactionagentCreateWithoutAgentInput, transactionagentUncheckedCreateWithoutAgentInput>
  }

  export type transactionagentUpdateWithWhereUniqueWithoutAgentInput = {
    where: transactionagentWhereUniqueInput
    data: XOR<transactionagentUpdateWithoutAgentInput, transactionagentUncheckedUpdateWithoutAgentInput>
  }

  export type transactionagentUpdateManyWithWhereWithoutAgentInput = {
    where: transactionagentScalarWhereInput
    data: XOR<transactionagentUpdateManyMutationInput, transactionagentUncheckedUpdateManyWithoutAgentInput>
  }

  export type transactionagentScalarWhereInput = {
    AND?: transactionagentScalarWhereInput | transactionagentScalarWhereInput[]
    OR?: transactionagentScalarWhereInput[]
    NOT?: transactionagentScalarWhereInput | transactionagentScalarWhereInput[]
    TransactionAgentID?: IntFilter<"transactionagent"> | number
    TransactionID?: IntNullableFilter<"transactionagent"> | number | null
    AgentID?: IntNullableFilter<"transactionagent"> | number | null
    LogDate?: DateTimeFilter<"transactionagent"> | Date | string
  }

  export type exchangeratesCreateWithoutBasecountryInput = {
    ExchangeRate: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
    currency: currencyCreateNestedOneWithoutExchangeratesInput
  }

  export type exchangeratesUncheckedCreateWithoutBasecountryInput = {
    ExchangeRateId?: number
    CurrencyId: number
    ExchangeRate: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type exchangeratesCreateOrConnectWithoutBasecountryInput = {
    where: exchangeratesWhereUniqueInput
    create: XOR<exchangeratesCreateWithoutBasecountryInput, exchangeratesUncheckedCreateWithoutBasecountryInput>
  }

  export type exchangeratesCreateManyBasecountryInputEnvelope = {
    data: exchangeratesCreateManyBasecountryInput | exchangeratesCreateManyBasecountryInput[]
    skipDuplicates?: boolean
  }

  export type fundraiserCreateWithoutBasecountryInput = {
    FundraiserName: string
    FundraiserEmail: string
    FundraiserLogo?: string | null
    FundraiserCentralID?: number | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesCreateNestedManyWithoutFundraiserInput
    fundraiser_contactlinks?: fundraiser_contactlinksCreateNestedManyWithoutFundraiserInput
  }

  export type fundraiserUncheckedCreateWithoutBasecountryInput = {
    FundraiserID?: number
    FundraiserName: string
    FundraiserEmail: string
    FundraiserLogo?: string | null
    FundraiserCentralID?: number | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedCreateNestedManyWithoutFundraiserInput
    fundraiser_contactlinks?: fundraiser_contactlinksUncheckedCreateNestedManyWithoutFundraiserInput
  }

  export type fundraiserCreateOrConnectWithoutBasecountryInput = {
    where: fundraiserWhereUniqueInput
    create: XOR<fundraiserCreateWithoutBasecountryInput, fundraiserUncheckedCreateWithoutBasecountryInput>
  }

  export type fundraiserCreateManyBasecountryInputEnvelope = {
    data: fundraiserCreateManyBasecountryInput | fundraiserCreateManyBasecountryInput[]
    skipDuplicates?: boolean
  }

  export type exchangeratesUpsertWithWhereUniqueWithoutBasecountryInput = {
    where: exchangeratesWhereUniqueInput
    update: XOR<exchangeratesUpdateWithoutBasecountryInput, exchangeratesUncheckedUpdateWithoutBasecountryInput>
    create: XOR<exchangeratesCreateWithoutBasecountryInput, exchangeratesUncheckedCreateWithoutBasecountryInput>
  }

  export type exchangeratesUpdateWithWhereUniqueWithoutBasecountryInput = {
    where: exchangeratesWhereUniqueInput
    data: XOR<exchangeratesUpdateWithoutBasecountryInput, exchangeratesUncheckedUpdateWithoutBasecountryInput>
  }

  export type exchangeratesUpdateManyWithWhereWithoutBasecountryInput = {
    where: exchangeratesScalarWhereInput
    data: XOR<exchangeratesUpdateManyMutationInput, exchangeratesUncheckedUpdateManyWithoutBasecountryInput>
  }

  export type exchangeratesScalarWhereInput = {
    AND?: exchangeratesScalarWhereInput | exchangeratesScalarWhereInput[]
    OR?: exchangeratesScalarWhereInput[]
    NOT?: exchangeratesScalarWhereInput | exchangeratesScalarWhereInput[]
    ExchangeRateId?: IntFilter<"exchangerates"> | number
    BaseCountryId?: IntFilter<"exchangerates"> | number
    CurrencyId?: IntFilter<"exchangerates"> | number
    ExchangeRate?: DecimalFilter<"exchangerates"> | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFilter<"exchangerates"> | Date | string
    UpdatedAt?: DateTimeFilter<"exchangerates"> | Date | string
  }

  export type fundraiserUpsertWithWhereUniqueWithoutBasecountryInput = {
    where: fundraiserWhereUniqueInput
    update: XOR<fundraiserUpdateWithoutBasecountryInput, fundraiserUncheckedUpdateWithoutBasecountryInput>
    create: XOR<fundraiserCreateWithoutBasecountryInput, fundraiserUncheckedCreateWithoutBasecountryInput>
  }

  export type fundraiserUpdateWithWhereUniqueWithoutBasecountryInput = {
    where: fundraiserWhereUniqueInput
    data: XOR<fundraiserUpdateWithoutBasecountryInput, fundraiserUncheckedUpdateWithoutBasecountryInput>
  }

  export type fundraiserUpdateManyWithWhereWithoutBasecountryInput = {
    where: fundraiserScalarWhereInput
    data: XOR<fundraiserUpdateManyMutationInput, fundraiserUncheckedUpdateManyWithoutBasecountryInput>
  }

  export type fundraiserScalarWhereInput = {
    AND?: fundraiserScalarWhereInput | fundraiserScalarWhereInput[]
    OR?: fundraiserScalarWhereInput[]
    NOT?: fundraiserScalarWhereInput | fundraiserScalarWhereInput[]
    FundraiserID?: IntFilter<"fundraiser"> | number
    FundraiserName?: StringFilter<"fundraiser"> | string
    FundraiserEmail?: StringFilter<"fundraiser"> | string
    FundraiserLogo?: StringNullableFilter<"fundraiser"> | string | null
    BaseCountryID?: IntNullableFilter<"fundraiser"> | number | null
    FundraiserCentralID?: IntNullableFilter<"fundraiser"> | number | null
  }

  export type exchangeratesCreateWithoutCurrencyInput = {
    ExchangeRate: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
    basecountry: basecountryCreateNestedOneWithoutExchangeratesInput
  }

  export type exchangeratesUncheckedCreateWithoutCurrencyInput = {
    ExchangeRateId?: number
    BaseCountryId: number
    ExchangeRate: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type exchangeratesCreateOrConnectWithoutCurrencyInput = {
    where: exchangeratesWhereUniqueInput
    create: XOR<exchangeratesCreateWithoutCurrencyInput, exchangeratesUncheckedCreateWithoutCurrencyInput>
  }

  export type exchangeratesCreateManyCurrencyInputEnvelope = {
    data: exchangeratesCreateManyCurrencyInput | exchangeratesCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type fundraiser_acceptedcurrenciesCreateWithoutCurrencyInput = {
    fundraiser?: fundraiserCreateNestedOneWithoutFundraiser_acceptedcurrenciesInput
  }

  export type fundraiser_acceptedcurrenciesUncheckedCreateWithoutCurrencyInput = {
    FundraiserAcceptedCurrencyID?: number
    FundraiserID?: number | null
  }

  export type fundraiser_acceptedcurrenciesCreateOrConnectWithoutCurrencyInput = {
    where: fundraiser_acceptedcurrenciesWhereUniqueInput
    create: XOR<fundraiser_acceptedcurrenciesCreateWithoutCurrencyInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutCurrencyInput>
  }

  export type fundraiser_acceptedcurrenciesCreateManyCurrencyInputEnvelope = {
    data: fundraiser_acceptedcurrenciesCreateManyCurrencyInput | fundraiser_acceptedcurrenciesCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type minimumamountCreateWithoutCurrencyInput = {
    Amount: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type minimumamountUncheckedCreateWithoutCurrencyInput = {
    MinimumAmountId?: number
    Amount: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type minimumamountCreateOrConnectWithoutCurrencyInput = {
    where: minimumamountWhereUniqueInput
    create: XOR<minimumamountCreateWithoutCurrencyInput, minimumamountUncheckedCreateWithoutCurrencyInput>
  }

  export type minimumamountCreateManyCurrencyInputEnvelope = {
    data: minimumamountCreateManyCurrencyInput | minimumamountCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type walletCreateWithoutCurrencyInput = {
    WalletName?: string | null
    transactions?: transactionsCreateNestedManyWithoutWalletInput
  }

  export type walletUncheckedCreateWithoutCurrencyInput = {
    WalletId?: number
    WalletName?: string | null
    transactions?: transactionsUncheckedCreateNestedManyWithoutWalletInput
  }

  export type walletCreateOrConnectWithoutCurrencyInput = {
    where: walletWhereUniqueInput
    create: XOR<walletCreateWithoutCurrencyInput, walletUncheckedCreateWithoutCurrencyInput>
  }

  export type walletCreateManyCurrencyInputEnvelope = {
    data: walletCreateManyCurrencyInput | walletCreateManyCurrencyInput[]
    skipDuplicates?: boolean
  }

  export type exchangeratesUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: exchangeratesWhereUniqueInput
    update: XOR<exchangeratesUpdateWithoutCurrencyInput, exchangeratesUncheckedUpdateWithoutCurrencyInput>
    create: XOR<exchangeratesCreateWithoutCurrencyInput, exchangeratesUncheckedCreateWithoutCurrencyInput>
  }

  export type exchangeratesUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: exchangeratesWhereUniqueInput
    data: XOR<exchangeratesUpdateWithoutCurrencyInput, exchangeratesUncheckedUpdateWithoutCurrencyInput>
  }

  export type exchangeratesUpdateManyWithWhereWithoutCurrencyInput = {
    where: exchangeratesScalarWhereInput
    data: XOR<exchangeratesUpdateManyMutationInput, exchangeratesUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type fundraiser_acceptedcurrenciesUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: fundraiser_acceptedcurrenciesWhereUniqueInput
    update: XOR<fundraiser_acceptedcurrenciesUpdateWithoutCurrencyInput, fundraiser_acceptedcurrenciesUncheckedUpdateWithoutCurrencyInput>
    create: XOR<fundraiser_acceptedcurrenciesCreateWithoutCurrencyInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutCurrencyInput>
  }

  export type fundraiser_acceptedcurrenciesUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: fundraiser_acceptedcurrenciesWhereUniqueInput
    data: XOR<fundraiser_acceptedcurrenciesUpdateWithoutCurrencyInput, fundraiser_acceptedcurrenciesUncheckedUpdateWithoutCurrencyInput>
  }

  export type fundraiser_acceptedcurrenciesUpdateManyWithWhereWithoutCurrencyInput = {
    where: fundraiser_acceptedcurrenciesScalarWhereInput
    data: XOR<fundraiser_acceptedcurrenciesUpdateManyMutationInput, fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type fundraiser_acceptedcurrenciesScalarWhereInput = {
    AND?: fundraiser_acceptedcurrenciesScalarWhereInput | fundraiser_acceptedcurrenciesScalarWhereInput[]
    OR?: fundraiser_acceptedcurrenciesScalarWhereInput[]
    NOT?: fundraiser_acceptedcurrenciesScalarWhereInput | fundraiser_acceptedcurrenciesScalarWhereInput[]
    FundraiserAcceptedCurrencyID?: IntFilter<"fundraiser_acceptedcurrencies"> | number
    FundraiserID?: IntNullableFilter<"fundraiser_acceptedcurrencies"> | number | null
    CurrencyID?: IntNullableFilter<"fundraiser_acceptedcurrencies"> | number | null
  }

  export type minimumamountUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: minimumamountWhereUniqueInput
    update: XOR<minimumamountUpdateWithoutCurrencyInput, minimumamountUncheckedUpdateWithoutCurrencyInput>
    create: XOR<minimumamountCreateWithoutCurrencyInput, minimumamountUncheckedCreateWithoutCurrencyInput>
  }

  export type minimumamountUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: minimumamountWhereUniqueInput
    data: XOR<minimumamountUpdateWithoutCurrencyInput, minimumamountUncheckedUpdateWithoutCurrencyInput>
  }

  export type minimumamountUpdateManyWithWhereWithoutCurrencyInput = {
    where: minimumamountScalarWhereInput
    data: XOR<minimumamountUpdateManyMutationInput, minimumamountUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type minimumamountScalarWhereInput = {
    AND?: minimumamountScalarWhereInput | minimumamountScalarWhereInput[]
    OR?: minimumamountScalarWhereInput[]
    NOT?: minimumamountScalarWhereInput | minimumamountScalarWhereInput[]
    MinimumAmountId?: IntFilter<"minimumamount"> | number
    CurrencyId?: IntFilter<"minimumamount"> | number
    Amount?: DecimalFilter<"minimumamount"> | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFilter<"minimumamount"> | Date | string
    UpdatedAt?: DateTimeFilter<"minimumamount"> | Date | string
  }

  export type walletUpsertWithWhereUniqueWithoutCurrencyInput = {
    where: walletWhereUniqueInput
    update: XOR<walletUpdateWithoutCurrencyInput, walletUncheckedUpdateWithoutCurrencyInput>
    create: XOR<walletCreateWithoutCurrencyInput, walletUncheckedCreateWithoutCurrencyInput>
  }

  export type walletUpdateWithWhereUniqueWithoutCurrencyInput = {
    where: walletWhereUniqueInput
    data: XOR<walletUpdateWithoutCurrencyInput, walletUncheckedUpdateWithoutCurrencyInput>
  }

  export type walletUpdateManyWithWhereWithoutCurrencyInput = {
    where: walletScalarWhereInput
    data: XOR<walletUpdateManyMutationInput, walletUncheckedUpdateManyWithoutCurrencyInput>
  }

  export type walletScalarWhereInput = {
    AND?: walletScalarWhereInput | walletScalarWhereInput[]
    OR?: walletScalarWhereInput[]
    NOT?: walletScalarWhereInput | walletScalarWhereInput[]
    WalletId?: IntFilter<"wallet"> | number
    CurrencyId?: IntNullableFilter<"wallet"> | number | null
    WalletName?: StringNullableFilter<"wallet"> | string | null
  }

  export type agentCreateWithoutCustomerInput = {
    AwsId?: string | null
    userrole?: userroleCreateNestedOneWithoutAgentInput
    customerauditlogs?: customerauditlogsCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusCreateNestedManyWithoutAgentInput
    note?: noteCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentCreateNestedManyWithoutAgentInput
  }

  export type agentUncheckedCreateWithoutCustomerInput = {
    AgentId?: number
    AwsId?: string | null
    UserRoleId?: number | null
    customerauditlogs?: customerauditlogsUncheckedCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusUncheckedCreateNestedManyWithoutAgentInput
    note?: noteUncheckedCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type agentCreateOrConnectWithoutCustomerInput = {
    where: agentWhereUniqueInput
    create: XOR<agentCreateWithoutCustomerInput, agentUncheckedCreateWithoutCustomerInput>
  }

  export type customerauditlogsCreateWithoutCustomerInput = {
    FieldChanged: $Enums.customerauditlogs_FieldChanged
    OldValue?: string | null
    NewValue?: string | null
    ChangeDate?: Date | string
    agent: agentCreateNestedOneWithoutCustomerauditlogsInput
  }

  export type customerauditlogsUncheckedCreateWithoutCustomerInput = {
    LogId?: number
    AgentId: number
    FieldChanged: $Enums.customerauditlogs_FieldChanged
    OldValue?: string | null
    NewValue?: string | null
    ChangeDate?: Date | string
  }

  export type customerauditlogsCreateOrConnectWithoutCustomerInput = {
    where: customerauditlogsWhereUniqueInput
    create: XOR<customerauditlogsCreateWithoutCustomerInput, customerauditlogsUncheckedCreateWithoutCustomerInput>
  }

  export type customerauditlogsCreateManyCustomerInputEnvelope = {
    data: customerauditlogsCreateManyCustomerInput | customerauditlogsCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type manychatCreateWithoutCustomerInput = {
    ConversationId: string
    CreateAt?: Date | string
    UpdateAt?: Date | string
  }

  export type manychatUncheckedCreateWithoutCustomerInput = {
    ManyChatId?: number
    ConversationId: string
    CreateAt?: Date | string
    UpdateAt?: Date | string
  }

  export type manychatCreateOrConnectWithoutCustomerInput = {
    where: manychatWhereUniqueInput
    create: XOR<manychatCreateWithoutCustomerInput, manychatUncheckedCreateWithoutCustomerInput>
  }

  export type manychatCreateManyCustomerInputEnvelope = {
    data: manychatCreateManyCustomerInput | manychatCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type transactionsCreateWithoutCustomerInput = {
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentCreateNestedManyWithoutTransactionsInput
    supportregion?: supportregionCreateNestedOneWithoutTransactionsInput
    wallet?: walletCreateNestedOneWithoutTransactionsInput
    note?: noteCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutCustomerInput = {
    TransactionID?: number
    SupportRegionID?: number | null
    WalletID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    NoteID?: number | null
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusUncheckedCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotUncheckedCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsCreateOrConnectWithoutCustomerInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutCustomerInput, transactionsUncheckedCreateWithoutCustomerInput>
  }

  export type transactionsCreateManyCustomerInputEnvelope = {
    data: transactionsCreateManyCustomerInput | transactionsCreateManyCustomerInput[]
    skipDuplicates?: boolean
  }

  export type agentUpsertWithoutCustomerInput = {
    update: XOR<agentUpdateWithoutCustomerInput, agentUncheckedUpdateWithoutCustomerInput>
    create: XOR<agentCreateWithoutCustomerInput, agentUncheckedCreateWithoutCustomerInput>
    where?: agentWhereInput
  }

  export type agentUpdateToOneWithWhereWithoutCustomerInput = {
    where?: agentWhereInput
    data: XOR<agentUpdateWithoutCustomerInput, agentUncheckedUpdateWithoutCustomerInput>
  }

  export type agentUpdateWithoutCustomerInput = {
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    userrole?: userroleUpdateOneWithoutAgentNestedInput
    customerauditlogs?: customerauditlogsUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUpdateManyWithoutAgentNestedInput
    note?: noteUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUpdateManyWithoutAgentNestedInput
  }

  export type agentUncheckedUpdateWithoutCustomerInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    UserRoleId?: NullableIntFieldUpdateOperationsInput | number | null
    customerauditlogs?: customerauditlogsUncheckedUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUncheckedUpdateManyWithoutAgentNestedInput
    note?: noteUncheckedUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type customerauditlogsUpsertWithWhereUniqueWithoutCustomerInput = {
    where: customerauditlogsWhereUniqueInput
    update: XOR<customerauditlogsUpdateWithoutCustomerInput, customerauditlogsUncheckedUpdateWithoutCustomerInput>
    create: XOR<customerauditlogsCreateWithoutCustomerInput, customerauditlogsUncheckedCreateWithoutCustomerInput>
  }

  export type customerauditlogsUpdateWithWhereUniqueWithoutCustomerInput = {
    where: customerauditlogsWhereUniqueInput
    data: XOR<customerauditlogsUpdateWithoutCustomerInput, customerauditlogsUncheckedUpdateWithoutCustomerInput>
  }

  export type customerauditlogsUpdateManyWithWhereWithoutCustomerInput = {
    where: customerauditlogsScalarWhereInput
    data: XOR<customerauditlogsUpdateManyMutationInput, customerauditlogsUncheckedUpdateManyWithoutCustomerInput>
  }

  export type manychatUpsertWithWhereUniqueWithoutCustomerInput = {
    where: manychatWhereUniqueInput
    update: XOR<manychatUpdateWithoutCustomerInput, manychatUncheckedUpdateWithoutCustomerInput>
    create: XOR<manychatCreateWithoutCustomerInput, manychatUncheckedCreateWithoutCustomerInput>
  }

  export type manychatUpdateWithWhereUniqueWithoutCustomerInput = {
    where: manychatWhereUniqueInput
    data: XOR<manychatUpdateWithoutCustomerInput, manychatUncheckedUpdateWithoutCustomerInput>
  }

  export type manychatUpdateManyWithWhereWithoutCustomerInput = {
    where: manychatScalarWhereInput
    data: XOR<manychatUpdateManyMutationInput, manychatUncheckedUpdateManyWithoutCustomerInput>
  }

  export type manychatScalarWhereInput = {
    AND?: manychatScalarWhereInput | manychatScalarWhereInput[]
    OR?: manychatScalarWhereInput[]
    NOT?: manychatScalarWhereInput | manychatScalarWhereInput[]
    ManyChatId?: IntFilter<"manychat"> | number
    ConversationId?: StringFilter<"manychat"> | string
    CustomerId?: IntFilter<"manychat"> | number
    CreateAt?: DateTimeFilter<"manychat"> | Date | string
    UpdateAt?: DateTimeFilter<"manychat"> | Date | string
  }

  export type transactionsUpsertWithWhereUniqueWithoutCustomerInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutCustomerInput, transactionsUncheckedUpdateWithoutCustomerInput>
    create: XOR<transactionsCreateWithoutCustomerInput, transactionsUncheckedCreateWithoutCustomerInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutCustomerInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutCustomerInput, transactionsUncheckedUpdateWithoutCustomerInput>
  }

  export type transactionsUpdateManyWithWhereWithoutCustomerInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutCustomerInput>
  }

  export type transactionsScalarWhereInput = {
    AND?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
    OR?: transactionsScalarWhereInput[]
    NOT?: transactionsScalarWhereInput | transactionsScalarWhereInput[]
    TransactionID?: IntFilter<"transactions"> | number
    CustomerID?: IntNullableFilter<"transactions"> | number | null
    SupportRegionID?: IntNullableFilter<"transactions"> | number | null
    WalletID?: IntNullableFilter<"transactions"> | number | null
    Amount?: FloatNullableFilter<"transactions"> | number | null
    PaymentCheck?: BoolNullableFilter<"transactions"> | boolean | null
    PaymentCheckTime?: DateTimeFilter<"transactions"> | Date | string
    NoteID?: IntNullableFilter<"transactions"> | number | null
    TransactionDate?: DateTimeFilter<"transactions"> | Date | string
    PaymentDenied?: BoolNullableFilter<"transactions"> | boolean | null
    Month?: IntNullableFilter<"transactions"> | number | null
    HopeFuelID?: IntNullableFilter<"transactions"> | number | null
  }

  export type agentCreateWithoutCustomerauditlogsInput = {
    AwsId?: string | null
    userrole?: userroleCreateNestedOneWithoutAgentInput
    customer?: customerCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusCreateNestedManyWithoutAgentInput
    note?: noteCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentCreateNestedManyWithoutAgentInput
  }

  export type agentUncheckedCreateWithoutCustomerauditlogsInput = {
    AgentId?: number
    AwsId?: string | null
    UserRoleId?: number | null
    customer?: customerUncheckedCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusUncheckedCreateNestedManyWithoutAgentInput
    note?: noteUncheckedCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type agentCreateOrConnectWithoutCustomerauditlogsInput = {
    where: agentWhereUniqueInput
    create: XOR<agentCreateWithoutCustomerauditlogsInput, agentUncheckedCreateWithoutCustomerauditlogsInput>
  }

  export type customerCreateWithoutCustomerauditlogsInput = {
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    CardID?: number | null
    agent?: agentCreateNestedOneWithoutCustomerInput
    manychat?: manychatCreateNestedManyWithoutCustomerInput
    transactions?: transactionsCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutCustomerauditlogsInput = {
    CustomerId?: number
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    AgentId?: number | null
    CardID?: number | null
    manychat?: manychatUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutCustomerauditlogsInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutCustomerauditlogsInput, customerUncheckedCreateWithoutCustomerauditlogsInput>
  }

  export type agentUpsertWithoutCustomerauditlogsInput = {
    update: XOR<agentUpdateWithoutCustomerauditlogsInput, agentUncheckedUpdateWithoutCustomerauditlogsInput>
    create: XOR<agentCreateWithoutCustomerauditlogsInput, agentUncheckedCreateWithoutCustomerauditlogsInput>
    where?: agentWhereInput
  }

  export type agentUpdateToOneWithWhereWithoutCustomerauditlogsInput = {
    where?: agentWhereInput
    data: XOR<agentUpdateWithoutCustomerauditlogsInput, agentUncheckedUpdateWithoutCustomerauditlogsInput>
  }

  export type agentUpdateWithoutCustomerauditlogsInput = {
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    userrole?: userroleUpdateOneWithoutAgentNestedInput
    customer?: customerUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUpdateManyWithoutAgentNestedInput
    note?: noteUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUpdateManyWithoutAgentNestedInput
  }

  export type agentUncheckedUpdateWithoutCustomerauditlogsInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    UserRoleId?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: customerUncheckedUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUncheckedUpdateManyWithoutAgentNestedInput
    note?: noteUncheckedUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type customerUpsertWithoutCustomerauditlogsInput = {
    update: XOR<customerUpdateWithoutCustomerauditlogsInput, customerUncheckedUpdateWithoutCustomerauditlogsInput>
    create: XOR<customerCreateWithoutCustomerauditlogsInput, customerUncheckedCreateWithoutCustomerauditlogsInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutCustomerauditlogsInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutCustomerauditlogsInput, customerUncheckedUpdateWithoutCustomerauditlogsInput>
  }

  export type customerUpdateWithoutCustomerauditlogsInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
    agent?: agentUpdateOneWithoutCustomerNestedInput
    manychat?: manychatUpdateManyWithoutCustomerNestedInput
    transactions?: transactionsUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutCustomerauditlogsInput = {
    CustomerId?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
    manychat?: manychatUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type basecountryCreateWithoutExchangeratesInput = {
    BaseCountryName: string
    fundraiser?: fundraiserCreateNestedManyWithoutBasecountryInput
  }

  export type basecountryUncheckedCreateWithoutExchangeratesInput = {
    BaseCountryID?: number
    BaseCountryName: string
    fundraiser?: fundraiserUncheckedCreateNestedManyWithoutBasecountryInput
  }

  export type basecountryCreateOrConnectWithoutExchangeratesInput = {
    where: basecountryWhereUniqueInput
    create: XOR<basecountryCreateWithoutExchangeratesInput, basecountryUncheckedCreateWithoutExchangeratesInput>
  }

  export type currencyCreateWithoutExchangeratesInput = {
    CurrencyCode?: string | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesCreateNestedManyWithoutCurrencyInput
    minimumamount?: minimumamountCreateNestedManyWithoutCurrencyInput
    wallet?: walletCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUncheckedCreateWithoutExchangeratesInput = {
    CurrencyId?: number
    CurrencyCode?: string | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedCreateNestedManyWithoutCurrencyInput
    minimumamount?: minimumamountUncheckedCreateNestedManyWithoutCurrencyInput
    wallet?: walletUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type currencyCreateOrConnectWithoutExchangeratesInput = {
    where: currencyWhereUniqueInput
    create: XOR<currencyCreateWithoutExchangeratesInput, currencyUncheckedCreateWithoutExchangeratesInput>
  }

  export type basecountryUpsertWithoutExchangeratesInput = {
    update: XOR<basecountryUpdateWithoutExchangeratesInput, basecountryUncheckedUpdateWithoutExchangeratesInput>
    create: XOR<basecountryCreateWithoutExchangeratesInput, basecountryUncheckedCreateWithoutExchangeratesInput>
    where?: basecountryWhereInput
  }

  export type basecountryUpdateToOneWithWhereWithoutExchangeratesInput = {
    where?: basecountryWhereInput
    data: XOR<basecountryUpdateWithoutExchangeratesInput, basecountryUncheckedUpdateWithoutExchangeratesInput>
  }

  export type basecountryUpdateWithoutExchangeratesInput = {
    BaseCountryName?: StringFieldUpdateOperationsInput | string
    fundraiser?: fundraiserUpdateManyWithoutBasecountryNestedInput
  }

  export type basecountryUncheckedUpdateWithoutExchangeratesInput = {
    BaseCountryID?: IntFieldUpdateOperationsInput | number
    BaseCountryName?: StringFieldUpdateOperationsInput | string
    fundraiser?: fundraiserUncheckedUpdateManyWithoutBasecountryNestedInput
  }

  export type currencyUpsertWithoutExchangeratesInput = {
    update: XOR<currencyUpdateWithoutExchangeratesInput, currencyUncheckedUpdateWithoutExchangeratesInput>
    create: XOR<currencyCreateWithoutExchangeratesInput, currencyUncheckedCreateWithoutExchangeratesInput>
    where?: currencyWhereInput
  }

  export type currencyUpdateToOneWithWhereWithoutExchangeratesInput = {
    where?: currencyWhereInput
    data: XOR<currencyUpdateWithoutExchangeratesInput, currencyUncheckedUpdateWithoutExchangeratesInput>
  }

  export type currencyUpdateWithoutExchangeratesInput = {
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUpdateManyWithoutCurrencyNestedInput
    minimumamount?: minimumamountUpdateManyWithoutCurrencyNestedInput
    wallet?: walletUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyUncheckedUpdateWithoutExchangeratesInput = {
    CurrencyId?: IntFieldUpdateOperationsInput | number
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutCurrencyNestedInput
    minimumamount?: minimumamountUncheckedUpdateManyWithoutCurrencyNestedInput
    wallet?: walletUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type transactionsCreateWithoutFormstatusInput = {
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    screenshot?: screenshotCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentCreateNestedManyWithoutTransactionsInput
    customer?: customerCreateNestedOneWithoutTransactionsInput
    supportregion?: supportregionCreateNestedOneWithoutTransactionsInput
    wallet?: walletCreateNestedOneWithoutTransactionsInput
    note?: noteCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutFormstatusInput = {
    TransactionID?: number
    CustomerID?: number | null
    SupportRegionID?: number | null
    WalletID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    NoteID?: number | null
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    screenshot?: screenshotUncheckedCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsCreateOrConnectWithoutFormstatusInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutFormstatusInput, transactionsUncheckedCreateWithoutFormstatusInput>
  }

  export type transactionstatusCreateWithoutFormstatusInput = {
    TransactionStatus: string
  }

  export type transactionstatusUncheckedCreateWithoutFormstatusInput = {
    TransactionStatusID?: number
    TransactionStatus: string
  }

  export type transactionstatusCreateOrConnectWithoutFormstatusInput = {
    where: transactionstatusWhereUniqueInput
    create: XOR<transactionstatusCreateWithoutFormstatusInput, transactionstatusUncheckedCreateWithoutFormstatusInput>
  }

  export type transactionsUpsertWithoutFormstatusInput = {
    update: XOR<transactionsUpdateWithoutFormstatusInput, transactionsUncheckedUpdateWithoutFormstatusInput>
    create: XOR<transactionsCreateWithoutFormstatusInput, transactionsUncheckedCreateWithoutFormstatusInput>
    where?: transactionsWhereInput
  }

  export type transactionsUpdateToOneWithWhereWithoutFormstatusInput = {
    where?: transactionsWhereInput
    data: XOR<transactionsUpdateWithoutFormstatusInput, transactionsUncheckedUpdateWithoutFormstatusInput>
  }

  export type transactionsUpdateWithoutFormstatusInput = {
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot?: screenshotUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUpdateManyWithoutTransactionsNestedInput
    customer?: customerUpdateOneWithoutTransactionsNestedInput
    supportregion?: supportregionUpdateOneWithoutTransactionsNestedInput
    wallet?: walletUpdateOneWithoutTransactionsNestedInput
    note?: noteUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutFormstatusInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    SupportRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    WalletID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NoteID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    screenshot?: screenshotUncheckedUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type transactionstatusUpsertWithoutFormstatusInput = {
    update: XOR<transactionstatusUpdateWithoutFormstatusInput, transactionstatusUncheckedUpdateWithoutFormstatusInput>
    create: XOR<transactionstatusCreateWithoutFormstatusInput, transactionstatusUncheckedCreateWithoutFormstatusInput>
    where?: transactionstatusWhereInput
  }

  export type transactionstatusUpdateToOneWithWhereWithoutFormstatusInput = {
    where?: transactionstatusWhereInput
    data: XOR<transactionstatusUpdateWithoutFormstatusInput, transactionstatusUncheckedUpdateWithoutFormstatusInput>
  }

  export type transactionstatusUpdateWithoutFormstatusInput = {
    TransactionStatus?: StringFieldUpdateOperationsInput | string
  }

  export type transactionstatusUncheckedUpdateWithoutFormstatusInput = {
    TransactionStatusID?: IntFieldUpdateOperationsInput | number
    TransactionStatus?: StringFieldUpdateOperationsInput | string
  }

  export type agentCreateWithoutFormvisibilitystatusInput = {
    AwsId?: string | null
    userrole?: userroleCreateNestedOneWithoutAgentInput
    customer?: customerCreateNestedManyWithoutAgentInput
    customerauditlogs?: customerauditlogsCreateNestedManyWithoutAgentInput
    note?: noteCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentCreateNestedManyWithoutAgentInput
  }

  export type agentUncheckedCreateWithoutFormvisibilitystatusInput = {
    AgentId?: number
    AwsId?: string | null
    UserRoleId?: number | null
    customer?: customerUncheckedCreateNestedManyWithoutAgentInput
    customerauditlogs?: customerauditlogsUncheckedCreateNestedManyWithoutAgentInput
    note?: noteUncheckedCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type agentCreateOrConnectWithoutFormvisibilitystatusInput = {
    where: agentWhereUniqueInput
    create: XOR<agentCreateWithoutFormvisibilitystatusInput, agentUncheckedCreateWithoutFormvisibilitystatusInput>
  }

  export type agentUpsertWithoutFormvisibilitystatusInput = {
    update: XOR<agentUpdateWithoutFormvisibilitystatusInput, agentUncheckedUpdateWithoutFormvisibilitystatusInput>
    create: XOR<agentCreateWithoutFormvisibilitystatusInput, agentUncheckedCreateWithoutFormvisibilitystatusInput>
    where?: agentWhereInput
  }

  export type agentUpdateToOneWithWhereWithoutFormvisibilitystatusInput = {
    where?: agentWhereInput
    data: XOR<agentUpdateWithoutFormvisibilitystatusInput, agentUncheckedUpdateWithoutFormvisibilitystatusInput>
  }

  export type agentUpdateWithoutFormvisibilitystatusInput = {
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    userrole?: userroleUpdateOneWithoutAgentNestedInput
    customer?: customerUpdateManyWithoutAgentNestedInput
    customerauditlogs?: customerauditlogsUpdateManyWithoutAgentNestedInput
    note?: noteUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUpdateManyWithoutAgentNestedInput
  }

  export type agentUncheckedUpdateWithoutFormvisibilitystatusInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    UserRoleId?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: customerUncheckedUpdateManyWithoutAgentNestedInput
    customerauditlogs?: customerauditlogsUncheckedUpdateManyWithoutAgentNestedInput
    note?: noteUncheckedUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type basecountryCreateWithoutFundraiserInput = {
    BaseCountryName: string
    exchangerates?: exchangeratesCreateNestedManyWithoutBasecountryInput
  }

  export type basecountryUncheckedCreateWithoutFundraiserInput = {
    BaseCountryID?: number
    BaseCountryName: string
    exchangerates?: exchangeratesUncheckedCreateNestedManyWithoutBasecountryInput
  }

  export type basecountryCreateOrConnectWithoutFundraiserInput = {
    where: basecountryWhereUniqueInput
    create: XOR<basecountryCreateWithoutFundraiserInput, basecountryUncheckedCreateWithoutFundraiserInput>
  }

  export type fundraiser_acceptedcurrenciesCreateWithoutFundraiserInput = {
    currency?: currencyCreateNestedOneWithoutFundraiser_acceptedcurrenciesInput
  }

  export type fundraiser_acceptedcurrenciesUncheckedCreateWithoutFundraiserInput = {
    FundraiserAcceptedCurrencyID?: number
    CurrencyID?: number | null
  }

  export type fundraiser_acceptedcurrenciesCreateOrConnectWithoutFundraiserInput = {
    where: fundraiser_acceptedcurrenciesWhereUniqueInput
    create: XOR<fundraiser_acceptedcurrenciesCreateWithoutFundraiserInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutFundraiserInput>
  }

  export type fundraiser_acceptedcurrenciesCreateManyFundraiserInputEnvelope = {
    data: fundraiser_acceptedcurrenciesCreateManyFundraiserInput | fundraiser_acceptedcurrenciesCreateManyFundraiserInput[]
    skipDuplicates?: boolean
  }

  export type fundraiser_contactlinksCreateWithoutFundraiserInput = {
    Platform?: number | null
    ContactURL: string
  }

  export type fundraiser_contactlinksUncheckedCreateWithoutFundraiserInput = {
    ContactID?: number
    Platform?: number | null
    ContactURL: string
  }

  export type fundraiser_contactlinksCreateOrConnectWithoutFundraiserInput = {
    where: fundraiser_contactlinksWhereUniqueInput
    create: XOR<fundraiser_contactlinksCreateWithoutFundraiserInput, fundraiser_contactlinksUncheckedCreateWithoutFundraiserInput>
  }

  export type fundraiser_contactlinksCreateManyFundraiserInputEnvelope = {
    data: fundraiser_contactlinksCreateManyFundraiserInput | fundraiser_contactlinksCreateManyFundraiserInput[]
    skipDuplicates?: boolean
  }

  export type basecountryUpsertWithoutFundraiserInput = {
    update: XOR<basecountryUpdateWithoutFundraiserInput, basecountryUncheckedUpdateWithoutFundraiserInput>
    create: XOR<basecountryCreateWithoutFundraiserInput, basecountryUncheckedCreateWithoutFundraiserInput>
    where?: basecountryWhereInput
  }

  export type basecountryUpdateToOneWithWhereWithoutFundraiserInput = {
    where?: basecountryWhereInput
    data: XOR<basecountryUpdateWithoutFundraiserInput, basecountryUncheckedUpdateWithoutFundraiserInput>
  }

  export type basecountryUpdateWithoutFundraiserInput = {
    BaseCountryName?: StringFieldUpdateOperationsInput | string
    exchangerates?: exchangeratesUpdateManyWithoutBasecountryNestedInput
  }

  export type basecountryUncheckedUpdateWithoutFundraiserInput = {
    BaseCountryID?: IntFieldUpdateOperationsInput | number
    BaseCountryName?: StringFieldUpdateOperationsInput | string
    exchangerates?: exchangeratesUncheckedUpdateManyWithoutBasecountryNestedInput
  }

  export type fundraiser_acceptedcurrenciesUpsertWithWhereUniqueWithoutFundraiserInput = {
    where: fundraiser_acceptedcurrenciesWhereUniqueInput
    update: XOR<fundraiser_acceptedcurrenciesUpdateWithoutFundraiserInput, fundraiser_acceptedcurrenciesUncheckedUpdateWithoutFundraiserInput>
    create: XOR<fundraiser_acceptedcurrenciesCreateWithoutFundraiserInput, fundraiser_acceptedcurrenciesUncheckedCreateWithoutFundraiserInput>
  }

  export type fundraiser_acceptedcurrenciesUpdateWithWhereUniqueWithoutFundraiserInput = {
    where: fundraiser_acceptedcurrenciesWhereUniqueInput
    data: XOR<fundraiser_acceptedcurrenciesUpdateWithoutFundraiserInput, fundraiser_acceptedcurrenciesUncheckedUpdateWithoutFundraiserInput>
  }

  export type fundraiser_acceptedcurrenciesUpdateManyWithWhereWithoutFundraiserInput = {
    where: fundraiser_acceptedcurrenciesScalarWhereInput
    data: XOR<fundraiser_acceptedcurrenciesUpdateManyMutationInput, fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutFundraiserInput>
  }

  export type fundraiser_contactlinksUpsertWithWhereUniqueWithoutFundraiserInput = {
    where: fundraiser_contactlinksWhereUniqueInput
    update: XOR<fundraiser_contactlinksUpdateWithoutFundraiserInput, fundraiser_contactlinksUncheckedUpdateWithoutFundraiserInput>
    create: XOR<fundraiser_contactlinksCreateWithoutFundraiserInput, fundraiser_contactlinksUncheckedCreateWithoutFundraiserInput>
  }

  export type fundraiser_contactlinksUpdateWithWhereUniqueWithoutFundraiserInput = {
    where: fundraiser_contactlinksWhereUniqueInput
    data: XOR<fundraiser_contactlinksUpdateWithoutFundraiserInput, fundraiser_contactlinksUncheckedUpdateWithoutFundraiserInput>
  }

  export type fundraiser_contactlinksUpdateManyWithWhereWithoutFundraiserInput = {
    where: fundraiser_contactlinksScalarWhereInput
    data: XOR<fundraiser_contactlinksUpdateManyMutationInput, fundraiser_contactlinksUncheckedUpdateManyWithoutFundraiserInput>
  }

  export type fundraiser_contactlinksScalarWhereInput = {
    AND?: fundraiser_contactlinksScalarWhereInput | fundraiser_contactlinksScalarWhereInput[]
    OR?: fundraiser_contactlinksScalarWhereInput[]
    NOT?: fundraiser_contactlinksScalarWhereInput | fundraiser_contactlinksScalarWhereInput[]
    ContactID?: IntFilter<"fundraiser_contactlinks"> | number
    FundraiserID?: IntNullableFilter<"fundraiser_contactlinks"> | number | null
    Platform?: IntNullableFilter<"fundraiser_contactlinks"> | number | null
    ContactURL?: StringFilter<"fundraiser_contactlinks"> | string
  }

  export type fundraiserCreateWithoutFundraiser_acceptedcurrenciesInput = {
    FundraiserName: string
    FundraiserEmail: string
    FundraiserLogo?: string | null
    FundraiserCentralID?: number | null
    basecountry?: basecountryCreateNestedOneWithoutFundraiserInput
    fundraiser_contactlinks?: fundraiser_contactlinksCreateNestedManyWithoutFundraiserInput
  }

  export type fundraiserUncheckedCreateWithoutFundraiser_acceptedcurrenciesInput = {
    FundraiserID?: number
    FundraiserName: string
    FundraiserEmail: string
    FundraiserLogo?: string | null
    BaseCountryID?: number | null
    FundraiserCentralID?: number | null
    fundraiser_contactlinks?: fundraiser_contactlinksUncheckedCreateNestedManyWithoutFundraiserInput
  }

  export type fundraiserCreateOrConnectWithoutFundraiser_acceptedcurrenciesInput = {
    where: fundraiserWhereUniqueInput
    create: XOR<fundraiserCreateWithoutFundraiser_acceptedcurrenciesInput, fundraiserUncheckedCreateWithoutFundraiser_acceptedcurrenciesInput>
  }

  export type currencyCreateWithoutFundraiser_acceptedcurrenciesInput = {
    CurrencyCode?: string | null
    exchangerates?: exchangeratesCreateNestedManyWithoutCurrencyInput
    minimumamount?: minimumamountCreateNestedManyWithoutCurrencyInput
    wallet?: walletCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUncheckedCreateWithoutFundraiser_acceptedcurrenciesInput = {
    CurrencyId?: number
    CurrencyCode?: string | null
    exchangerates?: exchangeratesUncheckedCreateNestedManyWithoutCurrencyInput
    minimumamount?: minimumamountUncheckedCreateNestedManyWithoutCurrencyInput
    wallet?: walletUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type currencyCreateOrConnectWithoutFundraiser_acceptedcurrenciesInput = {
    where: currencyWhereUniqueInput
    create: XOR<currencyCreateWithoutFundraiser_acceptedcurrenciesInput, currencyUncheckedCreateWithoutFundraiser_acceptedcurrenciesInput>
  }

  export type fundraiserUpsertWithoutFundraiser_acceptedcurrenciesInput = {
    update: XOR<fundraiserUpdateWithoutFundraiser_acceptedcurrenciesInput, fundraiserUncheckedUpdateWithoutFundraiser_acceptedcurrenciesInput>
    create: XOR<fundraiserCreateWithoutFundraiser_acceptedcurrenciesInput, fundraiserUncheckedCreateWithoutFundraiser_acceptedcurrenciesInput>
    where?: fundraiserWhereInput
  }

  export type fundraiserUpdateToOneWithWhereWithoutFundraiser_acceptedcurrenciesInput = {
    where?: fundraiserWhereInput
    data: XOR<fundraiserUpdateWithoutFundraiser_acceptedcurrenciesInput, fundraiserUncheckedUpdateWithoutFundraiser_acceptedcurrenciesInput>
  }

  export type fundraiserUpdateWithoutFundraiser_acceptedcurrenciesInput = {
    FundraiserName?: StringFieldUpdateOperationsInput | string
    FundraiserEmail?: StringFieldUpdateOperationsInput | string
    FundraiserLogo?: NullableStringFieldUpdateOperationsInput | string | null
    FundraiserCentralID?: NullableIntFieldUpdateOperationsInput | number | null
    basecountry?: basecountryUpdateOneWithoutFundraiserNestedInput
    fundraiser_contactlinks?: fundraiser_contactlinksUpdateManyWithoutFundraiserNestedInput
  }

  export type fundraiserUncheckedUpdateWithoutFundraiser_acceptedcurrenciesInput = {
    FundraiserID?: IntFieldUpdateOperationsInput | number
    FundraiserName?: StringFieldUpdateOperationsInput | string
    FundraiserEmail?: StringFieldUpdateOperationsInput | string
    FundraiserLogo?: NullableStringFieldUpdateOperationsInput | string | null
    BaseCountryID?: NullableIntFieldUpdateOperationsInput | number | null
    FundraiserCentralID?: NullableIntFieldUpdateOperationsInput | number | null
    fundraiser_contactlinks?: fundraiser_contactlinksUncheckedUpdateManyWithoutFundraiserNestedInput
  }

  export type currencyUpsertWithoutFundraiser_acceptedcurrenciesInput = {
    update: XOR<currencyUpdateWithoutFundraiser_acceptedcurrenciesInput, currencyUncheckedUpdateWithoutFundraiser_acceptedcurrenciesInput>
    create: XOR<currencyCreateWithoutFundraiser_acceptedcurrenciesInput, currencyUncheckedCreateWithoutFundraiser_acceptedcurrenciesInput>
    where?: currencyWhereInput
  }

  export type currencyUpdateToOneWithWhereWithoutFundraiser_acceptedcurrenciesInput = {
    where?: currencyWhereInput
    data: XOR<currencyUpdateWithoutFundraiser_acceptedcurrenciesInput, currencyUncheckedUpdateWithoutFundraiser_acceptedcurrenciesInput>
  }

  export type currencyUpdateWithoutFundraiser_acceptedcurrenciesInput = {
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    exchangerates?: exchangeratesUpdateManyWithoutCurrencyNestedInput
    minimumamount?: minimumamountUpdateManyWithoutCurrencyNestedInput
    wallet?: walletUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyUncheckedUpdateWithoutFundraiser_acceptedcurrenciesInput = {
    CurrencyId?: IntFieldUpdateOperationsInput | number
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    exchangerates?: exchangeratesUncheckedUpdateManyWithoutCurrencyNestedInput
    minimumamount?: minimumamountUncheckedUpdateManyWithoutCurrencyNestedInput
    wallet?: walletUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type fundraiserCreateWithoutFundraiser_contactlinksInput = {
    FundraiserName: string
    FundraiserEmail: string
    FundraiserLogo?: string | null
    FundraiserCentralID?: number | null
    basecountry?: basecountryCreateNestedOneWithoutFundraiserInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesCreateNestedManyWithoutFundraiserInput
  }

  export type fundraiserUncheckedCreateWithoutFundraiser_contactlinksInput = {
    FundraiserID?: number
    FundraiserName: string
    FundraiserEmail: string
    FundraiserLogo?: string | null
    BaseCountryID?: number | null
    FundraiserCentralID?: number | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedCreateNestedManyWithoutFundraiserInput
  }

  export type fundraiserCreateOrConnectWithoutFundraiser_contactlinksInput = {
    where: fundraiserWhereUniqueInput
    create: XOR<fundraiserCreateWithoutFundraiser_contactlinksInput, fundraiserUncheckedCreateWithoutFundraiser_contactlinksInput>
  }

  export type fundraiserUpsertWithoutFundraiser_contactlinksInput = {
    update: XOR<fundraiserUpdateWithoutFundraiser_contactlinksInput, fundraiserUncheckedUpdateWithoutFundraiser_contactlinksInput>
    create: XOR<fundraiserCreateWithoutFundraiser_contactlinksInput, fundraiserUncheckedCreateWithoutFundraiser_contactlinksInput>
    where?: fundraiserWhereInput
  }

  export type fundraiserUpdateToOneWithWhereWithoutFundraiser_contactlinksInput = {
    where?: fundraiserWhereInput
    data: XOR<fundraiserUpdateWithoutFundraiser_contactlinksInput, fundraiserUncheckedUpdateWithoutFundraiser_contactlinksInput>
  }

  export type fundraiserUpdateWithoutFundraiser_contactlinksInput = {
    FundraiserName?: StringFieldUpdateOperationsInput | string
    FundraiserEmail?: StringFieldUpdateOperationsInput | string
    FundraiserLogo?: NullableStringFieldUpdateOperationsInput | string | null
    FundraiserCentralID?: NullableIntFieldUpdateOperationsInput | number | null
    basecountry?: basecountryUpdateOneWithoutFundraiserNestedInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUpdateManyWithoutFundraiserNestedInput
  }

  export type fundraiserUncheckedUpdateWithoutFundraiser_contactlinksInput = {
    FundraiserID?: IntFieldUpdateOperationsInput | number
    FundraiserName?: StringFieldUpdateOperationsInput | string
    FundraiserEmail?: StringFieldUpdateOperationsInput | string
    FundraiserLogo?: NullableStringFieldUpdateOperationsInput | string | null
    BaseCountryID?: NullableIntFieldUpdateOperationsInput | number | null
    FundraiserCentralID?: NullableIntFieldUpdateOperationsInput | number | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutFundraiserNestedInput
  }

  export type customerCreateWithoutManychatInput = {
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    CardID?: number | null
    agent?: agentCreateNestedOneWithoutCustomerInput
    customerauditlogs?: customerauditlogsCreateNestedManyWithoutCustomerInput
    transactions?: transactionsCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutManychatInput = {
    CustomerId?: number
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    AgentId?: number | null
    CardID?: number | null
    customerauditlogs?: customerauditlogsUncheckedCreateNestedManyWithoutCustomerInput
    transactions?: transactionsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutManychatInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutManychatInput, customerUncheckedCreateWithoutManychatInput>
  }

  export type customerUpsertWithoutManychatInput = {
    update: XOR<customerUpdateWithoutManychatInput, customerUncheckedUpdateWithoutManychatInput>
    create: XOR<customerCreateWithoutManychatInput, customerUncheckedCreateWithoutManychatInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutManychatInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutManychatInput, customerUncheckedUpdateWithoutManychatInput>
  }

  export type customerUpdateWithoutManychatInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
    agent?: agentUpdateOneWithoutCustomerNestedInput
    customerauditlogs?: customerauditlogsUpdateManyWithoutCustomerNestedInput
    transactions?: transactionsUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutManychatInput = {
    CustomerId?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
    customerauditlogs?: customerauditlogsUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type currencyCreateWithoutMinimumamountInput = {
    CurrencyCode?: string | null
    exchangerates?: exchangeratesCreateNestedManyWithoutCurrencyInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesCreateNestedManyWithoutCurrencyInput
    wallet?: walletCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUncheckedCreateWithoutMinimumamountInput = {
    CurrencyId?: number
    CurrencyCode?: string | null
    exchangerates?: exchangeratesUncheckedCreateNestedManyWithoutCurrencyInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedCreateNestedManyWithoutCurrencyInput
    wallet?: walletUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type currencyCreateOrConnectWithoutMinimumamountInput = {
    where: currencyWhereUniqueInput
    create: XOR<currencyCreateWithoutMinimumamountInput, currencyUncheckedCreateWithoutMinimumamountInput>
  }

  export type currencyUpsertWithoutMinimumamountInput = {
    update: XOR<currencyUpdateWithoutMinimumamountInput, currencyUncheckedUpdateWithoutMinimumamountInput>
    create: XOR<currencyCreateWithoutMinimumamountInput, currencyUncheckedCreateWithoutMinimumamountInput>
    where?: currencyWhereInput
  }

  export type currencyUpdateToOneWithWhereWithoutMinimumamountInput = {
    where?: currencyWhereInput
    data: XOR<currencyUpdateWithoutMinimumamountInput, currencyUncheckedUpdateWithoutMinimumamountInput>
  }

  export type currencyUpdateWithoutMinimumamountInput = {
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    exchangerates?: exchangeratesUpdateManyWithoutCurrencyNestedInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUpdateManyWithoutCurrencyNestedInput
    wallet?: walletUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyUncheckedUpdateWithoutMinimumamountInput = {
    CurrencyId?: IntFieldUpdateOperationsInput | number
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    exchangerates?: exchangeratesUncheckedUpdateManyWithoutCurrencyNestedInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutCurrencyNestedInput
    wallet?: walletUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type agentCreateWithoutNoteInput = {
    AwsId?: string | null
    userrole?: userroleCreateNestedOneWithoutAgentInput
    customer?: customerCreateNestedManyWithoutAgentInput
    customerauditlogs?: customerauditlogsCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentCreateNestedManyWithoutAgentInput
  }

  export type agentUncheckedCreateWithoutNoteInput = {
    AgentId?: number
    AwsId?: string | null
    UserRoleId?: number | null
    customer?: customerUncheckedCreateNestedManyWithoutAgentInput
    customerauditlogs?: customerauditlogsUncheckedCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusUncheckedCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type agentCreateOrConnectWithoutNoteInput = {
    where: agentWhereUniqueInput
    create: XOR<agentCreateWithoutNoteInput, agentUncheckedCreateWithoutNoteInput>
  }

  export type transactionsCreateWithoutNoteInput = {
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentCreateNestedManyWithoutTransactionsInput
    customer?: customerCreateNestedOneWithoutTransactionsInput
    supportregion?: supportregionCreateNestedOneWithoutTransactionsInput
    wallet?: walletCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutNoteInput = {
    TransactionID?: number
    CustomerID?: number | null
    SupportRegionID?: number | null
    WalletID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusUncheckedCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotUncheckedCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsCreateOrConnectWithoutNoteInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutNoteInput, transactionsUncheckedCreateWithoutNoteInput>
  }

  export type transactionsCreateManyNoteInputEnvelope = {
    data: transactionsCreateManyNoteInput | transactionsCreateManyNoteInput[]
    skipDuplicates?: boolean
  }

  export type agentUpsertWithoutNoteInput = {
    update: XOR<agentUpdateWithoutNoteInput, agentUncheckedUpdateWithoutNoteInput>
    create: XOR<agentCreateWithoutNoteInput, agentUncheckedCreateWithoutNoteInput>
    where?: agentWhereInput
  }

  export type agentUpdateToOneWithWhereWithoutNoteInput = {
    where?: agentWhereInput
    data: XOR<agentUpdateWithoutNoteInput, agentUncheckedUpdateWithoutNoteInput>
  }

  export type agentUpdateWithoutNoteInput = {
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    userrole?: userroleUpdateOneWithoutAgentNestedInput
    customer?: customerUpdateManyWithoutAgentNestedInput
    customerauditlogs?: customerauditlogsUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUpdateManyWithoutAgentNestedInput
  }

  export type agentUncheckedUpdateWithoutNoteInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    UserRoleId?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: customerUncheckedUpdateManyWithoutAgentNestedInput
    customerauditlogs?: customerauditlogsUncheckedUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUncheckedUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type transactionsUpsertWithWhereUniqueWithoutNoteInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutNoteInput, transactionsUncheckedUpdateWithoutNoteInput>
    create: XOR<transactionsCreateWithoutNoteInput, transactionsUncheckedCreateWithoutNoteInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutNoteInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutNoteInput, transactionsUncheckedUpdateWithoutNoteInput>
  }

  export type transactionsUpdateManyWithWhereWithoutNoteInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutNoteInput>
  }

  export type transactionsCreateWithoutScreenshotInput = {
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentCreateNestedManyWithoutTransactionsInput
    customer?: customerCreateNestedOneWithoutTransactionsInput
    supportregion?: supportregionCreateNestedOneWithoutTransactionsInput
    wallet?: walletCreateNestedOneWithoutTransactionsInput
    note?: noteCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutScreenshotInput = {
    TransactionID?: number
    CustomerID?: number | null
    SupportRegionID?: number | null
    WalletID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    NoteID?: number | null
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusUncheckedCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsCreateOrConnectWithoutScreenshotInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutScreenshotInput, transactionsUncheckedCreateWithoutScreenshotInput>
  }

  export type transactionsUpsertWithoutScreenshotInput = {
    update: XOR<transactionsUpdateWithoutScreenshotInput, transactionsUncheckedUpdateWithoutScreenshotInput>
    create: XOR<transactionsCreateWithoutScreenshotInput, transactionsUncheckedCreateWithoutScreenshotInput>
    where?: transactionsWhereInput
  }

  export type transactionsUpdateToOneWithWhereWithoutScreenshotInput = {
    where?: transactionsWhereInput
    data: XOR<transactionsUpdateWithoutScreenshotInput, transactionsUncheckedUpdateWithoutScreenshotInput>
  }

  export type transactionsUpdateWithoutScreenshotInput = {
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUpdateManyWithoutTransactionsNestedInput
    customer?: customerUpdateOneWithoutTransactionsNestedInput
    supportregion?: supportregionUpdateOneWithoutTransactionsNestedInput
    wallet?: walletUpdateOneWithoutTransactionsNestedInput
    note?: noteUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutScreenshotInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    SupportRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    WalletID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NoteID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUncheckedUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type transactionsCreateWithoutSupportregionInput = {
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentCreateNestedManyWithoutTransactionsInput
    customer?: customerCreateNestedOneWithoutTransactionsInput
    wallet?: walletCreateNestedOneWithoutTransactionsInput
    note?: noteCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutSupportregionInput = {
    TransactionID?: number
    CustomerID?: number | null
    WalletID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    NoteID?: number | null
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusUncheckedCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotUncheckedCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsCreateOrConnectWithoutSupportregionInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutSupportregionInput, transactionsUncheckedCreateWithoutSupportregionInput>
  }

  export type transactionsCreateManySupportregionInputEnvelope = {
    data: transactionsCreateManySupportregionInput | transactionsCreateManySupportregionInput[]
    skipDuplicates?: boolean
  }

  export type transactionsUpsertWithWhereUniqueWithoutSupportregionInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutSupportregionInput, transactionsUncheckedUpdateWithoutSupportregionInput>
    create: XOR<transactionsCreateWithoutSupportregionInput, transactionsUncheckedCreateWithoutSupportregionInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutSupportregionInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutSupportregionInput, transactionsUncheckedUpdateWithoutSupportregionInput>
  }

  export type transactionsUpdateManyWithWhereWithoutSupportregionInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutSupportregionInput>
  }

  export type transactionsCreateWithoutTransactionagentInput = {
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotCreateNestedManyWithoutTransactionsInput
    customer?: customerCreateNestedOneWithoutTransactionsInput
    supportregion?: supportregionCreateNestedOneWithoutTransactionsInput
    wallet?: walletCreateNestedOneWithoutTransactionsInput
    note?: noteCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutTransactionagentInput = {
    TransactionID?: number
    CustomerID?: number | null
    SupportRegionID?: number | null
    WalletID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    NoteID?: number | null
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusUncheckedCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsCreateOrConnectWithoutTransactionagentInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutTransactionagentInput, transactionsUncheckedCreateWithoutTransactionagentInput>
  }

  export type agentCreateWithoutTransactionagentInput = {
    AwsId?: string | null
    userrole?: userroleCreateNestedOneWithoutAgentInput
    customer?: customerCreateNestedManyWithoutAgentInput
    customerauditlogs?: customerauditlogsCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusCreateNestedManyWithoutAgentInput
    note?: noteCreateNestedManyWithoutAgentInput
  }

  export type agentUncheckedCreateWithoutTransactionagentInput = {
    AgentId?: number
    AwsId?: string | null
    UserRoleId?: number | null
    customer?: customerUncheckedCreateNestedManyWithoutAgentInput
    customerauditlogs?: customerauditlogsUncheckedCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusUncheckedCreateNestedManyWithoutAgentInput
    note?: noteUncheckedCreateNestedManyWithoutAgentInput
  }

  export type agentCreateOrConnectWithoutTransactionagentInput = {
    where: agentWhereUniqueInput
    create: XOR<agentCreateWithoutTransactionagentInput, agentUncheckedCreateWithoutTransactionagentInput>
  }

  export type transactionsUpsertWithoutTransactionagentInput = {
    update: XOR<transactionsUpdateWithoutTransactionagentInput, transactionsUncheckedUpdateWithoutTransactionagentInput>
    create: XOR<transactionsCreateWithoutTransactionagentInput, transactionsUncheckedCreateWithoutTransactionagentInput>
    where?: transactionsWhereInput
  }

  export type transactionsUpdateToOneWithWhereWithoutTransactionagentInput = {
    where?: transactionsWhereInput
    data: XOR<transactionsUpdateWithoutTransactionagentInput, transactionsUncheckedUpdateWithoutTransactionagentInput>
  }

  export type transactionsUpdateWithoutTransactionagentInput = {
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUpdateManyWithoutTransactionsNestedInput
    customer?: customerUpdateOneWithoutTransactionsNestedInput
    supportregion?: supportregionUpdateOneWithoutTransactionsNestedInput
    wallet?: walletUpdateOneWithoutTransactionsNestedInput
    note?: noteUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutTransactionagentInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    SupportRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    WalletID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NoteID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUncheckedUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type agentUpsertWithoutTransactionagentInput = {
    update: XOR<agentUpdateWithoutTransactionagentInput, agentUncheckedUpdateWithoutTransactionagentInput>
    create: XOR<agentCreateWithoutTransactionagentInput, agentUncheckedCreateWithoutTransactionagentInput>
    where?: agentWhereInput
  }

  export type agentUpdateToOneWithWhereWithoutTransactionagentInput = {
    where?: agentWhereInput
    data: XOR<agentUpdateWithoutTransactionagentInput, agentUncheckedUpdateWithoutTransactionagentInput>
  }

  export type agentUpdateWithoutTransactionagentInput = {
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    userrole?: userroleUpdateOneWithoutAgentNestedInput
    customer?: customerUpdateManyWithoutAgentNestedInput
    customerauditlogs?: customerauditlogsUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUpdateManyWithoutAgentNestedInput
    note?: noteUpdateManyWithoutAgentNestedInput
  }

  export type agentUncheckedUpdateWithoutTransactionagentInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    UserRoleId?: NullableIntFieldUpdateOperationsInput | number | null
    customer?: customerUncheckedUpdateManyWithoutAgentNestedInput
    customerauditlogs?: customerauditlogsUncheckedUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUncheckedUpdateManyWithoutAgentNestedInput
    note?: noteUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type formstatusCreateWithoutTransactionsInput = {
    transactionstatus?: transactionstatusCreateNestedOneWithoutFormstatusInput
  }

  export type formstatusUncheckedCreateWithoutTransactionsInput = {
    FormStatusID?: number
    TransactionStatusID?: number | null
  }

  export type formstatusCreateOrConnectWithoutTransactionsInput = {
    where: formstatusWhereUniqueInput
    create: XOR<formstatusCreateWithoutTransactionsInput, formstatusUncheckedCreateWithoutTransactionsInput>
  }

  export type formstatusCreateManyTransactionsInputEnvelope = {
    data: formstatusCreateManyTransactionsInput | formstatusCreateManyTransactionsInput[]
    skipDuplicates?: boolean
  }

  export type screenshotCreateWithoutTransactionsInput = {
    ScreenShotLink?: string | null
  }

  export type screenshotUncheckedCreateWithoutTransactionsInput = {
    ScreenShotID?: number
    ScreenShotLink?: string | null
  }

  export type screenshotCreateOrConnectWithoutTransactionsInput = {
    where: screenshotWhereUniqueInput
    create: XOR<screenshotCreateWithoutTransactionsInput, screenshotUncheckedCreateWithoutTransactionsInput>
  }

  export type screenshotCreateManyTransactionsInputEnvelope = {
    data: screenshotCreateManyTransactionsInput | screenshotCreateManyTransactionsInput[]
    skipDuplicates?: boolean
  }

  export type transactionagentCreateWithoutTransactionsInput = {
    LogDate?: Date | string
    agent?: agentCreateNestedOneWithoutTransactionagentInput
  }

  export type transactionagentUncheckedCreateWithoutTransactionsInput = {
    TransactionAgentID?: number
    AgentID?: number | null
    LogDate?: Date | string
  }

  export type transactionagentCreateOrConnectWithoutTransactionsInput = {
    where: transactionagentWhereUniqueInput
    create: XOR<transactionagentCreateWithoutTransactionsInput, transactionagentUncheckedCreateWithoutTransactionsInput>
  }

  export type transactionagentCreateManyTransactionsInputEnvelope = {
    data: transactionagentCreateManyTransactionsInput | transactionagentCreateManyTransactionsInput[]
    skipDuplicates?: boolean
  }

  export type customerCreateWithoutTransactionsInput = {
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    CardID?: number | null
    agent?: agentCreateNestedOneWithoutCustomerInput
    customerauditlogs?: customerauditlogsCreateNestedManyWithoutCustomerInput
    manychat?: manychatCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutTransactionsInput = {
    CustomerId?: number
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    AgentId?: number | null
    CardID?: number | null
    customerauditlogs?: customerauditlogsUncheckedCreateNestedManyWithoutCustomerInput
    manychat?: manychatUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutTransactionsInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutTransactionsInput, customerUncheckedCreateWithoutTransactionsInput>
  }

  export type supportregionCreateWithoutTransactionsInput = {
    Region?: string | null
  }

  export type supportregionUncheckedCreateWithoutTransactionsInput = {
    SupportRegionID?: number
    Region?: string | null
  }

  export type supportregionCreateOrConnectWithoutTransactionsInput = {
    where: supportregionWhereUniqueInput
    create: XOR<supportregionCreateWithoutTransactionsInput, supportregionUncheckedCreateWithoutTransactionsInput>
  }

  export type walletCreateWithoutTransactionsInput = {
    WalletName?: string | null
    currency?: currencyCreateNestedOneWithoutWalletInput
  }

  export type walletUncheckedCreateWithoutTransactionsInput = {
    WalletId?: number
    CurrencyId?: number | null
    WalletName?: string | null
  }

  export type walletCreateOrConnectWithoutTransactionsInput = {
    where: walletWhereUniqueInput
    create: XOR<walletCreateWithoutTransactionsInput, walletUncheckedCreateWithoutTransactionsInput>
  }

  export type noteCreateWithoutTransactionsInput = {
    Note?: string | null
    Date?: Date | string | null
    agent?: agentCreateNestedOneWithoutNoteInput
  }

  export type noteUncheckedCreateWithoutTransactionsInput = {
    NoteID?: number
    Note?: string | null
    Date?: Date | string | null
    AgentID?: number | null
  }

  export type noteCreateOrConnectWithoutTransactionsInput = {
    where: noteWhereUniqueInput
    create: XOR<noteCreateWithoutTransactionsInput, noteUncheckedCreateWithoutTransactionsInput>
  }

  export type formstatusUpsertWithWhereUniqueWithoutTransactionsInput = {
    where: formstatusWhereUniqueInput
    update: XOR<formstatusUpdateWithoutTransactionsInput, formstatusUncheckedUpdateWithoutTransactionsInput>
    create: XOR<formstatusCreateWithoutTransactionsInput, formstatusUncheckedCreateWithoutTransactionsInput>
  }

  export type formstatusUpdateWithWhereUniqueWithoutTransactionsInput = {
    where: formstatusWhereUniqueInput
    data: XOR<formstatusUpdateWithoutTransactionsInput, formstatusUncheckedUpdateWithoutTransactionsInput>
  }

  export type formstatusUpdateManyWithWhereWithoutTransactionsInput = {
    where: formstatusScalarWhereInput
    data: XOR<formstatusUpdateManyMutationInput, formstatusUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type formstatusScalarWhereInput = {
    AND?: formstatusScalarWhereInput | formstatusScalarWhereInput[]
    OR?: formstatusScalarWhereInput[]
    NOT?: formstatusScalarWhereInput | formstatusScalarWhereInput[]
    FormStatusID?: IntFilter<"formstatus"> | number
    TransactionID?: IntNullableFilter<"formstatus"> | number | null
    TransactionStatusID?: IntNullableFilter<"formstatus"> | number | null
  }

  export type screenshotUpsertWithWhereUniqueWithoutTransactionsInput = {
    where: screenshotWhereUniqueInput
    update: XOR<screenshotUpdateWithoutTransactionsInput, screenshotUncheckedUpdateWithoutTransactionsInput>
    create: XOR<screenshotCreateWithoutTransactionsInput, screenshotUncheckedCreateWithoutTransactionsInput>
  }

  export type screenshotUpdateWithWhereUniqueWithoutTransactionsInput = {
    where: screenshotWhereUniqueInput
    data: XOR<screenshotUpdateWithoutTransactionsInput, screenshotUncheckedUpdateWithoutTransactionsInput>
  }

  export type screenshotUpdateManyWithWhereWithoutTransactionsInput = {
    where: screenshotScalarWhereInput
    data: XOR<screenshotUpdateManyMutationInput, screenshotUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type screenshotScalarWhereInput = {
    AND?: screenshotScalarWhereInput | screenshotScalarWhereInput[]
    OR?: screenshotScalarWhereInput[]
    NOT?: screenshotScalarWhereInput | screenshotScalarWhereInput[]
    ScreenShotID?: IntFilter<"screenshot"> | number
    TransactionID?: IntNullableFilter<"screenshot"> | number | null
    ScreenShotLink?: StringNullableFilter<"screenshot"> | string | null
  }

  export type transactionagentUpsertWithWhereUniqueWithoutTransactionsInput = {
    where: transactionagentWhereUniqueInput
    update: XOR<transactionagentUpdateWithoutTransactionsInput, transactionagentUncheckedUpdateWithoutTransactionsInput>
    create: XOR<transactionagentCreateWithoutTransactionsInput, transactionagentUncheckedCreateWithoutTransactionsInput>
  }

  export type transactionagentUpdateWithWhereUniqueWithoutTransactionsInput = {
    where: transactionagentWhereUniqueInput
    data: XOR<transactionagentUpdateWithoutTransactionsInput, transactionagentUncheckedUpdateWithoutTransactionsInput>
  }

  export type transactionagentUpdateManyWithWhereWithoutTransactionsInput = {
    where: transactionagentScalarWhereInput
    data: XOR<transactionagentUpdateManyMutationInput, transactionagentUncheckedUpdateManyWithoutTransactionsInput>
  }

  export type customerUpsertWithoutTransactionsInput = {
    update: XOR<customerUpdateWithoutTransactionsInput, customerUncheckedUpdateWithoutTransactionsInput>
    create: XOR<customerCreateWithoutTransactionsInput, customerUncheckedCreateWithoutTransactionsInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutTransactionsInput, customerUncheckedUpdateWithoutTransactionsInput>
  }

  export type customerUpdateWithoutTransactionsInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
    agent?: agentUpdateOneWithoutCustomerNestedInput
    customerauditlogs?: customerauditlogsUpdateManyWithoutCustomerNestedInput
    manychat?: manychatUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutTransactionsInput = {
    CustomerId?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    AgentId?: NullableIntFieldUpdateOperationsInput | number | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
    customerauditlogs?: customerauditlogsUncheckedUpdateManyWithoutCustomerNestedInput
    manychat?: manychatUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type supportregionUpsertWithoutTransactionsInput = {
    update: XOR<supportregionUpdateWithoutTransactionsInput, supportregionUncheckedUpdateWithoutTransactionsInput>
    create: XOR<supportregionCreateWithoutTransactionsInput, supportregionUncheckedCreateWithoutTransactionsInput>
    where?: supportregionWhereInput
  }

  export type supportregionUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: supportregionWhereInput
    data: XOR<supportregionUpdateWithoutTransactionsInput, supportregionUncheckedUpdateWithoutTransactionsInput>
  }

  export type supportregionUpdateWithoutTransactionsInput = {
    Region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type supportregionUncheckedUpdateWithoutTransactionsInput = {
    SupportRegionID?: IntFieldUpdateOperationsInput | number
    Region?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type walletUpsertWithoutTransactionsInput = {
    update: XOR<walletUpdateWithoutTransactionsInput, walletUncheckedUpdateWithoutTransactionsInput>
    create: XOR<walletCreateWithoutTransactionsInput, walletUncheckedCreateWithoutTransactionsInput>
    where?: walletWhereInput
  }

  export type walletUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: walletWhereInput
    data: XOR<walletUpdateWithoutTransactionsInput, walletUncheckedUpdateWithoutTransactionsInput>
  }

  export type walletUpdateWithoutTransactionsInput = {
    WalletName?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: currencyUpdateOneWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateWithoutTransactionsInput = {
    WalletId?: IntFieldUpdateOperationsInput | number
    CurrencyId?: NullableIntFieldUpdateOperationsInput | number | null
    WalletName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type noteUpsertWithoutTransactionsInput = {
    update: XOR<noteUpdateWithoutTransactionsInput, noteUncheckedUpdateWithoutTransactionsInput>
    create: XOR<noteCreateWithoutTransactionsInput, noteUncheckedCreateWithoutTransactionsInput>
    where?: noteWhereInput
  }

  export type noteUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: noteWhereInput
    data: XOR<noteUpdateWithoutTransactionsInput, noteUncheckedUpdateWithoutTransactionsInput>
  }

  export type noteUpdateWithoutTransactionsInput = {
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agent?: agentUpdateOneWithoutNoteNestedInput
  }

  export type noteUncheckedUpdateWithoutTransactionsInput = {
    NoteID?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    AgentID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type formstatusCreateWithoutTransactionstatusInput = {
    transactions?: transactionsCreateNestedOneWithoutFormstatusInput
  }

  export type formstatusUncheckedCreateWithoutTransactionstatusInput = {
    FormStatusID?: number
    TransactionID?: number | null
  }

  export type formstatusCreateOrConnectWithoutTransactionstatusInput = {
    where: formstatusWhereUniqueInput
    create: XOR<formstatusCreateWithoutTransactionstatusInput, formstatusUncheckedCreateWithoutTransactionstatusInput>
  }

  export type formstatusCreateManyTransactionstatusInputEnvelope = {
    data: formstatusCreateManyTransactionstatusInput | formstatusCreateManyTransactionstatusInput[]
    skipDuplicates?: boolean
  }

  export type formstatusUpsertWithWhereUniqueWithoutTransactionstatusInput = {
    where: formstatusWhereUniqueInput
    update: XOR<formstatusUpdateWithoutTransactionstatusInput, formstatusUncheckedUpdateWithoutTransactionstatusInput>
    create: XOR<formstatusCreateWithoutTransactionstatusInput, formstatusUncheckedCreateWithoutTransactionstatusInput>
  }

  export type formstatusUpdateWithWhereUniqueWithoutTransactionstatusInput = {
    where: formstatusWhereUniqueInput
    data: XOR<formstatusUpdateWithoutTransactionstatusInput, formstatusUncheckedUpdateWithoutTransactionstatusInput>
  }

  export type formstatusUpdateManyWithWhereWithoutTransactionstatusInput = {
    where: formstatusScalarWhereInput
    data: XOR<formstatusUpdateManyMutationInput, formstatusUncheckedUpdateManyWithoutTransactionstatusInput>
  }

  export type agentCreateWithoutUserroleInput = {
    AwsId?: string | null
    customer?: customerCreateNestedManyWithoutAgentInput
    customerauditlogs?: customerauditlogsCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusCreateNestedManyWithoutAgentInput
    note?: noteCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentCreateNestedManyWithoutAgentInput
  }

  export type agentUncheckedCreateWithoutUserroleInput = {
    AgentId?: number
    AwsId?: string | null
    customer?: customerUncheckedCreateNestedManyWithoutAgentInput
    customerauditlogs?: customerauditlogsUncheckedCreateNestedManyWithoutAgentInput
    formvisibilitystatus?: formvisibilitystatusUncheckedCreateNestedManyWithoutAgentInput
    note?: noteUncheckedCreateNestedManyWithoutAgentInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type agentCreateOrConnectWithoutUserroleInput = {
    where: agentWhereUniqueInput
    create: XOR<agentCreateWithoutUserroleInput, agentUncheckedCreateWithoutUserroleInput>
  }

  export type agentCreateManyUserroleInputEnvelope = {
    data: agentCreateManyUserroleInput | agentCreateManyUserroleInput[]
    skipDuplicates?: boolean
  }

  export type agentUpsertWithWhereUniqueWithoutUserroleInput = {
    where: agentWhereUniqueInput
    update: XOR<agentUpdateWithoutUserroleInput, agentUncheckedUpdateWithoutUserroleInput>
    create: XOR<agentCreateWithoutUserroleInput, agentUncheckedCreateWithoutUserroleInput>
  }

  export type agentUpdateWithWhereUniqueWithoutUserroleInput = {
    where: agentWhereUniqueInput
    data: XOR<agentUpdateWithoutUserroleInput, agentUncheckedUpdateWithoutUserroleInput>
  }

  export type agentUpdateManyWithWhereWithoutUserroleInput = {
    where: agentScalarWhereInput
    data: XOR<agentUpdateManyMutationInput, agentUncheckedUpdateManyWithoutUserroleInput>
  }

  export type agentScalarWhereInput = {
    AND?: agentScalarWhereInput | agentScalarWhereInput[]
    OR?: agentScalarWhereInput[]
    NOT?: agentScalarWhereInput | agentScalarWhereInput[]
    AgentId?: IntFilter<"agent"> | number
    AwsId?: StringNullableFilter<"agent"> | string | null
    UserRoleId?: IntNullableFilter<"agent"> | number | null
  }

  export type transactionsCreateWithoutWalletInput = {
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentCreateNestedManyWithoutTransactionsInput
    customer?: customerCreateNestedOneWithoutTransactionsInput
    supportregion?: supportregionCreateNestedOneWithoutTransactionsInput
    note?: noteCreateNestedOneWithoutTransactionsInput
  }

  export type transactionsUncheckedCreateWithoutWalletInput = {
    TransactionID?: number
    CustomerID?: number | null
    SupportRegionID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    NoteID?: number | null
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
    formstatus?: formstatusUncheckedCreateNestedManyWithoutTransactionsInput
    screenshot?: screenshotUncheckedCreateNestedManyWithoutTransactionsInput
    transactionagent?: transactionagentUncheckedCreateNestedManyWithoutTransactionsInput
  }

  export type transactionsCreateOrConnectWithoutWalletInput = {
    where: transactionsWhereUniqueInput
    create: XOR<transactionsCreateWithoutWalletInput, transactionsUncheckedCreateWithoutWalletInput>
  }

  export type transactionsCreateManyWalletInputEnvelope = {
    data: transactionsCreateManyWalletInput | transactionsCreateManyWalletInput[]
    skipDuplicates?: boolean
  }

  export type currencyCreateWithoutWalletInput = {
    CurrencyCode?: string | null
    exchangerates?: exchangeratesCreateNestedManyWithoutCurrencyInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesCreateNestedManyWithoutCurrencyInput
    minimumamount?: minimumamountCreateNestedManyWithoutCurrencyInput
  }

  export type currencyUncheckedCreateWithoutWalletInput = {
    CurrencyId?: number
    CurrencyCode?: string | null
    exchangerates?: exchangeratesUncheckedCreateNestedManyWithoutCurrencyInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedCreateNestedManyWithoutCurrencyInput
    minimumamount?: minimumamountUncheckedCreateNestedManyWithoutCurrencyInput
  }

  export type currencyCreateOrConnectWithoutWalletInput = {
    where: currencyWhereUniqueInput
    create: XOR<currencyCreateWithoutWalletInput, currencyUncheckedCreateWithoutWalletInput>
  }

  export type transactionsUpsertWithWhereUniqueWithoutWalletInput = {
    where: transactionsWhereUniqueInput
    update: XOR<transactionsUpdateWithoutWalletInput, transactionsUncheckedUpdateWithoutWalletInput>
    create: XOR<transactionsCreateWithoutWalletInput, transactionsUncheckedCreateWithoutWalletInput>
  }

  export type transactionsUpdateWithWhereUniqueWithoutWalletInput = {
    where: transactionsWhereUniqueInput
    data: XOR<transactionsUpdateWithoutWalletInput, transactionsUncheckedUpdateWithoutWalletInput>
  }

  export type transactionsUpdateManyWithWhereWithoutWalletInput = {
    where: transactionsScalarWhereInput
    data: XOR<transactionsUpdateManyMutationInput, transactionsUncheckedUpdateManyWithoutWalletInput>
  }

  export type currencyUpsertWithoutWalletInput = {
    update: XOR<currencyUpdateWithoutWalletInput, currencyUncheckedUpdateWithoutWalletInput>
    create: XOR<currencyCreateWithoutWalletInput, currencyUncheckedCreateWithoutWalletInput>
    where?: currencyWhereInput
  }

  export type currencyUpdateToOneWithWhereWithoutWalletInput = {
    where?: currencyWhereInput
    data: XOR<currencyUpdateWithoutWalletInput, currencyUncheckedUpdateWithoutWalletInput>
  }

  export type currencyUpdateWithoutWalletInput = {
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    exchangerates?: exchangeratesUpdateManyWithoutCurrencyNestedInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUpdateManyWithoutCurrencyNestedInput
    minimumamount?: minimumamountUpdateManyWithoutCurrencyNestedInput
  }

  export type currencyUncheckedUpdateWithoutWalletInput = {
    CurrencyId?: IntFieldUpdateOperationsInput | number
    CurrencyCode?: NullableStringFieldUpdateOperationsInput | string | null
    exchangerates?: exchangeratesUncheckedUpdateManyWithoutCurrencyNestedInput
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutCurrencyNestedInput
    minimumamount?: minimumamountUncheckedUpdateManyWithoutCurrencyNestedInput
  }

  export type customerCreateManyAgentInput = {
    CustomerId?: number
    Name?: string | null
    Email?: string | null
    ManyChatId?: string | null
    ExpireDate?: Date | string | null
    UserCountry?: string | null
    ContactLink?: string | null
    CardID?: number | null
  }

  export type customerauditlogsCreateManyAgentInput = {
    LogId?: number
    FieldChanged: $Enums.customerauditlogs_FieldChanged
    OldValue?: string | null
    NewValue?: string | null
    CustomerId: number
    ChangeDate?: Date | string
  }

  export type formvisibilitystatusCreateManyAgentInput = {
    VisibilityStatusId?: number
    IsFormOpen: boolean
    FormTimeStamp?: Date | string
  }

  export type noteCreateManyAgentInput = {
    NoteID?: number
    Note?: string | null
    Date?: Date | string | null
  }

  export type transactionagentCreateManyAgentInput = {
    TransactionAgentID?: number
    TransactionID?: number | null
    LogDate?: Date | string
  }

  export type customerUpdateWithoutAgentInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
    customerauditlogs?: customerauditlogsUpdateManyWithoutCustomerNestedInput
    manychat?: manychatUpdateManyWithoutCustomerNestedInput
    transactions?: transactionsUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutAgentInput = {
    CustomerId?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
    customerauditlogs?: customerauditlogsUncheckedUpdateManyWithoutCustomerNestedInput
    manychat?: manychatUncheckedUpdateManyWithoutCustomerNestedInput
    transactions?: transactionsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateManyWithoutAgentInput = {
    CustomerId?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    ManyChatId?: NullableStringFieldUpdateOperationsInput | string | null
    ExpireDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    UserCountry?: NullableStringFieldUpdateOperationsInput | string | null
    ContactLink?: NullableStringFieldUpdateOperationsInput | string | null
    CardID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type customerauditlogsUpdateWithoutAgentInput = {
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFieldUpdateOperationsInput | $Enums.customerauditlogs_FieldChanged
    OldValue?: NullableStringFieldUpdateOperationsInput | string | null
    NewValue?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUpdateOneRequiredWithoutCustomerauditlogsNestedInput
  }

  export type customerauditlogsUncheckedUpdateWithoutAgentInput = {
    LogId?: IntFieldUpdateOperationsInput | number
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFieldUpdateOperationsInput | $Enums.customerauditlogs_FieldChanged
    OldValue?: NullableStringFieldUpdateOperationsInput | string | null
    NewValue?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: IntFieldUpdateOperationsInput | number
    ChangeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerauditlogsUncheckedUpdateManyWithoutAgentInput = {
    LogId?: IntFieldUpdateOperationsInput | number
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFieldUpdateOperationsInput | $Enums.customerauditlogs_FieldChanged
    OldValue?: NullableStringFieldUpdateOperationsInput | string | null
    NewValue?: NullableStringFieldUpdateOperationsInput | string | null
    CustomerId?: IntFieldUpdateOperationsInput | number
    ChangeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formvisibilitystatusUpdateWithoutAgentInput = {
    IsFormOpen?: BoolFieldUpdateOperationsInput | boolean
    FormTimeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formvisibilitystatusUncheckedUpdateWithoutAgentInput = {
    VisibilityStatusId?: IntFieldUpdateOperationsInput | number
    IsFormOpen?: BoolFieldUpdateOperationsInput | boolean
    FormTimeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formvisibilitystatusUncheckedUpdateManyWithoutAgentInput = {
    VisibilityStatusId?: IntFieldUpdateOperationsInput | number
    IsFormOpen?: BoolFieldUpdateOperationsInput | boolean
    FormTimeStamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type noteUpdateWithoutAgentInput = {
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: transactionsUpdateManyWithoutNoteNestedInput
  }

  export type noteUncheckedUpdateWithoutAgentInput = {
    NoteID?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transactions?: transactionsUncheckedUpdateManyWithoutNoteNestedInput
  }

  export type noteUncheckedUpdateManyWithoutAgentInput = {
    NoteID?: IntFieldUpdateOperationsInput | number
    Note?: NullableStringFieldUpdateOperationsInput | string | null
    Date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type transactionagentUpdateWithoutAgentInput = {
    LogDate?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: transactionsUpdateOneWithoutTransactionagentNestedInput
  }

  export type transactionagentUncheckedUpdateWithoutAgentInput = {
    TransactionAgentID?: IntFieldUpdateOperationsInput | number
    TransactionID?: NullableIntFieldUpdateOperationsInput | number | null
    LogDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionagentUncheckedUpdateManyWithoutAgentInput = {
    TransactionAgentID?: IntFieldUpdateOperationsInput | number
    TransactionID?: NullableIntFieldUpdateOperationsInput | number | null
    LogDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchangeratesCreateManyBasecountryInput = {
    ExchangeRateId?: number
    CurrencyId: number
    ExchangeRate: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type fundraiserCreateManyBasecountryInput = {
    FundraiserID?: number
    FundraiserName: string
    FundraiserEmail: string
    FundraiserLogo?: string | null
    FundraiserCentralID?: number | null
  }

  export type exchangeratesUpdateWithoutBasecountryInput = {
    ExchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    currency?: currencyUpdateOneRequiredWithoutExchangeratesNestedInput
  }

  export type exchangeratesUncheckedUpdateWithoutBasecountryInput = {
    ExchangeRateId?: IntFieldUpdateOperationsInput | number
    CurrencyId?: IntFieldUpdateOperationsInput | number
    ExchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchangeratesUncheckedUpdateManyWithoutBasecountryInput = {
    ExchangeRateId?: IntFieldUpdateOperationsInput | number
    CurrencyId?: IntFieldUpdateOperationsInput | number
    ExchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fundraiserUpdateWithoutBasecountryInput = {
    FundraiserName?: StringFieldUpdateOperationsInput | string
    FundraiserEmail?: StringFieldUpdateOperationsInput | string
    FundraiserLogo?: NullableStringFieldUpdateOperationsInput | string | null
    FundraiserCentralID?: NullableIntFieldUpdateOperationsInput | number | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUpdateManyWithoutFundraiserNestedInput
    fundraiser_contactlinks?: fundraiser_contactlinksUpdateManyWithoutFundraiserNestedInput
  }

  export type fundraiserUncheckedUpdateWithoutBasecountryInput = {
    FundraiserID?: IntFieldUpdateOperationsInput | number
    FundraiserName?: StringFieldUpdateOperationsInput | string
    FundraiserEmail?: StringFieldUpdateOperationsInput | string
    FundraiserLogo?: NullableStringFieldUpdateOperationsInput | string | null
    FundraiserCentralID?: NullableIntFieldUpdateOperationsInput | number | null
    fundraiser_acceptedcurrencies?: fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutFundraiserNestedInput
    fundraiser_contactlinks?: fundraiser_contactlinksUncheckedUpdateManyWithoutFundraiserNestedInput
  }

  export type fundraiserUncheckedUpdateManyWithoutBasecountryInput = {
    FundraiserID?: IntFieldUpdateOperationsInput | number
    FundraiserName?: StringFieldUpdateOperationsInput | string
    FundraiserEmail?: StringFieldUpdateOperationsInput | string
    FundraiserLogo?: NullableStringFieldUpdateOperationsInput | string | null
    FundraiserCentralID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type exchangeratesCreateManyCurrencyInput = {
    ExchangeRateId?: number
    BaseCountryId: number
    ExchangeRate: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type fundraiser_acceptedcurrenciesCreateManyCurrencyInput = {
    FundraiserAcceptedCurrencyID?: number
    FundraiserID?: number | null
  }

  export type minimumamountCreateManyCurrencyInput = {
    MinimumAmountId?: number
    Amount: Decimal | DecimalJsLike | number | string
    CreateAt?: Date | string
    UpdatedAt?: Date | string
  }

  export type walletCreateManyCurrencyInput = {
    WalletId?: number
    WalletName?: string | null
  }

  export type exchangeratesUpdateWithoutCurrencyInput = {
    ExchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    basecountry?: basecountryUpdateOneRequiredWithoutExchangeratesNestedInput
  }

  export type exchangeratesUncheckedUpdateWithoutCurrencyInput = {
    ExchangeRateId?: IntFieldUpdateOperationsInput | number
    BaseCountryId?: IntFieldUpdateOperationsInput | number
    ExchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type exchangeratesUncheckedUpdateManyWithoutCurrencyInput = {
    ExchangeRateId?: IntFieldUpdateOperationsInput | number
    BaseCountryId?: IntFieldUpdateOperationsInput | number
    ExchangeRate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type fundraiser_acceptedcurrenciesUpdateWithoutCurrencyInput = {
    fundraiser?: fundraiserUpdateOneWithoutFundraiser_acceptedcurrenciesNestedInput
  }

  export type fundraiser_acceptedcurrenciesUncheckedUpdateWithoutCurrencyInput = {
    FundraiserAcceptedCurrencyID?: IntFieldUpdateOperationsInput | number
    FundraiserID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutCurrencyInput = {
    FundraiserAcceptedCurrencyID?: IntFieldUpdateOperationsInput | number
    FundraiserID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type minimumamountUpdateWithoutCurrencyInput = {
    Amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type minimumamountUncheckedUpdateWithoutCurrencyInput = {
    MinimumAmountId?: IntFieldUpdateOperationsInput | number
    Amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type minimumamountUncheckedUpdateManyWithoutCurrencyInput = {
    MinimumAmountId?: IntFieldUpdateOperationsInput | number
    Amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type walletUpdateWithoutCurrencyInput = {
    WalletName?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUpdateManyWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateWithoutCurrencyInput = {
    WalletId?: IntFieldUpdateOperationsInput | number
    WalletName?: NullableStringFieldUpdateOperationsInput | string | null
    transactions?: transactionsUncheckedUpdateManyWithoutWalletNestedInput
  }

  export type walletUncheckedUpdateManyWithoutCurrencyInput = {
    WalletId?: IntFieldUpdateOperationsInput | number
    WalletName?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type customerauditlogsCreateManyCustomerInput = {
    LogId?: number
    AgentId: number
    FieldChanged: $Enums.customerauditlogs_FieldChanged
    OldValue?: string | null
    NewValue?: string | null
    ChangeDate?: Date | string
  }

  export type manychatCreateManyCustomerInput = {
    ManyChatId?: number
    ConversationId: string
    CreateAt?: Date | string
    UpdateAt?: Date | string
  }

  export type transactionsCreateManyCustomerInput = {
    TransactionID?: number
    SupportRegionID?: number | null
    WalletID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    NoteID?: number | null
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
  }

  export type customerauditlogsUpdateWithoutCustomerInput = {
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFieldUpdateOperationsInput | $Enums.customerauditlogs_FieldChanged
    OldValue?: NullableStringFieldUpdateOperationsInput | string | null
    NewValue?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDate?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: agentUpdateOneRequiredWithoutCustomerauditlogsNestedInput
  }

  export type customerauditlogsUncheckedUpdateWithoutCustomerInput = {
    LogId?: IntFieldUpdateOperationsInput | number
    AgentId?: IntFieldUpdateOperationsInput | number
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFieldUpdateOperationsInput | $Enums.customerauditlogs_FieldChanged
    OldValue?: NullableStringFieldUpdateOperationsInput | string | null
    NewValue?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerauditlogsUncheckedUpdateManyWithoutCustomerInput = {
    LogId?: IntFieldUpdateOperationsInput | number
    AgentId?: IntFieldUpdateOperationsInput | number
    FieldChanged?: Enumcustomerauditlogs_FieldChangedFieldUpdateOperationsInput | $Enums.customerauditlogs_FieldChanged
    OldValue?: NullableStringFieldUpdateOperationsInput | string | null
    NewValue?: NullableStringFieldUpdateOperationsInput | string | null
    ChangeDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type manychatUpdateWithoutCustomerInput = {
    ConversationId?: StringFieldUpdateOperationsInput | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type manychatUncheckedUpdateWithoutCustomerInput = {
    ManyChatId?: IntFieldUpdateOperationsInput | number
    ConversationId?: StringFieldUpdateOperationsInput | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type manychatUncheckedUpdateManyWithoutCustomerInput = {
    ManyChatId?: IntFieldUpdateOperationsInput | number
    ConversationId?: StringFieldUpdateOperationsInput | string
    CreateAt?: DateTimeFieldUpdateOperationsInput | Date | string
    UpdateAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionsUpdateWithoutCustomerInput = {
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUpdateManyWithoutTransactionsNestedInput
    supportregion?: supportregionUpdateOneWithoutTransactionsNestedInput
    wallet?: walletUpdateOneWithoutTransactionsNestedInput
    note?: noteUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutCustomerInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    SupportRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    WalletID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NoteID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUncheckedUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUncheckedUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateManyWithoutCustomerInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    SupportRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    WalletID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NoteID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fundraiser_acceptedcurrenciesCreateManyFundraiserInput = {
    FundraiserAcceptedCurrencyID?: number
    CurrencyID?: number | null
  }

  export type fundraiser_contactlinksCreateManyFundraiserInput = {
    ContactID?: number
    Platform?: number | null
    ContactURL: string
  }

  export type fundraiser_acceptedcurrenciesUpdateWithoutFundraiserInput = {
    currency?: currencyUpdateOneWithoutFundraiser_acceptedcurrenciesNestedInput
  }

  export type fundraiser_acceptedcurrenciesUncheckedUpdateWithoutFundraiserInput = {
    FundraiserAcceptedCurrencyID?: IntFieldUpdateOperationsInput | number
    CurrencyID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fundraiser_acceptedcurrenciesUncheckedUpdateManyWithoutFundraiserInput = {
    FundraiserAcceptedCurrencyID?: IntFieldUpdateOperationsInput | number
    CurrencyID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type fundraiser_contactlinksUpdateWithoutFundraiserInput = {
    Platform?: NullableIntFieldUpdateOperationsInput | number | null
    ContactURL?: StringFieldUpdateOperationsInput | string
  }

  export type fundraiser_contactlinksUncheckedUpdateWithoutFundraiserInput = {
    ContactID?: IntFieldUpdateOperationsInput | number
    Platform?: NullableIntFieldUpdateOperationsInput | number | null
    ContactURL?: StringFieldUpdateOperationsInput | string
  }

  export type fundraiser_contactlinksUncheckedUpdateManyWithoutFundraiserInput = {
    ContactID?: IntFieldUpdateOperationsInput | number
    Platform?: NullableIntFieldUpdateOperationsInput | number | null
    ContactURL?: StringFieldUpdateOperationsInput | string
  }

  export type transactionsCreateManyNoteInput = {
    TransactionID?: number
    CustomerID?: number | null
    SupportRegionID?: number | null
    WalletID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
  }

  export type transactionsUpdateWithoutNoteInput = {
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUpdateManyWithoutTransactionsNestedInput
    customer?: customerUpdateOneWithoutTransactionsNestedInput
    supportregion?: supportregionUpdateOneWithoutTransactionsNestedInput
    wallet?: walletUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutNoteInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    SupportRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    WalletID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUncheckedUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUncheckedUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateManyWithoutNoteInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    SupportRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    WalletID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type transactionsCreateManySupportregionInput = {
    TransactionID?: number
    CustomerID?: number | null
    WalletID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    NoteID?: number | null
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
  }

  export type transactionsUpdateWithoutSupportregionInput = {
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUpdateManyWithoutTransactionsNestedInput
    customer?: customerUpdateOneWithoutTransactionsNestedInput
    wallet?: walletUpdateOneWithoutTransactionsNestedInput
    note?: noteUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutSupportregionInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    WalletID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NoteID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUncheckedUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUncheckedUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateManyWithoutSupportregionInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    WalletID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NoteID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type formstatusCreateManyTransactionsInput = {
    FormStatusID?: number
    TransactionStatusID?: number | null
  }

  export type screenshotCreateManyTransactionsInput = {
    ScreenShotID?: number
    ScreenShotLink?: string | null
  }

  export type transactionagentCreateManyTransactionsInput = {
    TransactionAgentID?: number
    AgentID?: number | null
    LogDate?: Date | string
  }

  export type formstatusUpdateWithoutTransactionsInput = {
    transactionstatus?: transactionstatusUpdateOneWithoutFormstatusNestedInput
  }

  export type formstatusUncheckedUpdateWithoutTransactionsInput = {
    FormStatusID?: IntFieldUpdateOperationsInput | number
    TransactionStatusID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type formstatusUncheckedUpdateManyWithoutTransactionsInput = {
    FormStatusID?: IntFieldUpdateOperationsInput | number
    TransactionStatusID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type screenshotUpdateWithoutTransactionsInput = {
    ScreenShotLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type screenshotUncheckedUpdateWithoutTransactionsInput = {
    ScreenShotID?: IntFieldUpdateOperationsInput | number
    ScreenShotLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type screenshotUncheckedUpdateManyWithoutTransactionsInput = {
    ScreenShotID?: IntFieldUpdateOperationsInput | number
    ScreenShotLink?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionagentUpdateWithoutTransactionsInput = {
    LogDate?: DateTimeFieldUpdateOperationsInput | Date | string
    agent?: agentUpdateOneWithoutTransactionagentNestedInput
  }

  export type transactionagentUncheckedUpdateWithoutTransactionsInput = {
    TransactionAgentID?: IntFieldUpdateOperationsInput | number
    AgentID?: NullableIntFieldUpdateOperationsInput | number | null
    LogDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type transactionagentUncheckedUpdateManyWithoutTransactionsInput = {
    TransactionAgentID?: IntFieldUpdateOperationsInput | number
    AgentID?: NullableIntFieldUpdateOperationsInput | number | null
    LogDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type formstatusCreateManyTransactionstatusInput = {
    FormStatusID?: number
    TransactionID?: number | null
  }

  export type formstatusUpdateWithoutTransactionstatusInput = {
    transactions?: transactionsUpdateOneWithoutFormstatusNestedInput
  }

  export type formstatusUncheckedUpdateWithoutTransactionstatusInput = {
    FormStatusID?: IntFieldUpdateOperationsInput | number
    TransactionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type formstatusUncheckedUpdateManyWithoutTransactionstatusInput = {
    FormStatusID?: IntFieldUpdateOperationsInput | number
    TransactionID?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type agentCreateManyUserroleInput = {
    AgentId?: number
    AwsId?: string | null
  }

  export type agentUpdateWithoutUserroleInput = {
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: customerUpdateManyWithoutAgentNestedInput
    customerauditlogs?: customerauditlogsUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUpdateManyWithoutAgentNestedInput
    note?: noteUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUpdateManyWithoutAgentNestedInput
  }

  export type agentUncheckedUpdateWithoutUserroleInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
    customer?: customerUncheckedUpdateManyWithoutAgentNestedInput
    customerauditlogs?: customerauditlogsUncheckedUpdateManyWithoutAgentNestedInput
    formvisibilitystatus?: formvisibilitystatusUncheckedUpdateManyWithoutAgentNestedInput
    note?: noteUncheckedUpdateManyWithoutAgentNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type agentUncheckedUpdateManyWithoutUserroleInput = {
    AgentId?: IntFieldUpdateOperationsInput | number
    AwsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type transactionsCreateManyWalletInput = {
    TransactionID?: number
    CustomerID?: number | null
    SupportRegionID?: number | null
    Amount?: number | null
    PaymentCheck?: boolean | null
    PaymentCheckTime?: Date | string
    NoteID?: number | null
    TransactionDate?: Date | string
    PaymentDenied?: boolean | null
    Month?: number | null
    HopeFuelID?: number | null
  }

  export type transactionsUpdateWithoutWalletInput = {
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUpdateManyWithoutTransactionsNestedInput
    customer?: customerUpdateOneWithoutTransactionsNestedInput
    supportregion?: supportregionUpdateOneWithoutTransactionsNestedInput
    note?: noteUpdateOneWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateWithoutWalletInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    SupportRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NoteID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
    formstatus?: formstatusUncheckedUpdateManyWithoutTransactionsNestedInput
    screenshot?: screenshotUncheckedUpdateManyWithoutTransactionsNestedInput
    transactionagent?: transactionagentUncheckedUpdateManyWithoutTransactionsNestedInput
  }

  export type transactionsUncheckedUpdateManyWithoutWalletInput = {
    TransactionID?: IntFieldUpdateOperationsInput | number
    CustomerID?: NullableIntFieldUpdateOperationsInput | number | null
    SupportRegionID?: NullableIntFieldUpdateOperationsInput | number | null
    Amount?: NullableFloatFieldUpdateOperationsInput | number | null
    PaymentCheck?: NullableBoolFieldUpdateOperationsInput | boolean | null
    PaymentCheckTime?: DateTimeFieldUpdateOperationsInput | Date | string
    NoteID?: NullableIntFieldUpdateOperationsInput | number | null
    TransactionDate?: DateTimeFieldUpdateOperationsInput | Date | string
    PaymentDenied?: NullableBoolFieldUpdateOperationsInput | boolean | null
    Month?: NullableIntFieldUpdateOperationsInput | number | null
    HopeFuelID?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}